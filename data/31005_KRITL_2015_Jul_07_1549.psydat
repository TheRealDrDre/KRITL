ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cdata/31005_KRITL_2015_Jul_07_1549
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'KRITL'
p11
sS'dataNames'
p12
(lp13
S'practice_encoding.keys'
p14
aS'practice_encoding.rt'
p15
aS'practice_execution.keys'
p16
aS'practice_execution.corr'
p17
aS'practice_execution.rt'
p18
aS'encoding.keys'
p19
aS'encoding.rt'
p20
aS'execution.keys'
p21
aS'execution.corr'
p22
aS'execution.rt'
p23
asS'autoLog'
p24
I01
sS'extraInfo'
p25
(dp26
S'date'
p27
V2015_Jul_07_1549
p28
sS'frameRate'
p29
cnumpy.core.multiarray
scalar
p30
(cnumpy
dtype
p31
(S'f8'
I0
I1
tRp32
(I3
S'<'
NNNI-1
I-1
I0
tbS'h\x14\xf4W\x01\xf5q@'
tRp33
sS'expName'
p34
g11
sVsession
p35
V001
p36
sVparticipant
p37
V31005
p38
ssS'loopsUnfinished'
p39
(lp40
sS'saveWideText'
p41
I01
sS'thisEntry'
p42
(dp43
sS'version'
p44
S''
sS'_paramNamesSoFar'
p45
(lp46
Voperationc
p47
aVoperationb
p48
aVoperationa
p49
aVcorrectresponse
p50
aVvaluey
p51
aVoperationd
p52
aVcondition
p53
aVvaluex
p54
aVRule
p55
aVOperatora
p56
aVLength
p57
aVIntermediate
p58
aVCorrectResponse
p59
aVResult
p60
aVY
aVX
aVOperatorc
p61
aVOperatorb
p62
aVOperatord
p63
aVStructure
p64
asS'entries'
p65
(lp66
(dp67
g35
g36
sg47
I0
sg27
g28
sg16
Nsg29
g33
sg14
(lp68
S'space'
p69
asg53
I2
sg49
VTIMES
p70
sg17
I0
sS'practice_trials.thisN'
p71
I0
sg48
Vdecrease
p72
sS'practice_trials.thisIndex'
p73
I1
sg34
g11
sg50
I8
sS'practice_trials.thisTrialN'
p74
I0
sg52
I0
sS'practice_trials.thisRepN'
p75
I0
sg37
g38
sg54
I3
sg51
I3
sg15
(lp76
F4.0078661291699973
asa(dp77
g35
g36
sg47
Vincrease
p78
sg27
g28
sg16
Nsg29
g33
sg14
(lp79
S'space'
p80
asg53
I3
sg49
Vtriple
p81
sg17
I0
sS'practice_trials.thisN'
p82
I1
sg48
VDIVIDE
p83
sS'practice_trials.thisIndex'
p84
I4
sg34
g11
sg50
I3
sS'practice_trials.thisTrialN'
p85
I1
sg52
I0
sS'practice_trials.thisRepN'
p86
I0
sg37
g38
sg54
I2
sg51
I3
sg15
(lp87
F8.909000395809926
asa(dp88
g18
F6.5989271519520116
sg29
g33
sg17
I1
sg47
I0
sg48
VADD
p89
sg49
Vhalf
p90
sg35
g36
sg50
I7
sS'practice_trials.thisTrialN'
p91
I2
sg52
I0
sS'practice_trials.thisRepN'
p92
I0
sg37
g38
sg53
I2
sg27
g28
sg16
S'7'
sg14
(lp93
S'space'
p94
asS'practice_trials.thisIndex'
p95
I2
sS'practice_trials.thisN'
p96
I2
sg34
g11
sg15
(lp97
F5.9897954148473218
asg51
I5
sg54
I4
sa(dp98
g18
F9.5404346056493523
sg29
g33
sg17
I0
sg47
g89
sg48
Vtriple 
p99
sg49
g90
sg35
g36
sg50
I8
sS'practice_trials.thisTrialN'
p100
I3
sg52
I0
sS'practice_trials.thisRepN'
p101
I0
sg37
g38
sg53
I3
sg27
g28
sg16
S'6'
sg14
(lp102
S'space'
p103
asS'practice_trials.thisIndex'
p104
I3
sS'practice_trials.thisN'
p105
I3
sg34
g11
sg15
(lp106
F11.002404949042102
asg51
I2
sg54
I4
sa(dp107
g18
F5.2633093736658338
sg29
g33
sg17
I1
sg47
I0
sg48
g89
sg49
g72
sg35
g36
sg50
I7
sS'practice_trials.thisTrialN'
p108
I4
sg52
I0
sS'practice_trials.thisRepN'
p109
I0
sg37
g38
sg53
I2
sg27
g28
sg16
S'7'
sg14
(lp110
S'space'
p111
asS'practice_trials.thisIndex'
p112
I0
sS'practice_trials.thisN'
p113
I4
sg34
g11
sg15
(lp114
F3.4347816805311595
asg51
I5
sg54
I3
sa(dp115
g18
F18.286374416829858
sg29
g33
sg17
I0
sg47
g78
sg48
g83
sg49
Vdouble
p116
sg35
g36
sg50
I9
sS'practice_trials.thisTrialN'
p117
I5
sg52
g81
sS'practice_trials.thisRepN'
p118
I0
sg37
g38
sg53
I4
sg27
g28
sg16
S'2'
sg14
(lp119
S'space'
p120
asS'practice_trials.thisIndex'
p121
I5
sS'practice_trials.thisN'
p122
I5
sg34
g11
sg15
(lp123
F16.223053424375394
asg51
I8
sg54
I8
sa(dp124
S'block.thisTrialN'
p125
I0
sS'block.thisRepN'
p126
I0
sg29
g33
sS'block.thisN'
p127
I0
sg55
(S'THIRD'
S'DOUBLE'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp128
sg27
g28
sg57
I4
sg58
(I10
I12
I24
I8
tp129
sg22
I0
sg20
F14.839720225194469
sVY
I2
sVX
I9
sg61
VADD
p130
sg35
g36
sg37
g38
sg21
Nsg19
S'space'
p131
sg34
g11
sg60
I8
sg56
Vdouble
p132
sg59
I8
sS'block.thisIndex'
p133
I14
sg62
Vthird
p134
sg63
Vincrease
p135
sg64
VUUBUxy
p136
sa(dp137
S'block.thisTrialN'
p138
I1
sS'block.thisRepN'
p139
I0
sg29
g33
sS'block.thisN'
p140
I1
sg55
(S'TIMES'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp141
sg27
g28
sg57
I3
sg58
(I4
I3
I9
tp142
sg22
I1
sg20
F4.6021128695228981
sg23
F7.9396540470988839
sVY
I3
sVX
I8
sg61
Vhalf
p143
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p144
sg34
g11
sg60
I9
sg56
Vdecrease
p145
sg59
I9
sS'block.thisIndex'
p146
I4
sg62
VTIMES
p147
sg63
I0
sg64
VBUUxy
p148
sa(dp149
S'block.thisTrialN'
p150
I2
sS'block.thisRepN'
p151
I0
sg29
g33
sS'block.thisN'
p152
I2
sg55
(S'THIRD'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp153
sg27
g28
sg57
I3
sg58
(I3
I15
I5
tp154
sg22
I1
sg20
F6.536083859649807
sg23
F4.2963042806477461
sVY
I5
sVX
I4
sg61
g145
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p155
sg34
g11
sg60
I5
sg56
g147
sg59
I5
sS'block.thisIndex'
p156
I7
sg62
g134
sg63
I0
sg64
VUBUxy
p157
sa(dp158
S'block.thisTrialN'
p159
I3
sS'block.thisRepN'
p160
I0
sg29
g33
sS'block.thisN'
p161
I3
sg55
(S'TRIPLE'
S'HALF'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp162
sg27
g28
sg57
I4
sg58
(I1
I4
I2
I6
tp163
sg22
I0
sg20
F7.0438217272021575
sg23
F10.340973619402575
sVY
I3
sVX
I2
sg61
g130
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p164
sg34
g11
sg60
I6
sg56
g143
sg59
I6
sS'block.thisIndex'
p165
I15
sg62
Vtriple
p166
sg63
g145
sg64
g136
sa(dp167
S'block.thisTrialN'
p168
I4
sS'block.thisRepN'
p169
I0
sg29
g33
sS'block.thisN'
p170
I4
sg55
(S'TRIPLE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp171
sg27
g28
sg57
I3
sg58
(I2
I1
I3
tp172
sg22
I1
sg20
F3.1806556985775387
sg23
F5.8213292942873522
sVY
I2
sVX
I4
sg61
VDIVIDE
p173
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p174
sg34
g11
sg60
I3
sg56
g143
sg59
I3
sS'block.thisIndex'
p175
I9
sg62
g166
sg63
I0
sg64
VUUBxy
p176
sa(dp177
S'block.thisTrialN'
p178
I5
sS'block.thisRepN'
p179
I0
sg29
g33
sS'block.thisN'
p180
I5
sg55
(S'THIRD'
S'INCREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp181
sg27
g28
sg57
I4
sg58
(I4
I2
I3
I1
tp182
sg22
I0
sg20
F9.5248353334318381
sg23
F12.285532054729629
sVY
I2
sVX
I8
sg61
g143
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p183
sg34
g11
sg60
I1
sg56
g135
sg59
I1
sS'block.thisIndex'
p184
I16
sg62
g134
sg63
g173
sg64
VUUUBxy
p185
sa(dp186
S'block.thisTrialN'
p187
I6
sS'block.thisRepN'
p188
I0
sg29
g33
sS'block.thisN'
p189
I6
sg55
(S'TIMES'
S'INCREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp190
sg27
g28
sg57
I4
sg58
(I6
I2
I3
I9
tp191
sg22
I0
sg20
F9.8221226615005435
sg23
F14.754073662414157
sVY
I3
sVX
I3
sg61
g134
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p192
sg34
g11
sg60
I9
sg56
g135
sg59
I9
sS'block.thisIndex'
p193
I11
sg62
g147
sg63
g132
sg64
VBUUUxy
p194
sa(dp195
S'block.thisTrialN'
p196
I7
sS'block.thisRepN'
p197
I0
sg29
g33
sS'block.thisN'
p198
I7
sg55
(S'TIMES'
S'INCREASE'
S'x'
S'y'
tp199
sg27
g28
sg57
I2
sg58
(I3
I6
tp200
sg22
I1
sg20
F3.8641921215530601
sg23
F2.4373049172318133
sVY
I2
sVX
I2
sg61
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p201
sg34
g11
sg60
I6
sg56
g135
sg59
I6
sS'block.thisIndex'
p202
I1
sg62
g147
sg63
I0
sg64
VBUxy
p203
sa(dp204
S'block.thisTrialN'
p205
I8
sS'block.thisRepN'
p206
I0
sg29
g33
sS'block.thisN'
p207
I8
sg55
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp208
sg27
g28
sg57
I4
sg58
(I6
I3
I2
I6
tp209
sg22
I0
sg20
F8.4268035630484519
sg23
F9.9258728351687751
sVY
I2
sVX
I3
sg61
g143
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p210
sg34
g11
sg60
I6
sg56
g145
sg59
I6
sS'block.thisIndex'
p211
I17
sg62
g166
sg63
g147
sg64
g185
sa(dp212
S'block.thisTrialN'
p213
I9
sS'block.thisRepN'
p214
I0
sg29
g33
sS'block.thisN'
p215
I9
sg55
(S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp216
sg27
g28
sg57
I4
sg58
(I2
I4
I1
I3
tp217
sg22
I0
sg20
F12.500931427804971
sg23
F17.339948576365714
sVY
I3
sVX
I3
sg61
g132
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p218
sg34
g11
sg60
I3
sg56
VSUBTRACT
p219
sg59
I3
sS'block.thisIndex'
p220
I13
sg62
g166
sg63
g145
sg64
VUBUUxy
p221
sa(dp222
S'block.thisTrialN'
p223
I10
sS'block.thisRepN'
p224
I0
sg29
g33
sS'block.thisN'
p225
I10
sg55
(S'THIRD'
S'DECREASE'
S'TIMES'
S'x'
S'y'
tp226
sg27
g28
sg57
I3
sg58
(I25
I24
I8
tp227
sg22
I1
sg20
F9.3631840517446108
sg23
F6.0283624403800786
sVY
I5
sVX
I5
sg61
g147
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p228
sg34
g11
sg60
I8
sg56
g145
sg59
I8
sS'block.thisIndex'
p229
I8
sg62
Vthid
p230
sg63
I0
sg64
g176
sa(dp231
S'block.thisTrialN'
p232
I11
sS'block.thisRepN'
p233
I0
sg29
g33
sS'block.thisN'
p234
I11
sg55
(S'TIMES'
S'DECREASE'
S'x'
S'y'
tp235
sg27
g28
sg57
I2
sg58
(I2
I4
tp236
sg22
I1
sg20
F2.6737787411893805
sg23
F2.1592890281899599
sVY
I2
sVX
I3
sg61
I0
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p237
sg34
g11
sg60
I4
sg56
g145
sg59
I4
sS'block.thisIndex'
p238
I0
sg62
g147
sg63
I0
sg64
g203
sa(dp239
S'block.thisTrialN'
p240
I12
sS'block.thisRepN'
p241
I0
sg29
g33
sS'block.thisN'
p242
I12
sg55
(S'THIRD'
S'SUBTRACT'
S'x'
S'y'
tp243
sg27
g28
sg57
I2
sg58
(I3
I1
tp244
sg22
I1
sg20
F2.4760878702309128
sg23
F2.116149379811759
sVY
I2
sVX
I5
sg61
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p245
sg34
g11
sg60
I1
sg56
g219
sg59
I1
sS'block.thisIndex'
p246
I3
sg62
g134
sg63
I0
sg64
VUBxy
p247
sa(dp248
S'block.thisTrialN'
p249
I13
sS'block.thisRepN'
p250
I0
sg29
g33
sS'block.thisN'
p251
I13
sg55
(S'THIRD'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp252
sg27
g28
sg57
I3
sg58
(I8
I15
I5
tp253
sg22
I1
sg20
F6.0117185271719791
sg23
F6.7103226278341026
sVY
I7
sVX
I7
sg61
g135
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p254
sg34
g11
sg60
I5
sg56
g130
sg59
I5
sS'block.thisIndex'
p255
I6
sg62
g134
sg63
I0
sg64
g157
sa(dp256
S'block.thisTrialN'
p257
I14
sS'block.thisRepN'
p258
I0
sg29
g33
sS'block.thisN'
p259
I14
sg55
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp260
sg27
g28
sg57
I4
sg58
(I6
I18
I3
I4
tp261
sg22
I1
sg20
F8.4206711529641325
sg23
F5.2008832378342049
sVY
I6
sVX
I3
sg61
g166
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p262
sg34
g11
sg60
I4
sg56
g173
sg59
I4
sS'block.thisIndex'
p263
I12
sg62
g135
sg63
g132
sg64
g221
sa(dp264
S'block.thisTrialN'
p265
I15
sS'block.thisRepN'
p266
I0
sg29
g33
sS'block.thisN'
p267
I15
sg55
(S'TIMES'
S'THIRD'
S'HALF'
S'x'
S'y'
tp268
sg27
g28
sg57
I3
sg58
(I3
I1
I5
tp269
sg22
I0
sg20
F11.077690842959782
sg23
F16.412874666528296
sVY
I5
sVX
I6
sg61
g143
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p270
sg34
g11
sg60
I5
sg56
g134
sg59
I5
sS'block.thisIndex'
p271
I5
sg62
g147
sg63
I0
sg64
g148
sa(dp272
S'block.thisTrialN'
p273
I16
sS'block.thisRepN'
p274
I0
sg29
g33
sS'block.thisN'
p275
I16
sg55
(S'SUBTRACT'
S'HALF'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp276
sg27
g28
sg57
I4
sg58
(I15
I16
I8
I3
tp277
sg22
I0
sg20
F15.358406000334071
sg23
F10.614139714522025
sVY
I5
sVX
I5
sg61
g135
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p278
sg34
g11
sg60
I3
sg56
g143
sg59
I3
sS'block.thisIndex'
p279
I10
sg62
g219
sg63
g166
sg64
g194
sa(dp280
S'block.thisTrialN'
p281
I17
sS'block.thisRepN'
p282
I0
sg29
g33
sS'block.thisN'
p283
I17
sg55
(S'THIRD'
S'ADD'
S'x'
S'y'
tp284
sg27
g28
sg57
I2
sg58
(I9
I3
tp285
sg22
I1
sg20
F2.271292740602803
sg23
F3.1043556104923482
sVY
I5
sVX
I4
sg61
I0
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p286
sg34
g11
sg60
I3
sg56
g130
sg59
I3
sS'block.thisIndex'
p287
I2
sg62
g134
sg63
I0
sg64
g247
sa(dp288
S'block.thisTrialN'
p289
I0
sS'block.thisRepN'
p290
I0
sg29
g33
sS'block.thisN'
p291
I0
sVRule
p292
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp293
sg27
g28
sVLength
p294
I4
sVIntermediate
p295
(I5
I1
I2
I6
tp296
sg22
I1
sg20
F12.293613411440674
sg23
F15.307544757704818
sVY
I4
sVX
I4
sVOperatorc
p297
VSUBTRACT
p298
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p299
sg34
g11
sVResult
p300
I6
sVOperatora
p301
Vdouble
p302
sVCorrectResponse
p303
I6
sS'block.thisIndex'
p304
I14
sVOperatorb
p305
Vtriple
p306
sVOperatord
p307
Vincrease
p308
sVStructure
p309
VUUBUxy
p310
sa(dp311
S'block.thisTrialN'
p312
I1
sS'block.thisRepN'
p313
I0
sg29
g33
sS'block.thisN'
p314
I1
sg292
(S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp315
sg27
g28
sg294
I4
sg295
(I16
I2
I3
I9
tp316
sg22
I0
sg20
F19.591117366902836
sVY
I8
sVX
I8
sg297
VDIVIDE
p317
sg35
g36
sg37
g38
sg21
Nsg19
S'space'
p318
sg34
g11
sg300
I9
sg301
g308
sg303
I9
sS'block.thisIndex'
p319
I15
sg305
g306
sg307
g302
sg309
g310
sa(dp320
S'block.thisTrialN'
p321
I2
sS'block.thisRepN'
p322
I0
sg29
g33
sS'block.thisN'
p323
I2
sg292
(S'INCREASE'
S'TIMES'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp324
sg27
g28
sg294
I4
sg295
(I1
I3
I6
I7
tp325
sg22
I0
sg20
F10.532512832287466
sg23
F9.2306703795456997
sVY
I2
sVX
I2
sg297
g306
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p326
sg34
g11
sg300
I7
sg301
VTIMES
p327
sg303
I7
sS'block.thisIndex'
p328
I13
sg305
g308
sg307
Vhalf
p329
sg309
VUBUUxy
p330
sa(dp331
S'block.thisTrialN'
p332
I3
sS'block.thisRepN'
p333
I0
sg29
g33
sS'block.thisN'
p334
I3
sg292
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp335
sg27
g28
sg294
I4
sg295
(I9
I10
I20
I5
tp336
sg22
I0
sg20
F8.6337285704248643
sg23
F8.7266606729590421
sVY
I4
sVX
I3
sg297
g308
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p337
sg34
g11
sg300
I5
sg301
g302
sg303
I5
sS'block.thisIndex'
p338
I10
sg305
g317
sg307
g306
sg309
VBUUUxy
p339
sa(dp340
S'block.thisTrialN'
p341
I4
sS'block.thisRepN'
p342
I0
sg29
g33
sS'block.thisN'
p343
I4
sg292
(S'TIMES'
S'HALF'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp344
sg27
g28
sg294
I4
sg295
(I1
I2
I1
I9
tp345
sg22
I0
sg20
F8.4816718875390507
sg23
F8.7269150964093569
sVY
I9
sVX
I3
sg297
g308
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p346
sg34
g11
sg300
I9
sg301
g329
sg303
I9
sS'block.thisIndex'
p347
I11
sg305
g327
sg307
Vthird
p348
sg309
g339
sa(dp349
S'block.thisTrialN'
p350
I5
sS'block.thisRepN'
p351
I0
sg29
g33
sS'block.thisN'
p352
I5
sg292
(S'HALF'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp353
sg27
g28
sg294
I3
sg295
(I8
I16
I8
tp354
sg22
I1
sg20
F5.3477706101366493
sg23
F5.8752551671241235
sVY
I2
sVX
I9
sg297
Vdecrease
p355
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p356
sg34
g11
sg300
I8
sg301
g327
sg303
I8
sS'block.thisIndex'
p357
I6
sg305
g329
sg307
I0
sg309
VUBUxy
p358
sa(dp359
S'block.thisTrialN'
p360
I6
sS'block.thisRepN'
p361
I0
sg29
g33
sS'block.thisN'
p362
I6
sg292
(S'HALF'
S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp363
sg27
g28
sg294
I4
sg295
(I15
I14
I10
I5
tp364
sg22
I0
sg20
F5.643113891064786
sg23
F16.006038269906639
sVY
I4
sVX
I5
sg297
g355
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p365
sg34
g11
sg300
I5
sg301
g298
sg303
I5
sS'block.thisIndex'
p366
I12
sg305
g329
sg307
g306
sg309
g330
sa(dp367
S'block.thisTrialN'
p368
I7
sS'block.thisRepN'
p369
I0
sg29
g33
sS'block.thisN'
p370
I7
sg292
(S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp371
sg27
g28
sg294
I3
sg295
(I4
I5
I3
tp372
sg22
I0
sg20
F4.7179483320924192
sg23
F9.2832446934153268
sVY
I2
sVX
I8
sg297
g329
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p373
sg34
g11
sg300
I3
sg301
g308
sg303
I3
sS'block.thisIndex'
p374
I5
sg305
g298
sg307
I0
sg309
VBUUxy
p375
sa(dp376
S'block.thisTrialN'
p377
I8
sS'block.thisRepN'
p378
I0
sg29
g33
sS'block.thisN'
p379
I8
sg292
(S'DECREASE'
S'THIRD'
S'DOUBLE'
S'ADD'
S'x'
S'y'
tp380
sg27
g28
sg294
I4
sg295
(I9
I18
I6
I5
tp381
sg22
I1
sg20
F10.999052648856377
sg23
F6.8592849336182553
sVY
I4
sVX
I5
sg297
g302
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p382
sg34
g11
sg300
I5
sg301
g348
sg303
I5
sS'block.thisIndex'
p383
I16
sg305
g355
sg307
VADD
p384
sg309
VUUUBxy
p385
sa(dp386
S'block.thisTrialN'
p387
I9
sS'block.thisRepN'
p388
I0
sg29
g33
sS'block.thisN'
p389
I9
sg292
(S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp390
sg27
g28
sg294
I3
sg295
(I1
I2
I6
tp391
sg22
I1
sg20
F5.2267465889926825
sg23
F15.798089969312059
sVY
I2
sVX
I3
sg297
g298
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p392
sg34
g11
sg300
I6
sg301
g308
sg303
I6
sS'block.thisIndex'
p393
I9
sg305
g306
sg307
I0
sg309
VUUBxy
p394
sa(dp395
S'block.thisTrialN'
p396
I10
sS'block.thisRepN'
p397
I0
sg29
g33
sS'block.thisN'
p398
I10
sg292
(S'DOUBLE'
S'DIVIDE'
S'x'
S'y'
tp399
sg27
g28
sg294
I2
sg295
(I1
I2
tp400
sg22
I1
sg20
F7.3185892552100995
sg23
F2.5715183620577591
sVY
I8
sVX
I8
sg297
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p401
sg34
g11
sg300
I2
sg301
g317
sg303
I2
sS'block.thisIndex'
p402
I2
sg305
Vdpuble
p403
sg307
I0
sg309
VUBxy
p404
sa(dp405
S'block.thisTrialN'
p406
I11
sS'block.thisRepN'
p407
I0
sg29
g33
sS'block.thisN'
p408
I11
sg292
(S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp409
sg27
g28
sg294
I3
sg295
(I6
I3
I9
tp410
sg22
I0
sg20
F2.2655302419188956
sg23
F13.182493706783134
sVY
I3
sVX
I3
sg297
g384
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p411
sg34
g11
sg300
I9
sg301
g329
sg303
I9
sS'block.thisIndex'
p412
I8
sg305
g306
sg307
I0
sg309
g394
sa(dp413
S'block.thisTrialN'
p414
I12
sS'block.thisRepN'
p415
I0
sg29
g33
sS'block.thisN'
p416
I12
sg292
(S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp417
sg27
g28
sg294
I2
sg295
(I12
I9
tp418
sg22
I1
sg20
F1.692714565235292
sg23
F3.5417595673879987
sVY
I3
sVX
I4
sg297
I0
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p419
sg34
g11
sg300
I9
sg301
g306
sg303
I9
sS'block.thisIndex'
p420
I1
sg305
g298
sg307
I0
sg309
VBUxy
p421
sa(dp422
S'block.thisTrialN'
p423
I13
sS'block.thisRepN'
p424
I0
sg29
g33
sS'block.thisN'
p425
I13
sg292
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'x'
S'y'
tp426
sg27
g28
sg294
I3
sg295
(I6
I2
I3
tp427
sg22
I1
sg20
F5.6807167672068317
sg23
F4.8078571001115051
sVY
I3
sVX
I2
sg297
g306
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p428
sg34
g11
sg300
I3
sg301
g317
sg303
I3
sS'block.thisIndex'
p429
I7
sg305
g308
sg307
I0
sg309
g358
sa(dp430
S'block.thisTrialN'
p431
I14
sS'block.thisRepN'
p432
I0
sg29
g33
sS'block.thisN'
p433
I14
sg292
(S'ADD'
S'HALF'
S'x'
S'y'
tp434
sg27
g28
sg294
I2
sg295
(I2
I7
tp435
sg22
I1
sg20
F2.2988198181519692
sg23
F2.3994882134047657
sVY
I5
sVX
I4
sg297
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p436
sg34
g11
sg300
I7
sg301
g329
sg303
I7
sS'block.thisIndex'
p437
I0
sg305
g384
sg307
I0
sg309
g421
sa(dp438
S'block.thisTrialN'
p439
I15
sS'block.thisRepN'
p440
I0
sg29
g33
sS'block.thisN'
p441
I15
sg292
(S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp442
sg27
g28
sg294
I2
sg295
(I4
I5
tp443
sg22
I1
sg20
F6.3704706413882377
sg23
F2.9520683016726252
sVY
I2
sVX
I8
sg297
I0
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p444
sg34
g11
sg300
I5
sg301
g317
sg303
I5
sS'block.thisIndex'
p445
I3
sg305
g308
sg307
I0
sg309
g404
sa(dp446
S'block.thisTrialN'
p447
I16
sS'block.thisRepN'
p448
I0
sg29
g33
sS'block.thisN'
p449
I16
sg292
(S'DIVIDE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp450
sg27
g28
sg294
I3
sg295
(I6
I18
I9
tp451
sg22
I1
sg20
F5.7721300282319135
sg23
F5.9143257901032484
sVY
I2
sVX
I7
sg297
g355
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p452
sg34
g11
sg300
I9
sg301
g306
sg303
I9
sS'block.thisIndex'
p453
I4
sg305
g317
sg307
I0
sg309
g375
sa(dp454
S'block.thisTrialN'
p455
I17
sS'block.thisRepN'
p456
I0
sg29
g33
sS'block.thisN'
p457
I17
sg292
(S'THIRD'
S'INCREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp458
sg27
g28
sg294
I4
sg295
(I28
I14
I15
I5
tp459
sg22
I0
sg20
F13.430121566814705
sg23
F10.517403858908438
sVY
I4
sVX
I7
sg297
g329
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p460
sg34
g11
sg300
I5
sg301
g308
sg303
I5
sS'block.thisIndex'
p461
I17
sg305
g348
sg307
g327
sg309
g385
sa(dp462
S'block.thisTrialN'
p463
I0
sS'block.thisRepN'
p464
I0
sg29
g33
sS'block.thisN'
p465
I0
sVRule
p466
(S'SUBTRACT'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp467
sg27
g28
sVLength
p468
I3
sVIntermediate
p469
(I12
I6
I2
tp470
sg22
I1
sg20
F13.494901207059229
sg23
F7.4592451777662063
sVY
I4
sVX
I4
sVOperatorc
p471
Vtriple
p472
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p473
sg34
g11
sVResult
p474
I2
sVOperatora
p475
Vhalf
p476
sVCorrectResponse
p477
I2
sS'block.thisIndex'
p478
I5
sVOperatorb
p479
VSUBTRACT
p480
sVOperatord
p481
I0
sVStructure
p482
VBUUxy
p483
sa(dp484
S'block.thisTrialN'
p485
I1
sS'block.thisRepN'
p486
I0
sg29
g33
sS'block.thisN'
p487
I1
sg466
(S'ADD'
S'THIRD'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp488
sg27
g28
sg468
I4
sg469
(I2
I3
I1
I7
tp489
sg22
I0
sg20
F8.0324118678217928
sg23
F17.995120109217169
sVY
I6
sVX
I4
sg471
Vincrease
p490
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p491
sg34
g11
sg474
I7
sg475
Vthird
p492
sg477
I7
sS'block.thisIndex'
p493
I10
sg479
VADD
p494
sg481
g476
sg482
VBUUUxy
p495
sa(dp496
S'block.thisTrialN'
p497
I2
sS'block.thisRepN'
p498
I0
sg29
g33
sS'block.thisN'
p499
I2
sg466
(S'DECREASE'
S'ADD'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp500
sg27
g28
sg468
I4
sg469
(I3
I6
I10
I9
tp501
sg22
I1
sg20
F9.6267272010154556
sg23
F12.237939471016944
sVY
I4
sVX
I9
sg471
Vdouble
p502
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p503
sg34
g11
sg474
I9
sg475
g494
sg477
I9
sS'block.thisIndex'
p504
I12
sg479
Vdecrease 
p505
sg481
g492
sg482
VUBUUxy
p506
sa(dp507
S'block.thisTrialN'
p508
I3
sS'block.thisRepN'
p509
I0
sg29
g33
sS'block.thisN'
p510
I3
sg466
(S'INCREASE'
S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp511
sg27
g28
sg468
I3
sg469
(I3
I1
I2
tp512
sg22
I1
sg20
F16.749681970686652
sg23
F4.1293517521444301
sVY
I3
sVX
I9
sg471
g492
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p513
sg34
g11
sg474
I2
sg475
VDIVIDE
p514
sg477
I2
sS'block.thisIndex'
p515
I7
sg479
g490
sg481
I0
sg482
VUBUxy
p516
sa(dp517
S'block.thisTrialN'
p518
I4
sS'block.thisRepN'
p519
I0
sg29
g33
sS'block.thisN'
p520
I4
sg466
(S'DOUBLE'
S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp521
sg27
g28
sg468
I3
sg469
(I1
I3
I6
tp522
sg22
I1
sg20
F5.1801720490475418
sg23
F5.9786371792088175
sVY
I3
sVX
I4
sg471
g480
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p523
sg34
g11
sg474
I6
sg475
g472
sg477
I6
sS'block.thisIndex'
p524
I9
sg479
g502
sg481
I0
sg482
VUUBxy
p525
sa(dp526
S'block.thisTrialN'
p527
I5
sS'block.thisRepN'
p528
I0
sg29
g33
sS'block.thisN'
p529
I5
sg466
(S'DECREASE'
S'TIMES'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp530
sg27
g28
sg468
I4
sg469
(I1
I2
I8
I7
tp531
sg22
I0
sg20
F11.543497486038177
sg23
F10.980458389167325
sVY
I4
sVX
I3
sg471
g502
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p532
sg34
g11
sg474
I7
sg475
VTIMES
p533
sg477
I7
sS'block.thisIndex'
p534
I13
sg479
Vdecrease
p535
sg481
g492
sg482
g506
sa(dp536
S'block.thisTrialN'
p537
I6
sS'block.thisRepN'
p538
I0
sg29
g33
sS'block.thisN'
p539
I6
sg466
(S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp540
sg27
g28
sg468
I2
sg469
(I12
I2
tp541
sg22
I1
sg20
F3.7868302442639106
sg23
F4.3885025097624748
sVY
I6
sVX
I6
sg471
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p542
sg34
g11
sg474
I2
sg475
g502
sg477
I2
sS'block.thisIndex'
p543
I1
sg479
g514
sg481
I0
sg482
VBUxy
p544
sa(dp545
S'block.thisTrialN'
p546
I7
sS'block.thisRepN'
p547
I0
sg29
g33
sS'block.thisN'
p548
I7
sg466
(S'DIVIDE'
S'INCREASE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp549
sg27
g28
sg468
I4
sg469
(I2
I4
I5
I1
tp550
sg22
I1
sg20
F9.5093784963537473
sg23
F12.338874538441814
sVY
I5
sVX
I6
sg471
g502
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p551
sg34
g11
sg474
I1
sg475
g490
sg477
I1
sS'block.thisIndex'
p552
I11
sg479
g514
sg481
g492
sg482
g495
sa(dp553
S'block.thisTrialN'
p554
I8
sS'block.thisRepN'
p555
I0
sg29
g33
sS'block.thisN'
p556
I8
sg466
(S'DOUBLE'
S'SUBTRACT'
S'x'
S'y'
tp557
sg27
g28
sg468
I2
sg469
(I1
I2
tp558
sg22
I1
sg20
F7.1551633087092341
sg23
F1.9718625861405599
sVY
I7
sVX
I8
sg471
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p559
sg34
g11
sg474
I2
sg475
g480
sg477
I2
sS'block.thisIndex'
p560
I2
sg479
g502
sg481
I0
sg482
VUBxy
p561
sa(dp562
S'block.thisTrialN'
p563
I9
sS'block.thisRepN'
p564
I0
sg29
g33
sS'block.thisN'
p565
I9
sg466
(S'DOUBLE'
S'DECREASE'
S'SUBTRACT'
S'x'
S'y'
tp566
sg27
g28
sg468
I3
sg469
(I5
I4
I8
tp567
sg22
I0
sg20
F8.3778303734015935
sg23
F11.047521891090582
sVY
I2
sVX
I7
sg471
g480
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p568
sg34
g11
sg474
I8
sg475
g535
sg477
I8
sS'block.thisIndex'
p569
I8
sg479
g502
sg481
I0
sg482
g525
sa(dp570
S'block.thisTrialN'
p571
I10
sS'block.thisRepN'
p572
I0
sg29
g33
sS'block.thisN'
p573
I10
sg466
(S'HALF'
S'TIMES'
S'x'
S'y'
tp574
sg27
g28
sg468
I2
sg469
(I16
I8
tp575
sg22
I1
sg20
F2.7259026520569023
sg23
F2.594442369938406
sVY
I4
sVX
I4
sg471
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p576
sg34
g11
sg474
I8
sg475
g533
sg477
I8
sS'block.thisIndex'
p577
I3
sg479
g476
sg481
I0
sg482
g561
sa(dp578
S'block.thisTrialN'
p579
I11
sS'block.thisRepN'
p580
I0
sg29
g33
sS'block.thisN'
p581
I11
sg466
(S'ADD'
S'DOUBLE'
S'x'
S'y'
tp582
sg27
g28
sg468
I2
sg469
(I4
I8
tp583
sg22
I1
sg20
F1.9465906732621079
sg23
F3.539476055673731
sVY
I4
sVX
I2
sg471
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p584
sg34
g11
sg474
I8
sg475
g502
sg477
I8
sS'block.thisIndex'
p585
I0
sg479
g494
sg481
I0
sg482
g544
sa(dp586
S'block.thisTrialN'
p587
I12
sS'block.thisRepN'
p588
I0
sg29
g33
sS'block.thisN'
p589
I12
sg466
(S'DOUBLE'
S'TRIPLE'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp590
sg27
g28
sg468
I4
sg469
(I8
I1
I3
I6
tp591
sg22
I1
sg20
F13.536543011736285
sg23
F8.0715510836434987
sVY
I8
sVX
I9
sg471
g514
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p592
sg34
g11
sg474
I6
sg475
g472
sg477
I6
sS'block.thisIndex'
p593
I15
sg479
g502
sg481
g535
sg482
VUUBUxy
p594
sa(dp595
S'block.thisTrialN'
p596
I13
sS'block.thisRepN'
p597
I0
sg29
g33
sS'block.thisN'
p598
I13
sg466
(S'DIVIDE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp599
sg27
g28
sg468
I3
sg469
(I2
I4
I1
tp600
sg22
I1
sg20
F12.255446744133224
sg23
F3.9619750679030403
sVY
I4
sVX
I6
sg471
g492
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p601
sg34
g11
sg474
I1
sg475
g502
sg477
I1
sS'block.thisIndex'
p602
I4
sg479
g514
sg481
I0
sg482
g483
sa(dp603
S'block.thisTrialN'
p604
I14
sS'block.thisRepN'
p605
I0
sg29
g33
sS'block.thisN'
p606
I14
sg466
(S'HALF'
S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp607
sg27
g28
sg468
I3
sg469
(I9
I2
I1
tp608
sg22
I1
sg20
F6.375877227210367
sg23
F5.1685651602238067
sVY
I7
sVX
I3
sg471
g472
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p609
sg34
g11
sg474
I1
sg475
g480
sg477
I1
sS'block.thisIndex'
p610
I6
sg479
g476
sg481
I0
sg482
g516
sa(dp611
S'block.thisTrialN'
p612
I15
sS'block.thisRepN'
p613
I0
sg29
g33
sS'block.thisN'
p614
I15
sg466
(S'DOUBLE'
S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp615
sg27
g28
sg468
I4
sg469
(I1
I3
I2
I4
tp616
sg22
I1
sg20
F10.58378528200592
sg23
F17.704180768736478
sVY
I4
sVX
I4
sg471
g472
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p617
sg34
g11
sg474
I4
sg475
g535
sg477
I4
sS'block.thisIndex'
p618
I17
sg479
g502
sg481
g514
sg482
VUUUBxy
p619
sa(dp620
S'block.thisTrialN'
p621
I16
sS'block.thisRepN'
p622
I0
sg29
g33
sS'block.thisN'
p623
I16
sg466
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp624
sg27
g28
sg468
I4
sg469
(I4
I12
I6
I5
tp625
sg22
I1
sg20
F12.250984009819149
sg23
F10.782211076273597
sVY
I2
sVX
I8
sg471
g472
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p626
sg34
g11
sg474
I5
sg475
g476
sg477
I5
sS'block.thisIndex'
p627
I16
sg479
g535
sg481
g514
sg482
g619
sa(dp628
S'block.thisTrialN'
p629
I17
sS'block.thisRepN'
p630
I0
sg29
g33
sS'block.thisN'
p631
I17
sg466
(S'DECREASE'
S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp632
sg27
g28
sg468
I4
sg469
(I2
I12
I4
I3
tp633
sg22
I1
sg20
F9.7771786014127429
sg23
F12.886788213649197
sVY
I6
sVX
I4
sg471
g533
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p634
sg34
g11
sg474
I3
sg475
g492
sg477
I3
sS'block.thisIndex'
p635
I14
sg479
g535
sg481
g476
sg482
g594
sa(dp636
S'block.thisTrialN'
p637
I0
sS'block.thisRepN'
p638
I0
sg29
g33
sS'block.thisN'
p639
I0
sVRule
p640
(S'TIMES'
S'INCREASE'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp641
sg27
g28
sVLength
p642
I4
sVIntermediate
p643
(I6
I3
I4
I8
tp644
sg22
I0
sg20
F14.363170053205977
sg23
F11.994721850775022
sVY
I2
sVX
I2
sVOperatorc
p645
Vhalf
p646
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p647
sg34
g11
sVResult
p648
I8
sVOperatora
p649
Vincrease
p650
sVCorrectResponse
p651
I8
sS'block.thisIndex'
p652
I11
sVOperatorb
p653
VTIMES
p654
sVOperatord
p655
Vtriple
p656
sVStructure
p657
VBUUUxy
p658
sa(dp659
S'block.thisTrialN'
p660
I1
sS'block.thisRepN'
p661
I0
sg29
g33
sS'block.thisN'
p662
I1
sg640
(S'INCREASE'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp663
sg27
g28
sg642
I3
sg643
(I6
I8
I9
tp664
sg22
I0
sg20
F8.566509684715129
sg23
F5.0465657908589492
sVY
I2
sVX
I2
sg645
g656
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p665
sg34
g11
sg648
I9
sg649
VADD
p666
sg651
I9
sS'block.thisIndex'
p667
I6
sg653
g650
sg655
I0
sg657
VUBUxy
p668
sa(dp669
S'block.thisTrialN'
p670
I2
sS'block.thisRepN'
p671
I0
sg29
g33
sS'block.thisN'
p672
I2
sg640
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp673
sg27
g28
sg642
I4
sg643
(I4
I2
I1
I3
tp674
sg22
I0
sg20
F19.654562246429123
sVY
I5
sVX
I9
sg645
g646
sg35
g36
sg37
g38
sg21
Nsg19
S'space'
p675
sg34
g11
sg648
I3
sg649
Vdecrease
p676
sg651
I3
sS'block.thisIndex'
p677
I17
sg653
g656
sg655
VSUBTRACT
p678
sg657
VUUUBxy
p679
sa(dp680
S'block.thisTrialN'
p681
I3
sS'block.thisRepN'
p682
I0
sg29
g33
sS'block.thisN'
p683
I3
sg640
(S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp684
sg27
g28
sg642
I3
sg643
(I4
I12
I4
tp685
sg22
I1
sg20
F5.0750013736069377
sg23
F7.2744049658413132
sVY
I3
sVX
I8
sg645
g646
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p686
sg34
g11
sg648
I4
sg649
g656
sg651
I4
sS'block.thisIndex'
p687
I4
sg653
VDIVIDE
p688
sg655
I0
sg657
VBUUxy
p689
sa(dp690
S'block.thisTrialN'
p691
I4
sS'block.thisRepN'
p692
I0
sg29
g33
sS'block.thisN'
p693
I4
sg640
(S'ADD'
S'THIRD'
S'x'
S'y'
tp694
sg27
g28
sg642
I2
sg643
(I1
I7
tp695
sg22
I1
sg20
F3.6755471066589962
sg23
F2.9184970048372634
sVY
I6
sVX
I3
sg645
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p696
sg34
g11
sg648
I7
sg649
Vthird
p697
sg651
I7
sS'block.thisIndex'
p698
I0
sg653
g666
sg655
I0
sg657
VBUxy
p699
sa(dp700
S'block.thisTrialN'
p701
I5
sS'block.thisRepN'
p702
I0
sg29
g33
sS'block.thisN'
p703
I5
sg640
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp704
sg27
g28
sg642
I4
sg643
(I6
I3
I9
I8
tp705
sg22
I1
sg20
F10.511400935312849
sg23
F7.9482358515888336
sVY
I2
sVX
I4
sg645
g646
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p706
sg34
g11
sg648
I8
sg649
g656
sg651
I8
sS'block.thisIndex'
p707
I16
sg653
g676
sg655
g666
sg657
g679
sa(dp708
S'block.thisTrialN'
p709
I6
sS'block.thisRepN'
p710
I0
sg29
g33
sS'block.thisN'
p711
I6
sg640
(S'THIRD'
S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp712
sg27
g28
sg642
I4
sg643
(I8
I4
I12
I4
tp713
sg22
I0
sg20
F8.4677604891930969
sg23
F19.776278495339284
sVY
I3
sVX
I7
sg645
g646
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p714
sg34
g11
sg648
I4
sg649
g654
sg651
I4
sS'block.thisIndex'
p715
I13
sg653
g697
sg655
g650
sg657
VUBUUxy
p716
sa(dp717
S'block.thisTrialN'
p718
I7
sS'block.thisRepN'
p719
I0
sg29
g33
sS'block.thisN'
p720
I7
sg640
(S'TIMES'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp721
sg27
g28
sg642
I3
sg643
(I6
I2
I4
tp722
sg22
I0
sg20
F3.3069333715029643
sg23
F10.762800001819414
sVY
I2
sVX
I3
sg645
Vdouble
p723
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p724
sg34
g11
sg648
I4
sg649
g697
sg651
I4
sS'block.thisIndex'
p725
I5
sg653
g654
sg655
I0
sg657
g689
sa(dp726
S'block.thisTrialN'
p727
I8
sS'block.thisRepN'
p728
I0
sg29
g33
sS'block.thisN'
p729
I8
sg640
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp730
sg27
g28
sg642
I3
sg643
(I2
I6
I5
tp731
sg22
I1
sg20
F6.468699091250528
sg23
F4.7887210969529406
sVY
I4
sVX
I8
sg645
g688
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p732
sg34
g11
sg648
I5
sg649
g656
sg651
I5
sS'block.thisIndex'
p733
I8
sg653
g676
sg655
I0
sg657
VUUBxy
p734
sa(dp735
S'block.thisTrialN'
p736
I9
sS'block.thisRepN'
p737
I0
sg29
g33
sS'block.thisN'
p738
I9
sg640
(S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp739
sg27
g28
sg642
I2
sg643
(I6
I2
tp740
sg22
I1
sg20
F4.1045001454094745
sg23
F3.9752901284755353
sVY
I4
sVX
I5
sg645
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p741
sg34
g11
sg648
I2
sg649
g650
sg651
I2
sS'block.thisIndex'
p742
I1
sg653
g678
sg655
I0
sg657
g699
sa(dp743
S'block.thisTrialN'
p744
I10
sS'block.thisRepN'
p745
I0
sg29
g33
sS'block.thisN'
p746
I10
sg640
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp747
sg27
g28
sg642
I4
sg643
(I2
I3
I6
I2
tp748
sg22
I1
sg20
F5.3659897089746664
sg23
F7.9429727507940697
sVY
I3
sVX
I6
sg645
g650
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p749
sg34
g11
sg648
I2
sg649
g723
sg651
I2
sS'block.thisIndex'
p750
I10
sg653
g688
sg655
g697
sg657
g658
sa(dp751
S'block.thisTrialN'
p752
I11
sS'block.thisRepN'
p753
I0
sg29
g33
sS'block.thisN'
p754
I11
sg640
(S'DOUBLE'
S'TIMES'
S'x'
S'y'
tp755
sg27
g28
sg642
I2
sg643
(I4
I8
tp756
sg22
I1
sg20
F1.7740303299342486
sg23
F2.6506727522973961
sVY
I2
sVX
I2
sg645
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p757
sg34
g11
sg648
I8
sg649
g654
sg651
I8
sS'block.thisIndex'
p758
I3
sg653
g723
sg655
I0
sg657
VUBxy
p759
sa(dp760
S'block.thisTrialN'
p761
I12
sS'block.thisRepN'
p762
I0
sg29
g33
sS'block.thisN'
p763
I12
sg640
(S'THIRD'
S'INCREASE'
S'ADD'
S'DOUBLE'
S'x'
S'y'
tp764
sg27
g28
sg642
I4
sg643
(I16
I20
I21
I7
tp765
sg22
I0
sg20
F7.2863026743161754
sg23
F11.313887145875924
sVY
I4
sVX
I8
sg645
g666
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p766
sg34
g11
sg648
I7
sg649
g650
sg651
I7
sS'block.thisIndex'
p767
I14
sg653
g697
sg655
g723
sg657
VUUBUxy
p768
sa(dp769
S'block.thisTrialN'
p770
I13
sS'block.thisRepN'
p771
I0
sg29
g33
sS'block.thisN'
p772
I13
sg640
(S'INCREASE'
S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp773
sg27
g28
sg642
I3
sg643
(I3
I1
I2
tp774
sg22
I1
sg20
F4.1528301021789957
sg23
F7.4290258311557409
sVY
I2
sVX
I9
sg645
g697
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p775
sg34
g11
sg648
I2
sg649
g678
sg651
I2
sS'block.thisIndex'
p776
I7
sg653
g650
sg655
I0
sg657
g668
sa(dp777
S'block.thisTrialN'
p778
I14
sS'block.thisRepN'
p779
I0
sg29
g33
sS'block.thisN'
p780
I14
sg640
(S'DOUBLE'
S'ADD'
S'x'
S'y'
tp781
sg27
g28
sg642
I2
sg643
(I4
I8
tp782
sg22
I1
sg20
F3.1489822537005239
sg23
F1.9424285575805698
sVY
I2
sVX
I2
sg645
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p783
sg34
g11
sg648
I8
sg649
g666
sg651
I8
sS'block.thisIndex'
p784
I2
sg653
g723
sg655
I0
sg657
g759
sa(dp785
S'block.thisTrialN'
p786
I15
sS'block.thisRepN'
p787
I0
sg29
g33
sS'block.thisN'
p788
I15
sg640
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp789
sg27
g28
sg642
I4
sg643
(I2
I6
I2
I3
tp790
sg22
I1
sg20
F8.055455913176047
sg23
F11.851551440608091
sVY
I3
sVX
I4
sg645
g656
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p791
sg34
g11
sg648
I3
sg649
g688
sg651
I3
sS'block.thisIndex'
p792
I12
sg653
g650
sg655
g646
sg657
g716
sa(dp793
S'block.thisTrialN'
p794
I16
sS'block.thisRepN'
p795
I0
sg29
g33
sS'block.thisN'
p796
I16
sg640
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp797
sg27
g28
sg642
I4
sg643
(I4
I1
I2
I6
tp798
sg22
I0
sg20
F6.2941131592906459
sVY
I3
sVX
I5
sg645
g678
sg35
g36
sg37
g38
sg21
Nsg19
S'space'
p799
sg34
g11
sg648
I6
sg649
g723
sg651
I6
sS'block.thisIndex'
p800
I15
sg653
g656
sg655
g676
sg657
g768
sa(dp801
S'block.thisTrialN'
p802
I17
sS'block.thisRepN'
p803
I0
sg29
g33
sS'block.thisN'
p804
I17
sg640
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp805
sg27
g28
sg642
I3
sg643
(I2
I3
I1
tp806
sg22
I1
sg20
F5.9226521212513035
sg23
F4.8323006494265428
sVY
I6
sVX
I8
sg645
g678
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p807
sg34
g11
sg648
I1
sg649
g650
sg651
I1
sS'block.thisIndex'
p808
I9
sg653
g697
sg655
I0
sg657
g734
sa(dp809
S'block.thisTrialN'
p810
I0
sS'block.thisRepN'
p811
I0
sg29
g33
sS'block.thisN'
p812
I0
sVRule
p813
(S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp814
sg27
g28
sVLength
p815
I3
sVIntermediate
p816
(I4
I2
I3
tp817
sg22
I1
sg20
F5.1401330771132052
sg23
F7.5328337487972021
sVY
I2
sVX
I8
sVOperatorc
p818
Vhalf
p819
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p820
sg34
g11
sVResult
p821
I3
sVOperatora
p822
VSUBTRACT
p823
sVCorrectResponse
p824
I3
sS'block.thisIndex'
p825
I7
sVOperatorb
p826
Vincrease
p827
sVOperatord
p828
I0
sVStructure
p829
VUBUxy
p830
sa(dp831
S'block.thisTrialN'
p832
I1
sS'block.thisRepN'
p833
I0
sg29
g33
sS'block.thisN'
p834
I1
sg813
(S'DIVIDE'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp835
sg27
g28
sg815
I3
sg816
(I9
I8
I4
tp836
sg22
I0
sg20
F3.2111665647680638
sg23
F7.3264595839427784
sVY
I2
sVX
I3
sg818
Vtriple
p837
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p838
sg34
g11
sg821
I4
sg822
Vdecrease
p839
sg824
I4
sS'block.thisIndex'
p840
I5
sg826
VDIVIDE
p841
sg828
I0
sg829
VBUUxy
p842
sa(dp843
S'block.thisTrialN'
p844
I2
sS'block.thisRepN'
p845
I0
sg29
g33
sS'block.thisN'
p846
I2
sg813
(S'DOUBLE'
S'ADD'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp847
sg27
g28
sg815
I4
sg816
(I1
I2
I4
I8
tp848
sg22
I0
sg20
F6.1323523390346963
sg23
F8.1572837374424125
sVY
I2
sVX
I3
sg818
g827
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p849
sg34
g11
sg821
I8
sg822
VADD
p850
sg824
I8
sS'block.thisIndex'
p851
I12
sg826
Vdouble
p852
sg828
Vthird
p853
sg829
VUBUUxy
p854
sa(dp855
S'block.thisTrialN'
p856
I3
sS'block.thisRepN'
p857
I0
sg29
g33
sS'block.thisN'
p858
I3
sg813
(S'ADD'
S'HALF'
S'THIRD'
S'x'
S'y'
tp859
sg27
g28
sg815
I3
sg816
(I2
I1
I9
tp860
sg22
I0
sg20
F9.3223846091659652
sg23
F9.5519578531984735
sVY
I8
sVX
I6
sg818
g853
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p861
sg34
g11
sg821
I9
sg822
g819
sg824
I9
sS'block.thisIndex'
p862
I4
sg826
g850
sg828
I0
sg829
g842
sa(dp863
S'block.thisTrialN'
p864
I4
sS'block.thisRepN'
p865
I0
sg29
g33
sS'block.thisN'
p866
I4
sg813
(S'THIRD'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp867
sg27
g28
sg815
I4
sg816
(I18
I2
I3
I1
tp868
sg22
I1
sg20
F10.68862384210297
sg23
F10.444387128203743
sVY
I9
sVX
I9
sg818
g841
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p869
sg34
g11
sg821
I1
sg822
Vincrese
p870
sg824
I1
sS'block.thisIndex'
p871
I15
sg826
g853
sg828
g852
sg829
VUUBUxy
p872
sa(dp873
S'block.thisTrialN'
p874
I5
sS'block.thisRepN'
p875
I0
sg29
g33
sS'block.thisN'
p876
I5
sg813
(S'HALF'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp877
sg27
g28
sg815
I3
sg816
(I9
I12
I6
tp878
sg22
I1
sg20
F2.5469649242095329
sg23
F5.5893937967575766
sVY
I3
sVX
I3
sg818
g837
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p879
sg34
g11
sg821
I6
sg822
g850
sg824
I6
sS'block.thisIndex'
p880
I6
sg826
g819
sg828
I0
sg829
g830
sa(dp881
S'block.thisTrialN'
p882
I6
sS'block.thisRepN'
p883
I0
sg29
g33
sS'block.thisN'
p884
I6
sg813
(S'INCREASE'
S'ADD'
S'x'
S'y'
tp885
sg27
g28
sg815
I2
sg816
(I5
I6
tp886
sg22
I1
sg20
F2.2097219155166385
sg23
F1.9077755236230587
sVY
I2
sVX
I3
sg818
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p887
sg34
g11
sg821
I6
sg822
g850
sg824
I6
sS'block.thisIndex'
p888
I3
sg826
g827
sg828
I0
sg829
VUBxy
p889
sa(dp890
S'block.thisTrialN'
p891
I7
sS'block.thisRepN'
p892
I0
sg29
g33
sS'block.thisN'
p893
I7
sg813
(S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp894
sg27
g28
sg815
I4
sg816
(I6
I18
I17
I8
tp895
sg22
I1
sg20
F10.103500299743246
sg23
F14.290563479700722
sVY
I9
sVX
I3
sg818
g837
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p896
sg34
g11
sg821
I8
sg822
g839
sg824
I8
sS'block.thisIndex'
p897
I11
sg826
g823
sg828
g852
sg829
VBUUUxy
p898
sa(dp899
S'block.thisTrialN'
p900
I8
sS'block.thisRepN'
p901
I0
sg29
g33
sS'block.thisN'
p902
I8
sg813
(S'DECREASE'
S'DIVIDE'
S'x'
S'y'
tp903
sg27
g28
sg815
I2
sg816
(I2
I1
tp904
sg22
I0
sg20
F1.9137123041218729
sg23
F3.5001300114345213
sVY
I4
sVX
I8
sg818
I0
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p905
sg34
g11
sg821
I1
sg822
g841
sg824
I1
sS'block.thisIndex'
p906
I2
sg826
g839
sg828
I0
sg829
g889
sa(dp907
S'block.thisTrialN'
p908
I9
sS'block.thisRepN'
p909
I0
sg29
g33
sS'block.thisN'
p910
I9
sg813
(S'THIRD'
S'TIMES'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp911
sg27
g28
sg815
I4
sg816
(I1
I2
I6
I2
tp912
sg22
I0
sg20
F9.0318907721975847
sg23
F8.117662271941299
sVY
I3
sVX
I2
sg818
g852
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p913
sg34
g11
sg821
I2
sg822
VTIMES
p914
sg824
I2
sS'block.thisIndex'
p915
I13
sg826
g853
sg828
g839
sg829
g854
sa(dp916
S'block.thisTrialN'
p917
I10
sS'block.thisRepN'
p918
I0
sg29
g33
sS'block.thisN'
p919
I10
sg813
(S'THIRD'
S'DOUBLE'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp920
sg27
g28
sg815
I4
sg816
(I8
I9
I18
I6
tp921
sg22
I1
sg20
F14.419970176111747
sg23
F9.2191065362330846
sVY
I4
sVX
I2
sg818
g827
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p922
sg34
g11
sg821
I6
sg822
g852
sg824
I6
sS'block.thisIndex'
p923
I17
sg826
g853
sg828
g914
sg829
VUUUBxy
p924
sa(dp925
S'block.thisTrialN'
p926
I11
sS'block.thisRepN'
p927
I0
sg29
g33
sS'block.thisN'
p928
I11
sg813
(S'THIRD'
S'DOUBLE'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp929
sg27
g28
sg815
I4
sg816
(I5
I12
I24
I8
tp930
sg22
I1
sg20
F6.8151839355559787
sg23
F14.900563476201569
sVY
I7
sVX
I6
sg818
g850
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p931
sg34
g11
sg821
I8
sg822
g852
sg824
I8
sS'block.thisIndex'
p932
I14
sg826
g853
sg828
g839
sg829
g872
sa(dp933
S'block.thisTrialN'
p934
I12
sS'block.thisRepN'
p935
I0
sg29
g33
sS'block.thisN'
p936
I12
sg813
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'THIRD'
S'x'
S'y'
tp937
sg27
g28
sg815
I4
sg816
(I2
I1
I2
I8
tp938
sg22
I1
sg20
F6.4764675806090963
sg23
F11.085764150509931
sVY
I6
sVX
I6
sg818
g839
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p939
sg34
g11
sg821
I8
sg822
g852
sg824
I8
sS'block.thisIndex'
p940
I10
sg826
g850
sg828
g853
sg829
g898
sa(dp941
S'block.thisTrialN'
p942
I13
sS'block.thisRepN'
p943
I0
sg29
g33
sS'block.thisN'
p944
I13
sg813
(S'DIVIDE'
S'INCREASE'
S'x'
S'y'
tp945
sg27
g28
sg815
I2
sg816
(I4
I2
tp946
sg22
I1
sg20
F2.4692541333315603
sg23
F2.8162849206692044
sVY
I2
sVX
I3
sg818
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p947
sg34
g11
sg821
I2
sg822
g827
sg824
I2
sS'block.thisIndex'
p948
I0
sg826
g841
sg828
I0
sg829
VBUxy
p949
sa(dp950
S'block.thisTrialN'
p951
I14
sS'block.thisRepN'
p952
I0
sg29
g33
sS'block.thisN'
p953
I14
sg813
(S'THIRD'
S'HALF'
S'ADD'
S'x'
S'y'
tp954
sg27
g28
sg815
I3
sg816
(I6
I3
I1
tp955
sg22
I1
sg20
F1.9797080674634344
sg23
F5.285734683584451
sVY
I3
sVX
I3
sg818
g850
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p956
sg34
g11
sg821
I1
sg822
g819
sg824
I1
sS'block.thisIndex'
p957
I9
sg826
g853
sg828
I0
sg829
VUUBxy
p958
sa(dp959
S'block.thisTrialN'
p960
I15
sS'block.thisRepN'
p961
I0
sg29
g33
sS'block.thisN'
p962
I15
sg813
(S'INCREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp963
sg27
g28
sg815
I3
sg816
(I2
I6
I7
tp964
sg22
I1
sg20
F3.029146708540793
sg23
F6.8102634490096534
sVY
I3
sVX
I6
sg818
g841
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p965
sg34
g11
sg821
I7
sg822
g837
sg824
I7
sS'block.thisIndex'
p966
I8
sg826
g827
sg828
I0
sg829
g958
sa(dp967
S'block.thisTrialN'
p968
I16
sS'block.thisRepN'
p969
I0
sg29
g33
sS'block.thisN'
p970
I16
sg813
(S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp971
sg27
g28
sg815
I2
sg816
(I5
I3
tp972
sg22
I0
sg20
F3.0289682271650236
sg23
F3.0871892018058134
sVY
I2
sVX
I6
sg818
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p973
sg34
g11
sg821
I3
sg822
g839
sg824
I3
sS'block.thisIndex'
p974
I1
sg826
g823
sg828
I0
sg829
g949
sa(dp975
S'block.thisTrialN'
p976
I17
sS'block.thisRepN'
p977
I0
sg29
g33
sS'block.thisN'
p978
I17
sg813
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp979
sg27
g28
sg815
I4
sg816
(I3
I4
I12
I6
tp980
sg22
I1
sg20
F7.6779142596460588
sg23
F7.3576311811866617
sVY
I3
sVX
I9
sg818
g827
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p981
sg34
g11
sg821
I6
sg822
g837
sg824
I6
sS'block.thisIndex'
p982
I16
sg826
g819
sg828
g841
sg829
g924
sa(dp983
S'block.thisTrialN'
p984
I0
sS'block.thisRepN'
p985
I0
sg29
g33
sS'block.thisN'
p986
I0
sVRule
p987
(S'INCREASE'
S'DIVIDE'
S'HALF'
S'x'
S'y'
tp988
sg27
g28
sVLength
p989
I3
sVIntermediate
p990
(I2
I1
I2
tp991
sg22
I1
sg20
F8.4054487914199854
sg23
F5.1354197689470311
sVY
I2
sVX
I4
sVOperatorc
p992
Vhalf
p993
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p994
sg34
g11
sVResult
p995
I2
sVOperatora
p996
VDIVIDE
p997
sVCorrectResponse
p998
I2
sS'block.thisIndex'
p999
I7
sVOperatorb
p1000
Vincrease
p1001
sVOperatord
p1002
I0
sVStructure
p1003
VUBUxy
p1004
sa(dp1005
S'block.thisTrialN'
p1006
I1
sS'block.thisRepN'
p1007
I0
sg29
g33
sS'block.thisN'
p1008
I1
sg987
(S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp1009
sg27
g28
sg989
I2
sg990
(I3
I1
tp1010
sg22
I1
sg20
F2.6672963676228392
sg23
F4.8238833277755475
sVY
I2
sVX
I9
sg992
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1011
sg34
g11
sg995
I1
sg996
Vthird
p1012
sg998
I1
sS'block.thisIndex'
p1013
I0
sg1000
VSUBTRACT
p1014
sg1002
I0
sg1003
VBUxy
p1015
sa(dp1016
S'block.thisTrialN'
p1017
I2
sS'block.thisRepN'
p1018
I0
sg29
g33
sS'block.thisN'
p1019
I2
sg987
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp1020
sg27
g28
sg989
I4
sg990
(I4
I2
I3
I1
tp1021
sg22
I1
sg20
F9.2736402956361417
sg23
F13.404791210037729
sVY
I2
sVX
I8
sg992
g1014
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1022
sg34
g11
sg995
I1
sg996
g1001
sg998
I1
sS'block.thisIndex'
p1023
I15
sg1000
g1012
sg1002
g993
sg1003
VUUBUxy
p1024
sa(dp1025
S'block.thisTrialN'
p1026
I3
sS'block.thisRepN'
p1027
I0
sg29
g33
sS'block.thisN'
p1028
I3
sg987
(S'TIMES'
S'THIRD'
S'x'
S'y'
tp1029
sg27
g28
sg989
I2
sg990
(I1
I4
tp1030
sg22
I1
sg20
F1.8603971175598417
sg23
F1.7046238225048
sVY
I4
sVX
I3
sg992
I0
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p1031
sg34
g11
sg995
I4
sg996
g1012
sg998
I4
sS'block.thisIndex'
p1032
I1
sg1000
VTIMES
p1033
sg1002
I0
sg1003
g1015
sa(dp1034
S'block.thisTrialN'
p1035
I4
sS'block.thisRepN'
p1036
I0
sg29
g33
sS'block.thisN'
p1037
I4
sg987
(S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp1038
sg27
g28
sg989
I2
sg990
(I2
I6
tp1039
sg22
I1
sg20
F1.6043176394541661
sg23
F3.3640001665826276
sVY
I6
sVX
I8
sg992
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1040
sg34
g11
sg995
I6
sg996
g1014
sg998
I6
sS'block.thisIndex'
p1041
I3
sg1000
Vtriple
p1042
sg1002
I0
sg1003
VUBxy
p1043
sa(dp1044
S'block.thisTrialN'
p1045
I5
sS'block.thisRepN'
p1046
I0
sg29
g33
sS'block.thisN'
p1047
I5
sg987
(S'TRIPLE'
S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp1048
sg27
g28
sg989
I4
sg990
(I3
I4
I1
I3
tp1049
sg22
I1
sg20
F6.7172134087795712
sg23
F13.421814133695079
sVY
I3
sVX
I6
sg992
g1001
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1050
sg34
g11
sg995
I3
sg996
g1014
sg998
I3
sS'block.thisIndex'
p1051
I13
sg1000
g1042
sg1002
g993
sg1003
VUBUUxy
p1052
sa(dp1053
S'block.thisTrialN'
p1054
I6
sS'block.thisRepN'
p1055
I0
sg29
g33
sS'block.thisN'
p1056
I6
sg987
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'ADD'
S'x'
S'y'
tp1057
sg27
g28
sg989
I4
sg990
(I4
I12
I6
I5
tp1058
sg22
I0
sg20
F6.3700566345905827
sg23
F6.0170036756662739
sVY
I2
sVX
I2
sg992
g1042
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1059
sg34
g11
sg995
I5
sg996
g993
sg998
I5
sS'block.thisIndex'
p1060
I16
sg1000
Vdecrease
p1061
sg1002
VADD
p1062
sg1003
VUUUBxy
p1063
sa(dp1064
S'block.thisTrialN'
p1065
I7
sS'block.thisRepN'
p1066
I0
sg29
g33
sS'block.thisN'
p1067
I7
sg987
(S'TIMES'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1068
sg27
g28
sg989
I4
sg990
(I6
I2
I1
I2
tp1069
sg22
I0
sg20
F8.4003603224009566
sg23
F18.494732874623878
sVY
I2
sVX
I3
sg992
g1012
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1070
sg34
g11
sg995
I2
sg996
g1061
sg998
I2
sS'block.thisIndex'
p1071
I11
sg1000
g1033
sg1002
Vdouble
p1072
sg1003
VBUUUxy
p1073
sa(dp1074
S'block.thisTrialN'
p1075
I8
sS'block.thisRepN'
p1076
I0
sg29
g33
sS'block.thisN'
p1077
I8
sg987
(S'DIVIDE'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1078
sg27
g28
sg989
I4
sg990
(I12
I4
I3
I1
tp1079
sg22
I1
sg20
F9.5156057465392223
sg23
F6.7238641147796443
sVY
I3
sVX
I6
sg992
g1012
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1080
sg34
g11
sg995
I1
sg996
g1061
sg998
I1
sS'block.thisIndex'
p1081
I10
sg1000
g997
sg1002
g1072
sg1003
g1073
sa(dp1082
S'block.thisTrialN'
p1083
I9
sS'block.thisRepN'
p1084
I0
sg29
g33
sS'block.thisN'
p1085
I9
sg987
(S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp1086
sg27
g28
sg989
I3
sg990
(I1
I4
I8
tp1087
sg22
I1
sg20
F7.8188487531315332
sg23
F6.3357966096245946
sVY
I4
sVX
I3
sg992
g1012
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1088
sg34
g11
sg995
I8
sg996
g1033
sg998
I8
sS'block.thisIndex'
p1089
I6
sg1000
g1072
sg1002
I0
sg1003
g1004
sa(dp1090
S'block.thisTrialN'
p1091
I10
sS'block.thisRepN'
p1092
I0
sg29
g33
sS'block.thisN'
p1093
I10
sg987
(S'INCREASE'
S'HALF'
S'TIMES'
S'TRIPLE'
S'x'
S'y'
tp1094
sg27
g28
sg989
I4
sg990
(I6
I12
I6
I7
tp1095
sg22
I0
sg20
F11.262875418949989
sg23
F15.122120806692692
sVY
I2
sVX
I2
sg992
g1033
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1096
sg34
g11
sg995
I7
sg996
g993
sg998
I7
sS'block.thisIndex'
p1097
I14
sg1000
g1001
sg1002
g1042
sg1003
g1024
sa(dp1098
S'block.thisTrialN'
p1099
I11
sS'block.thisRepN'
p1100
I0
sg29
g33
sS'block.thisN'
p1101
I11
sg987
(S'ADD'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp1102
sg27
g28
sg989
I3
sg990
(I3
I2
I6
tp1103
sg22
I0
sg20
F11.102212084168059
sg23
F9.6467682097372744
sVY
I4
sVX
I6
sg992
g993
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1104
sg34
g11
sg995
I6
sg996
g1061
sg998
I6
sS'block.thisIndex'
p1105
I4
sg1000
g1062
sg1002
I0
sg1003
VBUUxy
p1106
sa(dp1107
S'block.thisTrialN'
p1108
I12
sS'block.thisRepN'
p1109
I0
sg29
g33
sS'block.thisN'
p1110
I12
sg987
(S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1111
sg27
g28
sg989
I3
sg990
(I8
I16
I7
tp1112
sg22
I1
sg20
F4.972213949473371
sg23
F11.951610899403022
sVY
I9
sVX
I9
sg992
g1061
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1113
sg34
g11
sg995
I7
sg996
g1072
sg998
I7
sS'block.thisIndex'
p1114
I5
sg1000
g1014
sg1002
I0
sg1003
g1106
sa(dp1115
S'block.thisTrialN'
p1116
I13
sS'block.thisRepN'
p1117
I0
sg29
g33
sS'block.thisN'
p1118
I13
sg987
(S'DECREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp1119
sg27
g28
sg989
I3
sg990
(I4
I2
I1
tp1120
sg22
I1
sg20
F4.5946971433531871
sg23
F5.6365233787855686
sVY
I2
sVX
I8
sg992
g997
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1121
sg34
g11
sg995
I1
sg996
g993
sg998
I1
sS'block.thisIndex'
p1122
I8
sg1000
g1061
sg1002
I0
sg1003
VUUBxy
p1123
sa(dp1124
S'block.thisTrialN'
p1125
I14
sS'block.thisRepN'
p1126
I0
sg29
g33
sS'block.thisN'
p1127
I14
sg987
(S'INCREASE'
S'TIMES'
S'x'
S'y'
tp1128
sg27
g28
sg989
I2
sg990
(I8
I9
tp1129
sg22
I1
sg20
F2.5745504456608614
sg23
F3.9213163106414868
sVY
I4
sVX
I2
sg992
I0
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1130
sg34
g11
sg995
I9
sg996
g1033
sg998
I9
sS'block.thisIndex'
p1131
I2
sg1000
g1001
sg1002
I0
sg1003
g1043
sa(dp1132
S'block.thisTrialN'
p1133
I15
sS'block.thisRepN'
p1134
I0
sg29
g33
sS'block.thisN'
p1135
I15
sg987
(S'TRIPLE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp1136
sg27
g28
sg989
I3
sg990
(I6
I3
I9
tp1137
sg22
I1
sg20
F3.0880130158420798
sg23
F8.3471868710494164
sVY
I3
sVX
I2
sg992
g1033
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1138
sg34
g11
sg995
I9
sg996
g993
sg998
I9
sS'block.thisIndex'
p1139
I9
sg1000
g1042
sg1002
I0
sg1003
g1123
sa(dp1140
S'block.thisTrialN'
p1141
I16
sS'block.thisRepN'
p1142
I0
sg29
g33
sS'block.thisN'
p1143
I16
sg987
(S'DECREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp1144
sg27
g28
sg989
I4
sg990
(I6
I18
I2
I1
tp1145
sg22
I0
sg20
F4.0030180850644683
sg23
F4.4293194505153224
sVY
I9
sVX
I3
sg992
g1042
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1146
sg34
g11
sg995
I1
sg996
g997
sg998
I1
sS'block.thisIndex'
p1147
I12
sg1000
g1061
sg1002
g1072
sg1003
g1052
sa(dp1148
S'block.thisTrialN'
p1149
I17
sS'block.thisRepN'
p1150
I0
sg29
g33
sS'block.thisN'
p1151
I17
sg987
(S'INCREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp1152
sg27
g28
sg989
I4
sg990
(I4
I2
I6
I7
tp1153
sg22
I1
sg20
F17.56561412816518
sg23
F9.3592011173641367
sVY
I2
sVX
I2
sg992
g993
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1154
sg34
g11
sg995
I7
sg996
g1042
sg998
I7
sS'block.thisIndex'
p1155
I17
sg1000
g1001
sg1002
g1062
sg1003
g1063
sa(dp1156
S'block.thisTrialN'
p1157
I0
sS'block.thisRepN'
p1158
I0
sg29
g33
sS'block.thisN'
p1159
I0
sVRule
p1160
(S'ADD'
S'TRIPLE'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1161
sg27
g28
sVLength
p1162
I4
sVIntermediate
p1163
(I1
I2
I6
I8
tp1164
sg22
I0
sg20
F16.952242933450179
sg23
F6.0528472853857238
sVY
I2
sVX
I2
sVOperatorc
p1165
Vdouble
p1166
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1167
sg34
g11
sVResult
p1168
I8
sVOperatora
p1169
Vtriple
p1170
sVCorrectResponse
p1171
I8
sS'block.thisIndex'
p1172
I11
sVOperatorb
p1173
VADD
p1174
sVOperatord
p1175
Vdecrease
p1176
sVStructure
p1177
VBUUUxy
p1178
sa(dp1179
S'block.thisTrialN'
p1180
I1
sS'block.thisRepN'
p1181
I0
sg29
g33
sS'block.thisN'
p1182
I1
sg1160
(S'ADD'
S'DECREASE'
S'x'
S'y'
tp1183
sg27
g28
sg1162
I2
sg1163
(I2
I7
tp1184
sg22
I1
sg20
F3.7163972939433734
sg23
F2.3426338461576961
sVY
I5
sVX
I3
sg1165
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1185
sg34
g11
sg1168
I7
sg1169
g1176
sg1171
I7
sS'block.thisIndex'
p1186
I0
sg1173
g1174
sg1175
I0
sg1177
VBUxy
p1187
sa(dp1188
S'block.thisTrialN'
p1189
I2
sS'block.thisRepN'
p1190
I0
sg29
g33
sS'block.thisN'
p1191
I2
sg1160
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1192
sg27
g28
sg1162
I3
sg1163
(I1
I2
I7
tp1193
sg22
I1
sg20
F8.1378184186487488
sg23
F2.6213031170191243
sVY
I5
sVX
I2
sg1165
g1176
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1194
sg34
g11
sg1168
I7
sg1169
g1166
sg1171
I7
sS'block.thisIndex'
p1195
I4
sg1173
g1174
sg1175
I0
sg1177
VBUUxy
p1196
sa(dp1197
S'block.thisTrialN'
p1198
I3
sS'block.thisRepN'
p1199
I0
sg29
g33
sS'block.thisN'
p1200
I3
sg1160
(S'DECREASE'
S'TIMES'
S'x'
S'y'
tp1201
sg27
g28
sg1162
I2
sg1163
(I9
I8
tp1202
sg22
I1
sg20
F2.746085395989212
sg23
F2.2878306148759293
sVY
I3
sVX
I3
sg1165
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1203
sg34
g11
sg1168
I8
sg1169
VTIMES
p1204
sg1171
I8
sS'block.thisIndex'
p1205
I2
sg1173
g1176
sg1175
I0
sg1177
VUBxy
p1206
sa(dp1207
S'block.thisTrialN'
p1208
I4
sS'block.thisRepN'
p1209
I0
sg29
g33
sS'block.thisN'
p1210
I4
sg1160
(S'INCREASE'
S'ADD'
S'HALF'
S'x'
S'y'
tp1211
sg27
g28
sg1162
I3
sg1163
(I1
I4
I5
tp1212
sg22
I1
sg20
F7.2607892866362818
sg23
F4.6930911259405548
sVY
I3
sVX
I2
sg1165
Vhalf
p1213
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1214
sg34
g11
sg1168
I5
sg1169
g1174
sg1171
I5
sS'block.thisIndex'
p1215
I7
sg1173
Vincrease
p1216
sg1175
I0
sg1177
VUBUxy
p1217
sa(dp1218
S'block.thisTrialN'
p1219
I5
sS'block.thisRepN'
p1220
I0
sg29
g33
sS'block.thisN'
p1221
I5
sg1160
(S'ADD'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1222
sg27
g28
sg1162
I4
sg1163
(I18
I6
I5
I9
tp1223
sg22
I0
sg20
F7.7278771460187272
sg23
F10.306176750456871
sVY
I4
sVX
I9
sg1165
Vthird
p1224
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1225
sg34
g11
sg1168
I9
sg1169
g1176
sg1171
I9
sS'block.thisIndex'
p1226
I10
sg1173
g1174
sg1175
g1166
sg1177
g1178
sa(dp1227
S'block.thisTrialN'
p1228
I6
sS'block.thisRepN'
p1229
I0
sg29
g33
sS'block.thisN'
p1230
I6
sg1160
(S'THIRD'
S'HALF'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1231
sg27
g28
sg1162
I4
sg1163
(I5
I6
I3
I1
tp1232
sg22
I1
sg20
F11.130962984012513
sg23
F10.89004637366088
sVY
I2
sVX
I7
sg1165
g1216
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1233
sg34
g11
sg1168
I1
sg1169
g1213
sg1171
I1
sS'block.thisIndex'
p1234
I17
sg1173
g1224
sg1175
VSUBTRACT
p1235
sg1177
VUUUBxy
p1236
sa(dp1237
S'block.thisTrialN'
p1238
I7
sS'block.thisRepN'
p1239
I0
sg29
g33
sS'block.thisN'
p1240
I7
sg1160
(S'HALF'
S'ADD'
S'x'
S'y'
tp1241
sg27
g28
sg1162
I2
sg1163
(I12
I6
tp1242
sg22
I1
sg20
F1.6408828738713055
sg23
F5.2592109513370815
sVY
I8
sVX
I4
sg1165
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1243
sg34
g11
sg1168
I6
sg1169
g1174
sg1171
I6
sS'block.thisIndex'
p1244
I3
sg1173
g1213
sg1175
I0
sg1177
g1206
sa(dp1245
S'block.thisTrialN'
p1246
I8
sS'block.thisRepN'
p1247
I0
sg29
g33
sS'block.thisN'
p1248
I8
sg1160
(S'DOUBLE'
S'THIRD'
S'ADD'
S'x'
S'y'
tp1249
sg27
g28
sg1162
I3
sg1163
(I9
I3
I6
tp1250
sg22
I1
sg20
F2.8503717137118656
sg23
F4.5697405475730193
sVY
I4
sVX
I5
sg1165
g1174
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1251
sg34
g11
sg1168
I6
sg1169
g1224
sg1171
I6
sS'block.thisIndex'
p1252
I8
sg1173
g1166
sg1175
I0
sg1177
VUUBxy
p1253
sa(dp1254
S'block.thisTrialN'
p1255
I9
sS'block.thisRepN'
p1256
I0
sg29
g33
sS'block.thisN'
p1257
I9
sg1160
(S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp1258
sg27
g28
sg1162
I3
sg1163
(I4
I1
I2
tp1259
sg22
I1
sg20
F5.8013782261823508
sg23
F4.019405125076446
sVY
I3
sVX
I3
sg1165
g1216
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1260
sg34
g11
sg1168
I2
sg1169
g1235
sg1171
I2
sS'block.thisIndex'
p1261
I6
sg1173
g1166
sg1175
I0
sg1177
g1217
sa(dp1262
S'block.thisTrialN'
p1263
I10
sS'block.thisRepN'
p1264
I0
sg29
g33
sS'block.thisN'
p1265
I10
sg1160
(S'ADD'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp1266
sg27
g28
sg1162
I3
sg1163
(I2
I6
I8
tp1267
sg22
I1
sg20
F3.3036153677367111
sg23
F18.626760797509633
sVY
I2
sVX
I4
sg1165
g1213
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1268
sg34
g11
sg1168
I8
sg1169
g1170
sg1171
I8
sS'block.thisIndex'
p1269
I5
sg1173
g1174
sg1175
I0
sg1177
g1196
sa(dp1270
S'block.thisTrialN'
p1271
I11
sS'block.thisRepN'
p1272
I0
sg29
g33
sS'block.thisN'
p1273
I11
sg1160
(S'DECREASE'
S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'x'
S'y'
tp1274
sg27
g28
sg1162
I4
sg1163
(I6
I3
I9
I8
tp1275
sg22
I0
sg20
F6.0191153553132608
sg23
F15.135314079974705
sVY
I3
sVX
I3
sg1165
g1235
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1276
sg34
g11
sg1168
I8
sg1169
g1170
sg1171
I8
sS'block.thisIndex'
p1277
I15
sg1173
g1176
sg1175
g1166
sg1177
VUUBUxy
p1278
sa(dp1279
S'block.thisTrialN'
p1280
I12
sS'block.thisRepN'
p1281
I0
sg29
g33
sS'block.thisN'
p1282
I12
sg1160
(S'INCREASE'
S'HALF'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp1283
sg27
g28
sg1162
I4
sg1163
(I12
I4
I2
I3
tp1284
sg22
I1
sg20
F6.1832429785954446
sg23
F6.5850692980184249
sVY
I4
sVX
I3
sg1165
g1224
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1285
sg34
g11
sg1168
I3
sg1169
g1213
sg1171
I3
sS'block.thisIndex'
p1286
I16
sg1173
g1216
sg1175
g1204
sg1177
g1236
sa(dp1287
S'block.thisTrialN'
p1288
I13
sS'block.thisRepN'
p1289
I0
sg29
g33
sS'block.thisN'
p1290
I13
sg1160
(S'HALF'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp1291
sg27
g28
sg1162
I3
sg1163
(I9
I10
I5
tp1292
sg22
I1
sg20
F2.6405434092957876
sg23
F6.470694583020304
sVY
I3
sVX
I3
sg1165
g1204
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1293
sg34
g11
sg1168
I5
sg1169
g1216
sg1171
I5
sS'block.thisIndex'
p1294
I9
sg1173
g1213
sg1175
I0
sg1177
g1253
sa(dp1295
S'block.thisTrialN'
p1296
I14
sS'block.thisRepN'
p1297
I0
sg29
g33
sS'block.thisN'
p1298
I14
sg1160
(S'DECREASE'
S'SUBTRACT'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp1299
sg27
g28
sg1162
I4
sg1163
(I3
I6
I4
I3
tp1300
sg22
I0
sg20
F8.4397553615272045
sg23
F18.529681627722312
sVY
I2
sVX
I9
sg1165
g1166
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1301
sg34
g11
sg1168
I3
sg1169
g1235
sg1171
I3
sS'block.thisIndex'
p1302
I13
sg1173
g1176
sg1175
g1224
sg1177
VUBUUxy
p1303
sa(dp1304
S'block.thisTrialN'
p1305
I15
sS'block.thisRepN'
p1306
I0
sg29
g33
sS'block.thisN'
p1307
I15
sg1160
(S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp1308
sg27
g28
sg1162
I2
sg1163
(I8
I2
tp1309
sg22
I1
sg20
F2.207743221993951
sg23
F3.1850606889165647
sVY
I4
sVX
I9
sg1165
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1310
sg34
g11
sg1168
I2
sg1169
g1176
sg1171
I2
sS'block.thisIndex'
p1311
I1
sg1173
VDIVIDE
p1312
sg1175
I0
sg1177
g1187
sa(dp1313
S'block.thisTrialN'
p1314
I16
sS'block.thisRepN'
p1315
I0
sg29
g33
sS'block.thisN'
p1316
I16
sg1160
(S'DECREASE'
S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp1317
sg27
g28
sg1162
I4
sg1163
(I1
I3
I6
I5
tp1318
sg22
I0
sg20
F6.1971543769413984
sg23
F6.7154670910094865
sVY
I3
sVX
I3
sg1165
g1204
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1319
sg34
g11
sg1168
I5
sg1169
g1166
sg1171
I5
sS'block.thisIndex'
p1320
I14
sg1173
g1176
sg1175
g1224
sg1177
g1278
sa(dp1321
S'block.thisTrialN'
p1322
I17
sS'block.thisRepN'
p1323
I0
sg29
g33
sS'block.thisN'
p1324
I17
sg1160
(S'DECREASE'
S'ADD'
S'THIRD'
S'HALF'
S'x'
S'y'
tp1325
sg27
g28
sg1162
I4
sg1163
(I3
I1
I7
I6
tp1326
sg22
I0
sg20
F8.695713752269512
sg23
F10.645090834770599
sVY
I6
sVX
I6
sg1165
g1224
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1327
sg34
g11
sg1168
I6
sg1169
g1174
sg1171
I6
sS'block.thisIndex'
p1328
I12
sg1173
g1176
sg1175
g1213
sg1177
g1303
sa(dp1329
S'block.thisTrialN'
p1330
I0
sS'block.thisRepN'
p1331
I0
sg29
g33
sS'block.thisN'
p1332
I0
sVRule
p1333
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'DOUBLE'
S'x'
S'y'
tp1334
sg27
g28
sVLength
p1335
I4
sVIntermediate
p1336
(I4
I3
I9
I1
tp1337
sg22
I0
sg20
F9.8162698722389905
sg23
F8.6944041889219079
sVY
I8
sVX
I2
sVOperatorc
p1338
Vdecrease
p1339
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1340
sg34
g11
sVResult
p1341
I1
sVOperatora
p1342
Vtriple
p1343
sVCorrectResponse
p1344
I1
sS'block.thisIndex'
p1345
I11
sVOperatorb
p1346
VSUBTRACT
p1347
sVOperatord
p1348
Vdouble
p1349
sVStructure
p1350
VBUUUxy
p1351
sa(dp1352
S'block.thisTrialN'
p1353
I1
sS'block.thisRepN'
p1354
I0
sg29
g33
sS'block.thisN'
p1355
I1
sg1333
(S'TIMES'
S'DOUBLE'
S'x'
S'y'
tp1356
sg27
g28
sg1335
I2
sg1336
(I4
I8
tp1357
sg22
I0
sg20
F1.7309837718421477
sg23
F2.3860625643701496
sVY
I2
sVX
I2
sg1338
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1358
sg34
g11
sg1341
I8
sg1342
g1349
sg1344
I8
sS'block.thisIndex'
p1359
I1
sg1346
VTIMES
p1360
sg1348
I0
sg1350
VBUxy
p1361
sa(dp1362
S'block.thisTrialN'
p1363
I2
sS'block.thisRepN'
p1364
I0
sg29
g33
sS'block.thisN'
p1365
I2
sg1333
(S'DOUBLE'
S'DIVIDE'
S'TRIPLE'
S'INCREASE'
S'x'
S'y'
tp1366
sg27
g28
sg1335
I4
sg1336
(I5
I15
I3
I6
tp1367
sg22
I1
sg20
F14.682831596523101
sg23
F10.425945452590895
sVY
I5
sVX
I4
sg1338
g1343
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1368
sg34
g11
sg1341
I6
sg1342
VDIVIDE
p1369
sg1344
I6
sS'block.thisIndex'
p1370
I12
sg1346
g1349
sg1348
Vincrease
p1371
sg1350
VUBUUxy
p1372
sa(dp1373
S'block.thisTrialN'
p1374
I3
sS'block.thisRepN'
p1375
I0
sg29
g33
sS'block.thisN'
p1376
I3
sg1333
(S'DOUBLE'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp1377
sg27
g28
sg1335
I3
sg1336
(I12
I4
I8
tp1378
sg22
I1
sg20
F7.4000061593560531
sg23
F6.1914230250058608
sVY
I6
sVX
I2
sg1338
g1360
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1379
sg34
g11
sg1341
I8
sg1342
Vthird
p1380
sg1344
I8
sS'block.thisIndex'
p1381
I9
sg1346
g1349
sg1348
I0
sg1350
VUUBxy
p1382
sa(dp1383
S'block.thisTrialN'
p1384
I4
sS'block.thisRepN'
p1385
I0
sg29
g33
sS'block.thisN'
p1386
I4
sg1333
(S'DOUBLE'
S'DECREASE'
S'ADD'
S'x'
S'y'
tp1387
sg27
g28
sg1335
I3
sg1336
(I4
I3
I6
tp1388
sg22
I1
sg20
F4.609184231625477
sg23
F3.4516821169709146
sVY
I2
sVX
I2
sg1338
VADD
p1389
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1390
sg34
g11
sg1341
I6
sg1342
g1339
sg1344
I6
sS'block.thisIndex'
p1391
I8
sg1346
g1349
sg1348
I0
sg1350
g1382
sa(dp1392
S'block.thisTrialN'
p1393
I5
sS'block.thisRepN'
p1394
I0
sg29
g33
sS'block.thisN'
p1395
I5
sg1333
(S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp1396
sg27
g28
sg1335
I3
sg1336
(I6
I3
I9
tp1397
sg22
I1
sg20
F6.7679563637539104
sg23
F4.9329364980749233
sVY
I3
sVX
I5
sg1338
g1371
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1398
sg34
g11
sg1341
I9
sg1342
Vhalf
p1399
sg1344
I9
sS'block.thisIndex'
p1400
I5
sg1346
g1360
sg1348
I0
sg1350
VBUUxy
p1401
sa(dp1402
S'block.thisTrialN'
p1403
I6
sS'block.thisRepN'
p1404
I0
sg29
g33
sS'block.thisN'
p1405
I6
sg1333
(S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp1406
sg27
g28
sg1335
I3
sg1336
(I3
I18
I6
tp1407
sg22
I1
sg20
F9.1157654698727129
sg23
F7.2043314280163031
sVY
I6
sVX
I6
sg1338
g1399
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1408
sg34
g11
sg1341
I6
sg1342
g1360
sg1344
I6
sS'block.thisIndex'
p1409
I7
sg1346
g1380
sg1348
I0
sg1350
VUBUxy
p1410
sa(dp1411
S'block.thisTrialN'
p1412
I7
sS'block.thisRepN'
p1413
I0
sg29
g33
sS'block.thisN'
p1414
I7
sg1333
(S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1415
sg27
g28
sg1335
I2
sg1336
(I3
I4
tp1416
sg22
I1
sg20
F2.6543771157466836
sg23
F2.4915275590992678
sVY
I3
sVX
I6
sg1338
I0
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p1417
sg34
g11
sg1341
I4
sg1342
g1347
sg1344
I4
sS'block.thisIndex'
p1418
I2
sg1346
g1371
sg1348
I0
sg1350
VUBxy
p1419
sa(dp1420
S'block.thisTrialN'
p1421
I8
sS'block.thisRepN'
p1422
I0
sg29
g33
sS'block.thisN'
p1423
I8
sg1333
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp1424
sg27
g28
sg1335
I4
sg1336
(I4
I2
I6
I5
tp1425
sg22
I0
sg20
F9.6460626833595597
sg23
F8.8003045382210985
sVY
I2
sVX
I6
sg1338
g1399
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1426
sg34
g11
sg1341
I5
sg1342
g1343
sg1344
I5
sS'block.thisIndex'
p1427
I16
sg1346
g1339
sg1348
g1347
sg1350
VUUUBxy
p1428
sa(dp1429
S'block.thisTrialN'
p1430
I9
sS'block.thisRepN'
p1431
I0
sg29
g33
sS'block.thisN'
p1432
I9
sg1333
(S'THIRD'
S'DECREASE'
S'TIMES'
S'HALF'
S'x'
S'y'
tp1433
sg27
g28
sg1335
I4
sg1336
(I4
I16
I15
I5
tp1434
sg22
I1
sg20
F8.4265312914594688
sg23
F13.834207600437367
sVY
I4
sVX
I8
sg1338
g1360
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1435
sg34
g11
sg1341
I5
sg1342
g1339
sg1344
I5
sS'block.thisIndex'
p1436
I15
sg1346
g1380
sg1348
g1399
sg1350
VUUBUxy
p1437
sa(dp1438
S'block.thisTrialN'
p1439
I10
sS'block.thisRepN'
p1440
I0
sg29
g33
sS'block.thisN'
p1441
I10
sg1333
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1442
sg27
g28
sg1335
I4
sg1336
(I1
I2
I6
I3
tp1443
sg22
I1
sg20
F7.7866587621574581
sg23
F11.258658708962685
sVY
I2
sVX
I3
sg1338
g1371
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1444
sg34
g11
sg1341
I3
sg1342
g1343
sg1344
I3
sS'block.thisIndex'
p1445
I17
sg1346
g1399
sg1348
g1347
sg1350
g1428
sa(dp1446
S'block.thisTrialN'
p1447
I11
sS'block.thisRepN'
p1448
I0
sg29
g33
sS'block.thisN'
p1449
I11
sg1333
(S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp1450
sg27
g28
sg1335
I2
sg1336
(I3
I1
tp1451
sg22
I1
sg20
F1.788773941440013
sg23
F2.6305946474476514
sVY
I3
sVX
I9
sg1338
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1452
sg34
g11
sg1341
I1
sg1342
g1380
sg1344
I1
sS'block.thisIndex'
p1453
I0
sg1346
g1369
sg1348
I0
sg1350
g1361
sa(dp1454
S'block.thisTrialN'
p1455
I12
sS'block.thisRepN'
p1456
I0
sg29
g33
sS'block.thisN'
p1457
I12
sg1333
(S'THIRD'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp1458
sg27
g28
sg1335
I3
sg1336
(I6
I3
I1
tp1459
sg22
I1
sg20
F3.3250975260743871
sg23
F8.1547699497568829
sVY
I2
sVX
I7
sg1338
g1339
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1460
sg34
g11
sg1341
I1
sg1342
g1369
sg1344
I1
sS'block.thisIndex'
p1461
I6
sg1346
g1380
sg1348
I0
sg1350
g1410
sa(dp1462
S'block.thisTrialN'
p1463
I13
sS'block.thisRepN'
p1464
I0
sg29
g33
sS'block.thisN'
p1465
I13
sg1333
(S'INCREASE'
S'ADD'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp1466
sg27
g28
sg1335
I4
sg1336
(I6
I3
I6
I7
tp1467
sg22
I0
sg20
F7.013919797467679
sg23
F13.124329076261347
sVY
I3
sVX
I2
sg1338
g1399
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1468
sg34
g11
sg1341
I7
sg1342
g1389
sg1344
I7
sS'block.thisIndex'
p1469
I13
sg1346
g1371
sg1348
g1343
sg1350
g1372
sa(dp1470
S'block.thisTrialN'
p1471
I14
sS'block.thisRepN'
p1472
I0
sg29
g33
sS'block.thisN'
p1473
I14
sg1333
(S'SUBTRACT'
S'DOUBLE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp1474
sg27
g28
sg1335
I4
sg1336
(I2
I6
I12
I8
tp1475
sg22
I1
sg20
F7.0849168889235443
sg23
F5.6869741142527346
sVY
I4
sVX
I3
sg1338
g1343
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1476
sg34
g11
sg1341
I8
sg1342
g1349
sg1344
I8
sS'block.thisIndex'
p1477
I10
sg1346
g1347
sg1348
g1339
sg1350
g1351
sa(dp1478
S'block.thisTrialN'
p1479
I15
sS'block.thisRepN'
p1480
I0
sg29
g33
sS'block.thisN'
p1481
I15
sg1333
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp1482
sg27
g28
sg1335
I3
sg1336
(I4
I12
I3
tp1483
sg22
I1
sg20
F4.6818013040337974
sg23
F9.5975570449209044
sVY
I9
sVX
I5
sg1338
g1339
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1484
sg34
g11
sg1341
I3
sg1342
g1343
sg1344
I3
sS'block.thisIndex'
p1485
I4
sg1346
g1347
sg1348
I0
sg1350
g1401
sa(dp1486
S'block.thisTrialN'
p1487
I16
sS'block.thisRepN'
p1488
I0
sg29
g33
sS'block.thisN'
p1489
I16
sg1333
(S'THIRD'
S'DIVIDE'
S'x'
S'y'
tp1490
sg27
g28
sg1335
I2
sg1336
(I3
I1
tp1491
sg22
I1
sg20
F1.8881205246234458
sg23
F3.2675939765686053
sVY
I2
sVX
I6
sg1338
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1492
sg34
g11
sg1341
I1
sg1342
g1369
sg1344
I1
sS'block.thisIndex'
p1493
I3
sg1346
g1380
sg1348
I0
sg1350
g1419
sa(dp1494
S'block.thisTrialN'
p1495
I17
sS'block.thisRepN'
p1496
I0
sg29
g33
sS'block.thisN'
p1497
I17
sg1333
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp1498
sg27
g28
sg1335
I4
sg1336
(I6
I2
I6
I5
tp1499
sg22
I1
sg20
F6.0267788556247979
sg23
F7.4576269466269878
sVY
I3
sVX
I3
sg1338
g1369
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1500
sg34
g11
sg1341
I5
sg1342
g1343
sg1344
I5
sS'block.thisIndex'
p1501
I14
sg1346
g1339
sg1348
g1349
sg1350
g1437
sasS'loops'
p1502
(lp1503
g1
(cpsychopy.data
TrialHandler
p1504
g3
NtRp1505
(dp1506
S'origin'
p1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1508
sS'thisTrial'
p1509
(lp1510
sS'_exp'
p1511
I156644944
sg10
S'practice_trials'
p1512
sg6
S'C:\\Users\\experimenter\\Desktop\\Experiments\\KRITL\\kritl_experimenter.py'
p1513
sS'thisRepN'
p1514
I1
sg24
I01
sg25
g26
sS'data'
p1515
g1
(cpsychopy.data
DataHandler
p1516
c__builtin__
dict
p1517
(dp1518
g15
cnumpy.ma.core
_mareconstruct
p1519
(cnumpy.ma.core
MaskedArray
p1520
cnumpy
ndarray
p1521
(I0
tp1522
S'b'
tRp1523
(I1
(I6
I1
tg31
(S'O4'
I0
I1
tRp1524
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'\x08\xda\x08\x04xC\x06\x04\xd8\x0c\x07\x04`\xcc\x07\x04pa\x06\x04@\xae\t\x04'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg16
g1519
(g1520
g1521
g1522
S'b'
tRp1525
(I1
(I6
I1
tg1524
I00
S'\x08\x03\x84\x01\xcc\x18\x1f\x1e\x08\x03\x84\x01\xc0\x02\x84\x01\xcc\x18\x1f\x1ex\x02\x84\x01'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'ran'
p1526
g1519
(g1520
g1521
g1522
S'b'
tRp1527
(I1
(I6
I1
tg31
(S'f4'
I0
I1
tRp1528
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg18
g1519
(g1520
g1521
g1522
S'b'
tRp1529
(I1
(I6
I1
tg1528
I00
S'\x08m\xa8@\x00\x00\x00\x00i*\xd3@\x9f\xa5\x18A\x00\x00\x00\x00\x7fJ\x92A'
S'\x00\x01\x00\x00\x01\x00'
Ntbsg14
g1519
(g1520
g1521
g1522
S'b'
tRp1530
(I1
(I6
I1
tg1524
I00
S'\xf0\xd8\x08\x04pF\x06\x04\xf0\x08\x07\x04\xd0\xcf\x07\x04\xc0K\x06\x04Ha\x1a\x04'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1531
g1519
(g1520
g1521
g1522
S'b'
tRp1532
(I1
(I6
I1
tg1528
I00
S'\x00\x00\x80@\x00\x00\x00\x00\x00\x00\x00@\x00\x00@@\x00\x00\x80?\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1519
(g1520
g1521
g1522
S'b'
tRp1533
(I1
(I6
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00'
NtbstRp1534
(dp1535
S'isNumeric'
p1536
(dp1537
g16
I00
sg1526
I01
sg18
I01
sg14
I00
sg17
I01
sg1531
I01
sg15
I00
ssS'trials'
p1538
g1505
sS'dataTypes'
p1539
(lp1540
g1526
ag1531
ag14
ag15
ag16
ag17
ag18
asS'dataShape'
p1541
(lp1542
I6
aI1
asbsS'method'
p1543
S'fullRandom'
p1544
sS'sequenceIndices'
p1545
cnumpy.core.multiarray
_reconstruct
p1546
(g1521
(I0
tS'b'
tRp1547
(I1
(I6
I1
tg1524
I00
(lp1548
I1
aI4
aI2
aI3
aI0
aI5
atbsS'finished'
p1549
I01
sS'nReps'
p1550
I1
sS'nRemaining'
p1551
I-1
sS'trialList'
p1552
(lp1553
g1
(cpsychopy.data
TrialType
p1554
g1517
(dp1555
g47
I0
sg48
g89
sg49
g72
sg50
I7
sg53
I2
sg52
I0
sg51
I5
sg54
I3
stRp1556
ag1
(g1554
g1517
(dp1557
g47
I0
sg48
g72
sg49
g70
sg50
I8
sg53
I2
sg52
I0
sg51
I3
sg54
I3
stRp1558
ag1
(g1554
g1517
(dp1559
g47
I0
sg48
g89
sg49
g90
sg50
I7
sg53
I2
sg52
I0
sg51
I5
sg54
I4
stRp1560
ag1
(g1554
g1517
(dp1561
g47
g89
sg48
g99
sg49
g90
sg50
I8
sg53
I3
sg52
I0
sg51
I2
sg54
I4
stRp1562
ag1
(g1554
g1517
(dp1563
g47
g78
sg48
g83
sg49
g81
sg50
I3
sg53
I3
sg52
I0
sg51
I3
sg54
I2
stRp1564
ag1
(g1554
g1517
(dp1565
g47
g78
sg48
g83
sg49
g116
sg50
I9
sg53
I4
sg52
g81
sg51
I8
sg54
I8
stRp1566
asS'seed'
p1567
NsS'thisIndex'
p1568
I5
sS'thisN'
p1569
I6
sS'thisTrialN'
p1570
I0
sS'nTotal'
p1571
I6
sS'_warnUseOfNext'
p1572
I01
sbag1
(g1504
g3
NtRp1573
(dp1574
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1575
sg1509
(lp1576
sg1511
I156644944
sg10
S'block'
p1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1578
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1579
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1580
(I1
(I18
I1
tg1524
I00
S'\xc0lB\x04\xa0\x1f\x08\x04\xa0\xc6\xf7\x03\xa0\x7f\xf2\x03\x80\xc1\x1b\x04`_A\x04 i\xf3\x03\xc0\x0b\x1c\x04`\xa4\x07\x04\xc0\xce\x1b\x04\xc0Z@\x04\x00\x19\t\x04@u\xf2\x03\xe0[@\x04 \x96P\x04@\xf5\x1d\x04`\x00\x1c\x04\xa0g\x17\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1581
(I1
(I18
I1
tg1528
I00
S'\xcb1\n@\xce\xfc\x1b@\xc3\xadF@\xfen\x07@\xa5\x11\xfe@\x91M\x83A\xf7\xba\xd6@S{\x89@X\xe8\xc0@TH\xba@\x84\xd3)A\xb0\x10lA\xa3m\xa6@7\xb8\x8aA\x00\x00\x00\x00\xa1t%A\x8a\x91DA`\xd0\x1eA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1582
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1583
(I1
(I18
I1
tg1524
I00
S' \xe9E\x01\xc0\x02\x84\x018\xecE\x01\xe8\xe7E\x01`r\x97\x01`r\x97\x01\xf0\x05\x8d\x01\xf0\x05\x8d\x01\xf0\xe8E\x018\xecE\x01`r\x97\x01\xe8\xe7E\x01 \xe9E\x01\x08\x03\x84\x01\xcc\x18\x1f\x1ex\x02\x84\x01x\x02\x84\x018\xecE\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1584
(I1
(I18
I1
tg1528
I00
S'\x00\x000A\x00\x00\xe0@\x00\x00\x88A\x00\x00@A\x00\x00\x80?\x00\x00pA\x00\x00PA\x00\x00\x00@\x00\x00 A\x00\x00\x80@\x00\x00\x80A\x00\x00\xc0@\x00\x00`A\x00\x00\x10A\x00\x00\x00\x00\x00\x00@@\x00\x00\xa0@\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1585
(I1
(I18
I1
tg1528
I00
S"1\x1f+@\xecNw@\xdc\\\x11@9x\x1e@\x82D\x93@9>1A\x00`\xc0@\x99'\xd1@\x9a\xcf\x15A\xdd\x8fK@\x08\xbcuAj'\x1dA\x12\xbb\x06A\xd1\x03HA~omA\xfdf\xe1@\xbae\x18A0\xd4\x06A"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1586
(dp1587
g1536
(dp1588
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1573
sg1539
(lp1589
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1590
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1591
(I1
(I18
I1
tg1524
I00
(lp1592
I14
aI4
aI7
aI15
aI9
aI16
aI11
aI1
aI17
aI13
aI8
aI0
aI3
aI6
aI12
aI5
aI10
aI2
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1593
g1
(g1554
g1517
(dp1594
g55
g235
sVY
I2
sg57
I2
sg58
g236
sg59
I4
sg60
I4
sg56
g145
sVX
I3
sg61
I0
sg62
g147
sg63
I0
sg64
g203
stRp1595
ag1
(g1554
g1517
(dp1596
g55
g199
sVY
I2
sg57
I2
sg58
g200
sg59
I6
sg60
I6
sg56
g135
sVX
I2
sg61
I0
sg62
g147
sg63
I0
sg64
g203
stRp1597
ag1
(g1554
g1517
(dp1598
g55
g284
sVY
I5
sg57
I2
sg58
g285
sg59
I3
sg60
I3
sg56
g130
sVX
I4
sg61
I0
sg62
g134
sg63
I0
sg64
g247
stRp1599
ag1
(g1554
g1517
(dp1600
g55
g243
sVY
I2
sg57
I2
sg58
g244
sg59
I1
sg60
I1
sg56
g219
sVX
I5
sg61
I0
sg62
g134
sg63
I0
sg64
g247
stRp1601
ag1
(g1554
g1517
(dp1602
g55
g141
sVY
I3
sg57
I3
sg58
g142
sg59
I9
sg60
I9
sg56
g145
sVX
I8
sg61
g143
sg62
g147
sg63
I0
sg64
g148
stRp1603
ag1
(g1554
g1517
(dp1604
g55
g268
sVY
I5
sg57
I3
sg58
g269
sg59
I5
sg60
I5
sg56
g134
sVX
I6
sg61
g143
sg62
g147
sg63
I0
sg64
g148
stRp1605
ag1
(g1554
g1517
(dp1606
g55
g252
sVY
I7
sg57
I3
sg58
g253
sg59
I5
sg60
I5
sg56
g130
sVX
I7
sg61
g135
sg62
g134
sg63
I0
sg64
g157
stRp1607
ag1
(g1554
g1517
(dp1608
g55
g153
sVY
I5
sg57
I3
sg58
g154
sg59
I5
sg60
I5
sg56
g147
sVX
I4
sg61
g145
sg62
g134
sg63
I0
sg64
g157
stRp1609
ag1
(g1554
g1517
(dp1610
g55
g226
sVY
I5
sg57
I3
sg58
g227
sg59
I8
sg60
I8
sg56
g145
sVX
I5
sg61
g147
sg62
g230
sg63
I0
sg64
g176
stRp1611
ag1
(g1554
g1517
(dp1612
g55
g171
sVY
I2
sg57
I3
sg58
g172
sg59
I3
sg60
I3
sg56
g143
sVX
I4
sg61
g173
sg62
g166
sg63
I0
sg64
g176
stRp1613
ag1
(g1554
g1517
(dp1614
g55
g276
sVY
I5
sg57
I4
sg58
g277
sg59
I3
sg60
I3
sg56
g143
sVX
I5
sg61
g135
sg62
g219
sg63
g166
sg64
g194
stRp1615
ag1
(g1554
g1517
(dp1616
g55
g190
sVY
I3
sg57
I4
sg58
g191
sg59
I9
sg60
I9
sg56
g135
sVX
I3
sg61
g134
sg62
g147
sg63
g132
sg64
g194
stRp1617
ag1
(g1554
g1517
(dp1618
g55
g260
sVY
I6
sg57
I4
sg58
g261
sg59
I4
sg60
I4
sg56
g173
sVX
I3
sg61
g166
sg62
g135
sg63
g132
sg64
g221
stRp1619
ag1
(g1554
g1517
(dp1620
g55
g216
sVY
I3
sg57
I4
sg58
g217
sg59
I3
sg60
I3
sg56
g219
sVX
I3
sg61
g132
sg62
g166
sg63
g145
sg64
g221
stRp1621
ag1
(g1554
g1517
(dp1622
g55
g128
sVY
I2
sg57
I4
sg58
g129
sg59
I8
sg60
I8
sg56
g132
sVX
I9
sg61
g130
sg62
g134
sg63
g135
sg64
g136
stRp1623
ag1
(g1554
g1517
(dp1624
g55
g162
sVY
I3
sg57
I4
sg58
g163
sg59
I6
sg60
I6
sg56
g143
sVX
I2
sg61
g130
sg62
g166
sg63
g145
sg64
g136
stRp1625
ag1
(g1554
g1517
(dp1626
g55
g181
sVY
I2
sg57
I4
sg58
g182
sg59
I1
sg60
I1
sg56
g135
sVX
I8
sg61
g143
sg62
g134
sg63
g173
sg64
g185
stRp1627
ag1
(g1554
g1517
(dp1628
g55
g208
sVY
I2
sg57
I4
sg58
g209
sg59
I6
sg60
I6
sg56
g145
sVX
I3
sg61
g143
sg62
g166
sg63
g147
sg64
g185
stRp1629
asg1567
Nsg1568
I2
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1630
(dp1631
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1632
sg1509
(lp1633
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1634
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1635
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1636
(I1
(I18
I1
tg1524
I00
S"\xa0\xb0I\x04\x80}\xf2\x03\xc0TA\x04\xc0\xbbH\x04\x80\xb0H\x04\xc0\xf6\x1b\x04 \xcb\x1b\x04\xe0\xbcH\x04@eB\x04 \xa8\x07\x04\xa0\xf5F\x04 \xfd\x1d\x04`\x1b\x1b\x04\xe0{\xf5\x03 \xfe\x1b\x04\xa0b\x1d\x04\xa0$\x07\x04`'%\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1637
(I1
(I18
I1
tg1528
I00
S'7\x91\x19@0\xacb@\xc2\x93$@\xb0\xee<@(B\xbd@,\x88\x14A\x17\x02\xbc@\xf7\xd9\x99@\x7f\xebRA\xfa\xc4|Ag\xa0\x0bAr\xa1\x0bA^\x0c\x80A\xd3\xb0\x13A\xb4\xebtA\x00\x00\x00\x00C\x7f\xdb@IG(A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1638
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1639
(I1
(I18
I1
tg1524
I00
S'\x08\x03\x84\x01`r\x97\x01x\x02\x84\x01\xf0\x05\x8d\x01`r\x97\x01\x08\x03\x84\x01\xf0\xe8E\x018\xecE\x018\xecE\x01\xc0\x02\x84\x01 \xe9E\x01\x08\x03\x84\x01\x08\x03\x84\x01\xf0\x05\x8d\x01\xc0\x02\x84\x01\xcc\x18\x1f\x1e\xf0\x05\x8d\x01x\x02\x84\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1640
(I1
(I18
I1
tg1528
I00
S'\x00\x00`A\x00\x00@A\x00\x00 A\x00\x00pA\x00\x00\x80A\x00\x00\xe0@\x00\x00\xa0@\x00\x00PA\x00\x000A\x00\x00\x10A\x00\x00@@\x00\x00\x80@\x00\x00\xc0@\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00A\x00\x00\x88A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1641
(I1
(I18
I1
tg1528
I00
S'\xdd\x1f\x13@\xdf\xaa\xd8?\xe21\xea@\xe5\xda\xcb@J\xb5\xb8@o\xf9\x96@\xf0 \xab@o\xc8\xb5@s\xfe\x10@\x82A\xa7@\xc1#\nA\xee\xb4\x07Ad\x94\xb4@,\x85(A\xa4\xb2DA\x9c\xba\x9cA\x1f\xfc/A\xc7\xe1VA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1642
(dp1643
g1536
(dp1644
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1630
sg1539
(lp1645
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1646
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1647
(I1
(I18
I1
tg1524
I00
(lp1648
I14
aI15
aI13
aI10
aI11
aI6
aI12
aI5
aI16
aI9
aI2
aI8
aI1
aI7
aI0
aI3
aI4
aI17
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1649
g1
(g1554
g1517
(dp1650
g292
g434
sVY
I5
sg294
I2
sg295
g435
sg303
I7
sg300
I7
sg301
g329
sVX
I4
sg297
I0
sg305
g384
sg307
I0
sg309
g421
stRp1651
ag1
(g1554
g1517
(dp1652
g292
g417
sVY
I3
sg294
I2
sg295
g418
sg303
I9
sg300
I9
sg301
g306
sVX
I4
sg297
I0
sg305
g298
sg307
I0
sg309
g421
stRp1653
ag1
(g1554
g1517
(dp1654
g292
g399
sVY
I8
sg294
I2
sg295
g400
sg303
I2
sg300
I2
sg301
g317
sVX
I8
sg297
I0
sg305
g403
sg307
I0
sg309
g404
stRp1655
ag1
(g1554
g1517
(dp1656
g292
g442
sVY
I2
sg294
I2
sg295
g443
sg303
I5
sg300
I5
sg301
g317
sVX
I8
sg297
I0
sg305
g308
sg307
I0
sg309
g404
stRp1657
ag1
(g1554
g1517
(dp1658
g292
g450
sVY
I2
sg294
I3
sg295
g451
sg303
I9
sg300
I9
sg301
g306
sVX
I7
sg297
g355
sg305
g317
sg307
I0
sg309
g375
stRp1659
ag1
(g1554
g1517
(dp1660
g292
g371
sVY
I2
sg294
I3
sg295
g372
sg303
I3
sg300
I3
sg301
g308
sVX
I8
sg297
g329
sg305
g298
sg307
I0
sg309
g375
stRp1661
ag1
(g1554
g1517
(dp1662
g292
g353
sVY
I2
sg294
I3
sg295
g354
sg303
I8
sg300
I8
sg301
g327
sVX
I9
sg297
g355
sg305
g329
sg307
I0
sg309
g358
stRp1663
ag1
(g1554
g1517
(dp1664
g292
g426
sVY
I3
sg294
I3
sg295
g427
sg303
I3
sg300
I3
sg301
g317
sVX
I2
sg297
g306
sg305
g308
sg307
I0
sg309
g358
stRp1665
ag1
(g1554
g1517
(dp1666
g292
g409
sVY
I3
sg294
I3
sg295
g410
sg303
I9
sg300
I9
sg301
g329
sVX
I3
sg297
g384
sg305
g306
sg307
I0
sg309
g394
stRp1667
ag1
(g1554
g1517
(dp1668
g292
g390
sVY
I2
sg294
I3
sg295
g391
sg303
I6
sg300
I6
sg301
g308
sVX
I3
sg297
g298
sg305
g306
sg307
I0
sg309
g394
stRp1669
ag1
(g1554
g1517
(dp1670
g292
g335
sVY
I4
sg294
I4
sg295
g336
sg303
I5
sg300
I5
sg301
g302
sVX
I3
sg297
g308
sg305
g317
sg307
g306
sg309
g339
stRp1671
ag1
(g1554
g1517
(dp1672
g292
g344
sVY
I9
sg294
I4
sg295
g345
sg303
I9
sg300
I9
sg301
g329
sVX
I3
sg297
g308
sg305
g327
sg307
g348
sg309
g339
stRp1673
ag1
(g1554
g1517
(dp1674
g292
g363
sVY
I4
sg294
I4
sg295
g364
sg303
I5
sg300
I5
sg301
g298
sVX
I5
sg297
g355
sg305
g329
sg307
g306
sg309
g330
stRp1675
ag1
(g1554
g1517
(dp1676
g292
g324
sVY
I2
sg294
I4
sg295
g325
sg303
I7
sg300
I7
sg301
g327
sVX
I2
sg297
g306
sg305
g308
sg307
g329
sg309
g330
stRp1677
ag1
(g1554
g1517
(dp1678
g292
g293
sVY
I4
sg294
I4
sg295
g296
sg303
I6
sg300
I6
sg301
g302
sVX
I4
sg297
g298
sg305
g306
sg307
g308
sg309
g310
stRp1679
ag1
(g1554
g1517
(dp1680
g292
g315
sVY
I8
sg294
I4
sg295
g316
sg303
I9
sg300
I9
sg301
g308
sVX
I8
sg297
g317
sg305
g306
sg307
g302
sg309
g310
stRp1681
ag1
(g1554
g1517
(dp1682
g292
g380
sVY
I4
sg294
I4
sg295
g381
sg303
I5
sg300
I5
sg301
g348
sVX
I5
sg297
g302
sg305
g355
sg307
g384
sg309
g385
stRp1683
ag1
(g1554
g1517
(dp1684
g292
g458
sVY
I4
sg294
I4
sg295
g459
sg303
I5
sg300
I5
sg301
g308
sVX
I7
sg297
g329
sg305
g348
sg307
g327
sg309
g385
stRp1685
asg1567
Nsg1568
I17
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1686
(dp1687
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1688
sg1509
(lp1689
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1690
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1691
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1692
(I1
(I18
I1
tg1524
I00
S'\x00E"\x04@V\xdb\x03@q\x19\x04\x80S\x19\x04\x80\x0b\x19\x04\xc0U\x18\x04 C\xd9\x03`\x88\x16\x04`!\x18\x04@\xcd\xd9\x03@^#\x04\xc0Z\x18\x04\xe0\x11#\x04`\x11#\x04\x80\xb6H\x04\x80\xbbI\x04\xe0\x94\x19\x04\xa0@\xd9\x03'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1693
(I1
(I18
I1
tg1528
I00
S'\xc7\x86b@\x9dn\x8c@\xfee\xfc?X\x0b&@\x00\x91}@#\xb2\xee@\xe3d\xa5@\xa6#\x84@\xa6\xc20A\xffP\xbf@\x02\xf6\x8fA\x08lEA\x9a\xceCA\xf5\xaf/AI0NA\x13%\x01A\xf0\x83,A*\xa2\x8dA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1694
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1695
(I1
(I18
I1
tg1524
I00
S'\xf0\xe8E\x01x\x02\x84\x01x\x02\x84\x01\xf0\xe8E\x01\xe8\xe7E\x01x\x02\x84\x01\xe8\xe7E\x01x\x02\x84\x01`r\x97\x01\xc0\x02\x84\x01`r\x97\x01\xe8\xe7E\x01`r\x97\x01`r\x97\x018\xecE\x01\xc0\x02\x84\x01\xf0\x05\x8d\x01 \xe9E\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1696
(I1
(I18
I1
tg1528
I00
S'\x00\x000A\x00\x00\xc0@\x00\x00\x00A\x00\x00 A\x00\x00PA\x00\x00\x00\x00\x00\x00`A\x00\x00@@\x00\x00\x10A\x00\x00\x80@\x00\x00\x80?\x00\x00\xe0@\x00\x00\x00@\x00\x00\xa0@\x00\x00\x88A\x00\x00@A\x00\x00\x80A\x00\x00pA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1697
(I1
(I18
I1
tg1528
I00
S'\xe2)\xf9?m[r@\x19\xf7\xe4@0u.@O\x16DA\x1e\xebWA0\x07\xcc@Y\xff\x85A\x98\x0b\x06A\xf8\xc3\xa5@\xc2\x84\x00Aj&\x18A\x13\x07\x1aA*\xb28ASo\x1cA\xae\x95XA\x08\x04DA/W)A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1698
(dp1699
g1536
(dp1700
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1686
sg1539
(lp1701
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1702
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1703
(I1
(I18
I1
tg1524
I00
(lp1704
I5
aI10
aI12
aI7
aI9
aI13
aI1
aI11
aI2
aI8
aI3
aI0
aI15
aI4
aI6
aI17
aI16
aI14
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1705
g1
(g1554
g1517
(dp1706
g466
g582
sVY
I4
sg468
I2
sg469
g583
sg477
I8
sg474
I8
sg475
g502
sVX
I2
sg471
I0
sg479
g494
sg481
I0
sg482
g544
stRp1707
ag1
(g1554
g1517
(dp1708
g466
g540
sVY
I6
sg468
I2
sg469
g541
sg477
I2
sg474
I2
sg475
g502
sVX
I6
sg471
I0
sg479
g514
sg481
I0
sg482
g544
stRp1709
ag1
(g1554
g1517
(dp1710
g466
g557
sVY
I7
sg468
I2
sg469
g558
sg477
I2
sg474
I2
sg475
g480
sVX
I8
sg471
I0
sg479
g502
sg481
I0
sg482
g561
stRp1711
ag1
(g1554
g1517
(dp1712
g466
g574
sVY
I4
sg468
I2
sg469
g575
sg477
I8
sg474
I8
sg475
g533
sVX
I4
sg471
I0
sg479
g476
sg481
I0
sg482
g561
stRp1713
ag1
(g1554
g1517
(dp1714
g466
g599
sVY
I4
sg468
I3
sg469
g600
sg477
I1
sg474
I1
sg475
g502
sVX
I6
sg471
g492
sg479
g514
sg481
I0
sg482
g483
stRp1715
ag1
(g1554
g1517
(dp1716
g466
g467
sVY
I4
sg468
I3
sg469
g470
sg477
I2
sg474
I2
sg475
g476
sVX
I4
sg471
g472
sg479
g480
sg481
I0
sg482
g483
stRp1717
ag1
(g1554
g1517
(dp1718
g466
g607
sVY
I7
sg468
I3
sg469
g608
sg477
I1
sg474
I1
sg475
g480
sVX
I3
sg471
g472
sg479
g476
sg481
I0
sg482
g516
stRp1719
ag1
(g1554
g1517
(dp1720
g466
g511
sVY
I3
sg468
I3
sg469
g512
sg477
I2
sg474
I2
sg475
g514
sVX
I9
sg471
g492
sg479
g490
sg481
I0
sg482
g516
stRp1721
ag1
(g1554
g1517
(dp1722
g466
g566
sVY
I2
sg468
I3
sg469
g567
sg477
I8
sg474
I8
sg475
g535
sVX
I7
sg471
g480
sg479
g502
sg481
I0
sg482
g525
stRp1723
ag1
(g1554
g1517
(dp1724
g466
g521
sVY
I3
sg468
I3
sg469
g522
sg477
I6
sg474
I6
sg475
g472
sVX
I4
sg471
g480
sg479
g502
sg481
I0
sg482
g525
stRp1725
ag1
(g1554
g1517
(dp1726
g466
g488
sVY
I6
sg468
I4
sg469
g489
sg477
I7
sg474
I7
sg475
g492
sVX
I4
sg471
g490
sg479
g494
sg481
g476
sg482
g495
stRp1727
ag1
(g1554
g1517
(dp1728
g466
g549
sVY
I5
sg468
I4
sg469
g550
sg477
I1
sg474
I1
sg475
g490
sVX
I6
sg471
g502
sg479
g514
sg481
g492
sg482
g495
stRp1729
ag1
(g1554
g1517
(dp1730
g466
g500
sVY
I4
sg468
I4
sg469
g501
sg477
I9
sg474
I9
sg475
g494
sVX
I9
sg471
g502
sg479
g505
sg481
g492
sg482
g506
stRp1731
ag1
(g1554
g1517
(dp1732
g466
g530
sVY
I4
sg468
I4
sg469
g531
sg477
I7
sg474
I7
sg475
g533
sVX
I3
sg471
g502
sg479
g535
sg481
g492
sg482
g506
stRp1733
ag1
(g1554
g1517
(dp1734
g466
g632
sVY
I6
sg468
I4
sg469
g633
sg477
I3
sg474
I3
sg475
g492
sVX
I4
sg471
g533
sg479
g535
sg481
g476
sg482
g594
stRp1735
ag1
(g1554
g1517
(dp1736
g466
g590
sVY
I8
sg468
I4
sg469
g591
sg477
I6
sg474
I6
sg475
g472
sVX
I9
sg471
g514
sg479
g502
sg481
g535
sg482
g594
stRp1737
ag1
(g1554
g1517
(dp1738
g466
g624
sVY
I2
sg468
I4
sg469
g625
sg477
I5
sg474
I5
sg475
g476
sVX
I8
sg471
g472
sg479
g535
sg481
g514
sg482
g619
stRp1739
ag1
(g1554
g1517
(dp1740
g466
g615
sVY
I4
sg468
I4
sg469
g616
sg477
I4
sg474
I4
sg475
g535
sVX
I4
sg471
g472
sg479
g502
sg481
g514
sg482
g619
stRp1741
asg1567
Nsg1568
I14
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1742
(dp1743
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1744
sg1509
(lp1745
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1746
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1747
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1748
(I1
(I18
I1
tg1524
I00
S'`\xc9"\x04\xa0s7\x04\xe0\x14\xda\x03\xa0{\x19\x04@q\xd9\x03\x00\x1e#\x04`\x15$\x04\xe0;I\x04 P\xdb\x03 \x98\x19\x04\x00\x99\x18\x04\x80\x057\x04\xc0\x98\xda\x03\xa0~\xd9\x03@H"\x04`\x1a1\x04\xa0z7\x04@T\xdb\x03'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1749
(I1
(I18
I1
tg1528
I00
S"\xa8\xc8:@'k~@\x80\xa1\xf8?\x9f\xa4)@\xed\xc7\xe8@n4,Ax}\xa1@\x94\xba\xed@4=\x99@5\xa2\x9a@\xd5,\xfe@a\xea?A\xf4\x9f=A\xd15\x9eA\xaf\x055A\x00\x00\x00\x00\xf3W\xfe@\x00\x00\x00\x00"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x01'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1750
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1751
(I1
(I18
I1
tg1524
I00
S'\x08\x03\x84\x01x\x02\x84\x01\xf0\xe8E\x01\xf0\xe8E\x01 \xe9E\x018\xecE\x01\x08\x03\x84\x01x\x02\x84\x01\xf0\x05\x8d\x01\xe8\xe7E\x01x\x02\x84\x01\xc0\x02\x84\x018\xecE\x018\xecE\x01\xc0\x02\x84\x01\xcc\x18\x1f\x1e\xf0\xe8E\x01\xcc\x18\x1f\x1e'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1752
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80@\x00\x00\x10A\x00\x00`A\x00\x000A\x00\x00@@\x00\x00\xe0@\x00\x00\x80?\x00\x00PA\x00\x00\x00A\x00\x00\x88A\x00\x00 A\x00\x00\x00\x00\x00\x00pA\x00\x00\xc0@\x00\x00@A\x00\x00\x80A\x00\x00\xa0@\x00\x00\x00@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1753
(I1
(I18
I1
tg1528
I00
S'*<k@\x11X\x83@\xed\x88I@m\x13\xe3?if\xa2@\xcc\xa4S@l\x10\tA\xfc\xe3\x84@\x95\xff\xce@^\x86\xbd@0\xb6\xab@\x8b\xcfeA&\xe3\x00A\xf2{\x07Ad)\xe9@`i\xc9@\xb3.(A\x8b<\x9dA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1754
(dp1755
g1536
(dp1756
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1742
sg1539
(lp1757
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1758
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1759
(I1
(I18
I1
tg1524
I00
(lp1760
I11
aI6
aI17
aI4
aI0
aI16
aI13
aI5
aI8
aI1
aI10
aI3
aI14
aI7
aI2
aI12
aI15
aI9
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1761
g1
(g1554
g1517
(dp1762
g640
g694
sVY
I6
sg642
I2
sg643
g695
sg651
I7
sg648
I7
sg649
g697
sVX
I3
sg645
I0
sg653
g666
sg655
I0
sg657
g699
stRp1763
ag1
(g1554
g1517
(dp1764
g640
g739
sVY
I4
sg642
I2
sg643
g740
sg651
I2
sg648
I2
sg649
g650
sVX
I5
sg645
I0
sg653
g678
sg655
I0
sg657
g699
stRp1765
ag1
(g1554
g1517
(dp1766
g640
g781
sVY
I2
sg642
I2
sg643
g782
sg651
I8
sg648
I8
sg649
g666
sVX
I2
sg645
I0
sg653
g723
sg655
I0
sg657
g759
stRp1767
ag1
(g1554
g1517
(dp1768
g640
g755
sVY
I2
sg642
I2
sg643
g756
sg651
I8
sg648
I8
sg649
g654
sVX
I2
sg645
I0
sg653
g723
sg655
I0
sg657
g759
stRp1769
ag1
(g1554
g1517
(dp1770
g640
g684
sVY
I3
sg642
I3
sg643
g685
sg651
I4
sg648
I4
sg649
g656
sVX
I8
sg645
g646
sg653
g688
sg655
I0
sg657
g689
stRp1771
ag1
(g1554
g1517
(dp1772
g640
g721
sVY
I2
sg642
I3
sg643
g722
sg651
I4
sg648
I4
sg649
g697
sVX
I3
sg645
g723
sg653
g654
sg655
I0
sg657
g689
stRp1773
ag1
(g1554
g1517
(dp1774
g640
g663
sVY
I2
sg642
I3
sg643
g664
sg651
I9
sg648
I9
sg649
g666
sVX
I2
sg645
g656
sg653
g650
sg655
I0
sg657
g668
stRp1775
ag1
(g1554
g1517
(dp1776
g640
g773
sVY
I2
sg642
I3
sg643
g774
sg651
I2
sg648
I2
sg649
g678
sVX
I9
sg645
g697
sg653
g650
sg655
I0
sg657
g668
stRp1777
ag1
(g1554
g1517
(dp1778
g640
g730
sVY
I4
sg642
I3
sg643
g731
sg651
I5
sg648
I5
sg649
g656
sVX
I8
sg645
g688
sg653
g676
sg655
I0
sg657
g734
stRp1779
ag1
(g1554
g1517
(dp1780
g640
g805
sVY
I6
sg642
I3
sg643
g806
sg651
I1
sg648
I1
sg649
g650
sVX
I8
sg645
g678
sg653
g697
sg655
I0
sg657
g734
stRp1781
ag1
(g1554
g1517
(dp1782
g640
g747
sVY
I3
sg642
I4
sg643
g748
sg651
I2
sg648
I2
sg649
g723
sVX
I6
sg645
g650
sg653
g688
sg655
g697
sg657
g658
stRp1783
ag1
(g1554
g1517
(dp1784
g640
g641
sVY
I2
sg642
I4
sg643
g644
sg651
I8
sg648
I8
sg649
g650
sVX
I2
sg645
g646
sg653
g654
sg655
g656
sg657
g658
stRp1785
ag1
(g1554
g1517
(dp1786
g640
g789
sVY
I3
sg642
I4
sg643
g790
sg651
I3
sg648
I3
sg649
g688
sVX
I4
sg645
g656
sg653
g650
sg655
g646
sg657
g716
stRp1787
ag1
(g1554
g1517
(dp1788
g640
g712
sVY
I3
sg642
I4
sg643
g713
sg651
I4
sg648
I4
sg649
g654
sVX
I7
sg645
g646
sg653
g697
sg655
g650
sg657
g716
stRp1789
ag1
(g1554
g1517
(dp1790
g640
g764
sVY
I4
sg642
I4
sg643
g765
sg651
I7
sg648
I7
sg649
g650
sVX
I8
sg645
g666
sg653
g697
sg655
g723
sg657
g768
stRp1791
ag1
(g1554
g1517
(dp1792
g640
g797
sVY
I3
sg642
I4
sg643
g798
sg651
I6
sg648
I6
sg649
g723
sVX
I5
sg645
g678
sg653
g656
sg655
g676
sg657
g768
stRp1793
ag1
(g1554
g1517
(dp1794
g640
g704
sVY
I2
sg642
I4
sg643
g705
sg651
I8
sg648
I8
sg649
g656
sVX
I4
sg645
g646
sg653
g676
sg655
g666
sg657
g679
stRp1795
ag1
(g1554
g1517
(dp1796
g640
g673
sVY
I5
sg642
I4
sg643
g674
sg651
I3
sg648
I3
sg649
g676
sVX
I9
sg645
g646
sg653
g656
sg655
g678
sg657
g679
stRp1797
asg1567
Nsg1568
I9
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1798
(dp1799
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1800
sg1509
(lp1801
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1802
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1803
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1804
(I1
(I18
I1
tg1524
I00
S'\xc0\xae\xd8\x03`\x9c\x19\x04\x00\xc1"\x04 z\xf2\x03`\xf38\x04\x00\x0e7\x04\xa0d8\x04`\xa9\xd8\x03@7I\x04\xc0I"\x04`\x99\x18\x04 e\xf3\x03@\x1a$\x04\xa0p\xd9\x03\xc0\x1c$\x04\xa0q\xd9\x03\xe0\xf9\xf2\x03`T\xdb\x03'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1805
(I1
(I18
I1
tg1528
I00
S"\x03>4@\x82\x94E@!\x02`@\xfd1\xf4?\xd2\xd4\x18A[r\xea@P\xdc\xb2@\xf9\x0c\xf1@\xae\xed\xd9@\xbd$\xa9@J_1A&\xa6dA<\x84\x02A\xf2\xe1\x01A\xb5hnA6\x1c'A\xb7q\xeb@v\x81\x13A"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1806
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1807
(I1
(I18
I1
tg1524
I00
S'x\x02\x84\x01\x08\x03\x84\x018\xecE\x01\xc0\x02\x84\x01\xe8\xe7E\x018\xecE\x01\xc0\x02\x84\x018\xecE\x01\x08\x03\x84\x01\xe8\xe7E\x01\xf0\xe8E\x01\xf0\xe8E\x01\xf0\x05\x8d\x01\xf0\x05\x8d\x01\xf0\xe8E\x01\xe8\xe7E\x01\xc0\x02\x84\x01\xc0\x02\x84\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1808
(I1
(I18
I1
tg1528
I00
S'\x00\x00PA\x00\x00\x80A\x00\x00\x00A\x00\x00\xc0@\x00\x00@@\x00\x00\x80?\x00\x00\xa0@\x00\x00\x00\x00\x00\x00pA\x00\x00`A\x00\x00@A\x00\x00\xe0@\x00\x00\x00@\x00\x00\x10A\x00\x000A\x00\x00\x80@\x00\x00\x88A\x00\x00 A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1809
(I1
(I18
I1
tg1528
I00
S'B\x08\x1e@\x9e\xdaA@\x86\xf4\xf4?\x15l\r@}(\x15A\xc1\x83M@y\x01#@\xf8{\xa4@\x8a\xddA@\x13g\xfd?9?\xcf@\xf0\xa7!A;<\xc4@\xa0\x82\x10A\xfd\x15\xda@\x9a\x04+Ay\xb1\xf5@3\xb8fA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1810
(dp1811
g1536
(dp1812
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1798
sg1539
(lp1813
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1814
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1815
(I1
(I18
I1
tg1524
I00
(lp1816
I7
aI5
aI12
aI4
aI15
aI6
aI3
aI11
aI2
aI13
aI17
aI14
aI10
aI0
aI9
aI8
aI1
aI16
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1817
g1
(g1554
g1517
(dp1818
g813
g945
sVY
I2
sg815
I2
sg816
g946
sg824
I2
sg821
I2
sg822
g827
sVX
I3
sg818
I0
sg826
g841
sg828
I0
sg829
g949
stRp1819
ag1
(g1554
g1517
(dp1820
g813
g971
sVY
I2
sg815
I2
sg816
g972
sg824
I3
sg821
I3
sg822
g839
sVX
I6
sg818
I0
sg826
g823
sg828
I0
sg829
g949
stRp1821
ag1
(g1554
g1517
(dp1822
g813
g903
sVY
I4
sg815
I2
sg816
g904
sg824
I1
sg821
I1
sg822
g841
sVX
I8
sg818
I0
sg826
g839
sg828
I0
sg829
g889
stRp1823
ag1
(g1554
g1517
(dp1824
g813
g885
sVY
I2
sg815
I2
sg816
g886
sg824
I6
sg821
I6
sg822
g850
sVX
I3
sg818
I0
sg826
g827
sg828
I0
sg829
g889
stRp1825
ag1
(g1554
g1517
(dp1826
g813
g859
sVY
I8
sg815
I3
sg816
g860
sg824
I9
sg821
I9
sg822
g819
sVX
I6
sg818
g853
sg826
g850
sg828
I0
sg829
g842
stRp1827
ag1
(g1554
g1517
(dp1828
g813
g835
sVY
I2
sg815
I3
sg816
g836
sg824
I4
sg821
I4
sg822
g839
sVX
I3
sg818
g837
sg826
g841
sg828
I0
sg829
g842
stRp1829
ag1
(g1554
g1517
(dp1830
g813
g877
sVY
I3
sg815
I3
sg816
g878
sg824
I6
sg821
I6
sg822
g850
sVX
I3
sg818
g837
sg826
g819
sg828
I0
sg829
g830
stRp1831
ag1
(g1554
g1517
(dp1832
g813
g814
sVY
I2
sg815
I3
sg816
g817
sg824
I3
sg821
I3
sg822
g823
sVX
I8
sg818
g819
sg826
g827
sg828
I0
sg829
g830
stRp1833
ag1
(g1554
g1517
(dp1834
g813
g963
sVY
I3
sg815
I3
sg816
g964
sg824
I7
sg821
I7
sg822
g837
sVX
I6
sg818
g841
sg826
g827
sg828
I0
sg829
g958
stRp1835
ag1
(g1554
g1517
(dp1836
g813
g954
sVY
I3
sg815
I3
sg816
g955
sg824
I1
sg821
I1
sg822
g819
sVX
I3
sg818
g850
sg826
g853
sg828
I0
sg829
g958
stRp1837
ag1
(g1554
g1517
(dp1838
g813
g937
sVY
I6
sg815
I4
sg816
g938
sg824
I8
sg821
I8
sg822
g852
sVX
I6
sg818
g839
sg826
g850
sg828
g853
sg829
g898
stRp1839
ag1
(g1554
g1517
(dp1840
g813
g894
sVY
I9
sg815
I4
sg816
g895
sg824
I8
sg821
I8
sg822
g839
sVX
I3
sg818
g837
sg826
g823
sg828
g852
sg829
g898
stRp1841
ag1
(g1554
g1517
(dp1842
g813
g847
sVY
I2
sg815
I4
sg816
g848
sg824
I8
sg821
I8
sg822
g850
sVX
I3
sg818
g827
sg826
g852
sg828
g853
sg829
g854
stRp1843
ag1
(g1554
g1517
(dp1844
g813
g911
sVY
I3
sg815
I4
sg816
g912
sg824
I2
sg821
I2
sg822
g914
sVX
I2
sg818
g852
sg826
g853
sg828
g839
sg829
g854
stRp1845
ag1
(g1554
g1517
(dp1846
g813
g929
sVY
I7
sg815
I4
sg816
g930
sg824
I8
sg821
I8
sg822
g852
sVX
I6
sg818
g850
sg826
g853
sg828
g839
sg829
g872
stRp1847
ag1
(g1554
g1517
(dp1848
g813
g867
sVY
I9
sg815
I4
sg816
g868
sg824
I1
sg821
I1
sg822
g870
sVX
I9
sg818
g841
sg826
g853
sg828
g852
sg829
g872
stRp1849
ag1
(g1554
g1517
(dp1850
g813
g979
sVY
I3
sg815
I4
sg816
g980
sg824
I6
sg821
I6
sg822
g837
sVX
I9
sg818
g827
sg826
g819
sg828
g841
sg829
g924
stRp1851
ag1
(g1554
g1517
(dp1852
g813
g920
sVY
I4
sg815
I4
sg816
g921
sg824
I6
sg821
I6
sg822
g852
sVX
I2
sg818
g827
sg826
g853
sg828
g914
sg829
g924
stRp1853
asg1567
Nsg1568
I16
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1854
(dp1855
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1856
sg1509
(lp1857
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1858
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1859
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1860
(I1
(I18
I1
tg1524
I00
S'\xc0)%\x04\xc0V\x18\x04`\x90\x18\x04\xc0Y#\x04\xa0\x18#\x04\x00]\xdb\x03\xe0o8\x04\xc0K"\x04\x00\x16$\x04\x80R\x19\x04\xc0\xe9$\x04@PG\x04\x80&\x18\x04\xe0\x12#\x04@\xc9"\x04\xc0\x9f\x18\x04 \xc3"\x04 \x99\xda\x03'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1861
(I1
(I18
I1
tg1528
I00
S'A]\x9a@\x1d1\xda?\xd9\xf6z@\xc7KW@*Y\x1aA\xcc9?A\xd9\xbe\xca@\\U\xa4@f^\xb4@\x14\x8e\x05A\xe5)\xd7@7\xf5\x93A\xfc\xbc\x8d@\xc0\xbfVA5\xf4qA\x06zVAK\x8b\xc0@J\xbf\x15A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1862
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1863
(I1
(I18
I1
tg1524
I00
S'\xe8\xe7E\x01 \xe9E\x01`r\x97\x01\xc0\x02\x84\x01x\x02\x84\x01\x08\x03\x84\x01\xf0\xe8E\x01x\x02\x84\x01\xe8\xe7E\x01`r\x97\x01\xe8\xe7E\x01\xe8\xe7E\x018\xecE\x018\xecE\x018\xecE\x01\xe8\xe7E\x01\x08\x03\x84\x01\x08\x03\x84\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1864
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00@@\x00\x00`A\x00\x00\x80@\x00\x000A\x00\x00@A\x00\x00\x10A\x00\x00\x00\x00\x00\x00PA\x00\x00pA\x00\x00\x00A\x00\x00\xe0@\x00\x00\x80A\x00\x00\xa0@\x00\x00 A\x00\x00\x00@\x00\x00\xc0@\x00\x00\x88A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1865
(I1
(I18
I1
tg1528
I00
S'\xfc\xb4*@~!\xee?o\xc5$@HZ\xcd?\xa9\xa21A`\x1c\x9f@\x024\xfa@\xb8|\x06A\xc2\x07\x93@\x01\xa2E@\xec?\x18A\xe0g\x06A\xb9\x18\x80@j\xf3\xd6@\xbd44A\xd5`\x14A\x81\xd7\xcb@a\x86\x8cA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1866
(dp1867
g1536
(dp1868
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1854
sg1539
(lp1869
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1870
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1871
(I1
(I18
I1
tg1524
I00
(lp1872
I7
aI0
aI15
aI1
aI3
aI13
aI16
aI11
aI10
aI6
aI14
aI4
aI5
aI8
aI2
aI9
aI12
aI17
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1873
g1
(g1554
g1517
(dp1874
g987
g1009
sVY
I2
sg989
I2
sg990
g1010
sg998
I1
sg995
I1
sg996
g1012
sVX
I9
sg992
I0
sg1000
g1014
sg1002
I0
sg1003
g1015
stRp1875
ag1
(g1554
g1517
(dp1876
g987
g1029
sVY
I4
sg989
I2
sg990
g1030
sg998
I4
sg995
I4
sg996
g1012
sVX
I3
sg992
I0
sg1000
g1033
sg1002
I0
sg1003
g1015
stRp1877
ag1
(g1554
g1517
(dp1878
g987
g1128
sVY
I4
sg989
I2
sg990
g1129
sg998
I9
sg995
I9
sg996
g1033
sVX
I2
sg992
I0
sg1000
g1001
sg1002
I0
sg1003
g1043
stRp1879
ag1
(g1554
g1517
(dp1880
g987
g1038
sVY
I6
sg989
I2
sg990
g1039
sg998
I6
sg995
I6
sg996
g1014
sVX
I8
sg992
I0
sg1000
g1042
sg1002
I0
sg1003
g1043
stRp1881
ag1
(g1554
g1517
(dp1882
g987
g1102
sVY
I4
sg989
I3
sg990
g1103
sg998
I6
sg995
I6
sg996
g1061
sVX
I6
sg992
g993
sg1000
g1062
sg1002
I0
sg1003
g1106
stRp1883
ag1
(g1554
g1517
(dp1884
g987
g1111
sVY
I9
sg989
I3
sg990
g1112
sg998
I7
sg995
I7
sg996
g1072
sVX
I9
sg992
g1061
sg1000
g1014
sg1002
I0
sg1003
g1106
stRp1885
ag1
(g1554
g1517
(dp1886
g987
g1086
sVY
I4
sg989
I3
sg990
g1087
sg998
I8
sg995
I8
sg996
g1033
sVX
I3
sg992
g1012
sg1000
g1072
sg1002
I0
sg1003
g1004
stRp1887
ag1
(g1554
g1517
(dp1888
g987
g988
sVY
I2
sg989
I3
sg990
g991
sg998
I2
sg995
I2
sg996
g997
sVX
I4
sg992
g993
sg1000
g1001
sg1002
I0
sg1003
g1004
stRp1889
ag1
(g1554
g1517
(dp1890
g987
g1119
sVY
I2
sg989
I3
sg990
g1120
sg998
I1
sg995
I1
sg996
g993
sVX
I8
sg992
g997
sg1000
g1061
sg1002
I0
sg1003
g1123
stRp1891
ag1
(g1554
g1517
(dp1892
g987
g1136
sVY
I3
sg989
I3
sg990
g1137
sg998
I9
sg995
I9
sg996
g993
sVX
I2
sg992
g1033
sg1000
g1042
sg1002
I0
sg1003
g1123
stRp1893
ag1
(g1554
g1517
(dp1894
g987
g1078
sVY
I3
sg989
I4
sg990
g1079
sg998
I1
sg995
I1
sg996
g1061
sVX
I6
sg992
g1012
sg1000
g997
sg1002
g1072
sg1003
g1073
stRp1895
ag1
(g1554
g1517
(dp1896
g987
g1068
sVY
I2
sg989
I4
sg990
g1069
sg998
I2
sg995
I2
sg996
g1061
sVX
I3
sg992
g1012
sg1000
g1033
sg1002
g1072
sg1003
g1073
stRp1897
ag1
(g1554
g1517
(dp1898
g987
g1144
sVY
I9
sg989
I4
sg990
g1145
sg998
I1
sg995
I1
sg996
g997
sVX
I3
sg992
g1042
sg1000
g1061
sg1002
g1072
sg1003
g1052
stRp1899
ag1
(g1554
g1517
(dp1900
g987
g1048
sVY
I3
sg989
I4
sg990
g1049
sg998
I3
sg995
I3
sg996
g1014
sVX
I6
sg992
g1001
sg1000
g1042
sg1002
g993
sg1003
g1052
stRp1901
ag1
(g1554
g1517
(dp1902
g987
g1094
sVY
I2
sg989
I4
sg990
g1095
sg998
I7
sg995
I7
sg996
g993
sVX
I2
sg992
g1033
sg1000
g1001
sg1002
g1042
sg1003
g1024
stRp1903
ag1
(g1554
g1517
(dp1904
g987
g1020
sVY
I2
sg989
I4
sg990
g1021
sg998
I1
sg995
I1
sg996
g1001
sVX
I8
sg992
g1014
sg1000
g1012
sg1002
g993
sg1003
g1024
stRp1905
ag1
(g1554
g1517
(dp1906
g987
g1057
sVY
I2
sg989
I4
sg990
g1058
sg998
I5
sg995
I5
sg996
g993
sVX
I2
sg992
g1042
sg1000
g1061
sg1002
g1062
sg1003
g1063
stRp1907
ag1
(g1554
g1517
(dp1908
g987
g1152
sVY
I2
sg989
I4
sg990
g1153
sg998
I7
sg995
I7
sg996
g1042
sVX
I2
sg992
g993
sg1000
g1001
sg1002
g1062
sg1003
g1063
stRp1909
asg1567
Nsg1568
I17
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1910
(dp1911
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1912
sg1509
(lp1913
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1914
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1915
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1916
(I1
(I18
I1
tg1524
I00
S'`D"\x04\xe0Q#\x04 \xa3\xd8\x03\x80v\xd9\x03\x00%%\x04\x00h\x17\x04 \x81\xf7\x03\x80\x047\x04@\xff8\x04@u\xd9\x03\xa0\x1a$\x04\x80\xe01\x04\x00\xa9\xd8\x03\xe0\xff8\x04@\x007\x04 \x84\xf7\x03`w7\x04\x00\xf68\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1917
(I1
(I18
I1
tg1528
I00
S"\xb7\xed\x15@\t\xd8K@\xd1k\x12@uK\xa8@n\xc3'@\x9b\x03\x95A\xf7\x9e\x80@\xcd-\x96@Q;\x92@\xee\x0f\xcf@\x1a\xe6$A\xed\xb0\xc1@KR*A\xca<\x94A\x1b\xe5\xd6@?*rA\xe3\xb8\xd2@\xa1=.A"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1918
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1919
(I1
(I18
I1
tg1524
I00
S'\x08\x03\x84\x01x\x02\x84\x01\xf0\xe8E\x01\xc0\x02\x84\x01\x08\x03\x84\x01\xf0\xe8E\x01x\x02\x84\x01\xf0\x05\x8d\x01\xc0\x02\x84\x01\xf0\x05\x8d\x01\x08\x03\x84\x018\xecE\x01x\x02\x84\x01x\x02\x84\x01\xc0\x02\x84\x01`r\x97\x018\xecE\x01\xe8\xe7E\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1920
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00pA\x00\x00@@\x00\x00\xe0@\x00\x00\x00@\x00\x00 A\x00\x00\x10A\x00\x00\x80@\x00\x00\x00A\x00\x00PA\x00\x00\xa0@\x00\x00\x00\x00\x00\x00\x88A\x00\x00`A\x00\x00\x80A\x00\x000A\x00\x00@A\x00\x00\xc0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1921
(I1
(I18
I1
tg1528
I00
S't\xd9m@\xaaK\r@\xdd\xbf/@s\x08\xd2?\x814\x02AonS@\xe4\xa4\xb9@cX\xe8@}l6@\xaa\xfe(@\xc5J\xf7@2\x9e\x87A\xa5!\x0bA=\t\x07A\x17O\xc6@\x98\x9c\xc0@ \xdd\xc5@m\x182A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1922
(dp1923
g1536
(dp1924
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1910
sg1539
(lp1925
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1926
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1927
(I1
(I18
I1
tg1524
I00
(lp1928
I11
aI0
aI4
aI2
aI7
aI10
aI17
aI3
aI8
aI6
aI5
aI15
aI16
aI9
aI13
aI1
aI14
aI12
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1929
g1
(g1554
g1517
(dp1930
g1160
g1183
sVY
I5
sg1162
I2
sg1163
g1184
sg1171
I7
sg1168
I7
sg1169
g1176
sVX
I3
sg1165
I0
sg1173
g1174
sg1175
I0
sg1177
g1187
stRp1931
ag1
(g1554
g1517
(dp1932
g1160
g1308
sVY
I4
sg1162
I2
sg1163
g1309
sg1171
I2
sg1168
I2
sg1169
g1176
sVX
I9
sg1165
I0
sg1173
g1312
sg1175
I0
sg1177
g1187
stRp1933
ag1
(g1554
g1517
(dp1934
g1160
g1201
sVY
I3
sg1162
I2
sg1163
g1202
sg1171
I8
sg1168
I8
sg1169
g1204
sVX
I3
sg1165
I0
sg1173
g1176
sg1175
I0
sg1177
g1206
stRp1935
ag1
(g1554
g1517
(dp1936
g1160
g1241
sVY
I8
sg1162
I2
sg1163
g1242
sg1171
I6
sg1168
I6
sg1169
g1174
sVX
I4
sg1165
I0
sg1173
g1213
sg1175
I0
sg1177
g1206
stRp1937
ag1
(g1554
g1517
(dp1938
g1160
g1192
sVY
I5
sg1162
I3
sg1163
g1193
sg1171
I7
sg1168
I7
sg1169
g1166
sVX
I2
sg1165
g1176
sg1173
g1174
sg1175
I0
sg1177
g1196
stRp1939
ag1
(g1554
g1517
(dp1940
g1160
g1266
sVY
I2
sg1162
I3
sg1163
g1267
sg1171
I8
sg1168
I8
sg1169
g1170
sVX
I4
sg1165
g1213
sg1173
g1174
sg1175
I0
sg1177
g1196
stRp1941
ag1
(g1554
g1517
(dp1942
g1160
g1258
sVY
I3
sg1162
I3
sg1163
g1259
sg1171
I2
sg1168
I2
sg1169
g1235
sVX
I3
sg1165
g1216
sg1173
g1166
sg1175
I0
sg1177
g1217
stRp1943
ag1
(g1554
g1517
(dp1944
g1160
g1211
sVY
I3
sg1162
I3
sg1163
g1212
sg1171
I5
sg1168
I5
sg1169
g1174
sVX
I2
sg1165
g1213
sg1173
g1216
sg1175
I0
sg1177
g1217
stRp1945
ag1
(g1554
g1517
(dp1946
g1160
g1249
sVY
I4
sg1162
I3
sg1163
g1250
sg1171
I6
sg1168
I6
sg1169
g1224
sVX
I5
sg1165
g1174
sg1173
g1166
sg1175
I0
sg1177
g1253
stRp1947
ag1
(g1554
g1517
(dp1948
g1160
g1291
sVY
I3
sg1162
I3
sg1163
g1292
sg1171
I5
sg1168
I5
sg1169
g1216
sVX
I3
sg1165
g1204
sg1173
g1213
sg1175
I0
sg1177
g1253
stRp1949
ag1
(g1554
g1517
(dp1950
g1160
g1222
sVY
I4
sg1162
I4
sg1163
g1223
sg1171
I9
sg1168
I9
sg1169
g1176
sVX
I9
sg1165
g1224
sg1173
g1174
sg1175
g1166
sg1177
g1178
stRp1951
ag1
(g1554
g1517
(dp1952
g1160
g1161
sVY
I2
sg1162
I4
sg1163
g1164
sg1171
I8
sg1168
I8
sg1169
g1170
sVX
I2
sg1165
g1166
sg1173
g1174
sg1175
g1176
sg1177
g1178
stRp1953
ag1
(g1554
g1517
(dp1954
g1160
g1325
sVY
I6
sg1162
I4
sg1163
g1326
sg1171
I6
sg1168
I6
sg1169
g1174
sVX
I6
sg1165
g1224
sg1173
g1176
sg1175
g1213
sg1177
g1303
stRp1955
ag1
(g1554
g1517
(dp1956
g1160
g1299
sVY
I2
sg1162
I4
sg1163
g1300
sg1171
I3
sg1168
I3
sg1169
g1235
sVX
I9
sg1165
g1166
sg1173
g1176
sg1175
g1224
sg1177
g1303
stRp1957
ag1
(g1554
g1517
(dp1958
g1160
g1317
sVY
I3
sg1162
I4
sg1163
g1318
sg1171
I5
sg1168
I5
sg1169
g1166
sVX
I3
sg1165
g1204
sg1173
g1176
sg1175
g1224
sg1177
g1278
stRp1959
ag1
(g1554
g1517
(dp1960
g1160
g1274
sVY
I3
sg1162
I4
sg1163
g1275
sg1171
I8
sg1168
I8
sg1169
g1170
sVX
I3
sg1165
g1235
sg1173
g1176
sg1175
g1166
sg1177
g1278
stRp1961
ag1
(g1554
g1517
(dp1962
g1160
g1283
sVY
I4
sg1162
I4
sg1163
g1284
sg1171
I3
sg1168
I3
sg1169
g1213
sVX
I3
sg1165
g1224
sg1173
g1216
sg1175
g1204
sg1177
g1236
stRp1963
ag1
(g1554
g1517
(dp1964
g1160
g1231
sVY
I2
sg1162
I4
sg1163
g1232
sg1171
I1
sg1168
I1
sg1169
g1213
sVX
I7
sg1165
g1216
sg1173
g1224
sg1175
g1235
sg1177
g1236
stRp1965
asg1567
Nsg1568
I12
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1966
(dp1967
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1968
sg1509
(lp1969
sg1511
I156644944
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1970
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1971
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1972
(I1
(I18
I1
tg1524
I00
S'\x00\x85\xf6\x03@.:\x04@\x13$\x04 _\xdb\x03 v\xd9\x03@X\x19\x04\x80\xdbQ\x04\x80\x9e\x18\x04\xc0\xa4?\x04\xa0\xe01\x04\xc0i8\x04 \xc6\xf7\x03\x00\xc3\xf7\x03\x80UA\x04`[\x18\x04\xc0\x8d\x16\x04\x00\xff8\x04 \xfb8\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1973
(I1
(I18
I1
tg1528
I00
S'\xaa[(@@\xb5\x18@0u\x1f@B Q@\x98\x8f\x19A\x9e\xda\x9d@\xf0y\x02A\xe2\x89\xe6@\\\xe8\\@# \xc6@\xb1\xfb\xb5@H\x1c\x0bA\xac\xd0&A@\xfdQA\xe1\xa4\xee@\xeaX]A\x0c\xce\x0cAw#4A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1974
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1975
(I1
(I18
I1
tg1524
I00
S'\xe8\xe7E\x01\xc0\x02\x84\x01 \xe9E\x01\xe8\xe7E\x018\xecE\x01`r\x97\x01\xe8\xe7E\x01\xc0\x02\x84\x01\xc0\x02\x84\x01\xf0\xe8E\x01\xf0\xe8E\x01\x08\x03\x84\x01\xc0\x02\x84\x01\xf0\x05\x8d\x01\xf0\x05\x8d\x01\xf0\x05\x8d\x01x\x02\x84\x018\xecE\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1976
(I1
(I18
I1
tg1528
I00
S'\x00\x000A\x00\x00\x80?\x00\x00\xe0@\x00\x00\x80A\x00\x00pA\x00\x00\xa0@\x00\x00@A\x00\x00\xc0@\x00\x00\x80@\x00\x00@@\x00\x00`A\x00\x00\x00\x00\x00\x00\x00@\x00\x00PA\x00\x00\x88A\x00\x00\x10A\x00\x00\x00A\x00\x00 A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1977
(I1
(I18
I1
tg1528
I00
S'\x8b\xf6\xe4?\xe0\x90\xdd?Q\xe1)@\xef\xad\xf1?Q\xd1\x95@\x19\x93\xd8@f\xceT@-\xda\x11Ap~\x93@\xda\xcc\xec@\xa4\xb7\xe2@q\x0f\x1dA\xe1\xecjA\x08r\xe0@_\xdb\xc0@\x12\xd3\x06AFV\x1aAO,\xf9@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1978
(dp1979
g1536
(dp1980
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1966
sg1539
(lp1981
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1982
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1983
(I1
(I18
I1
tg1524
I00
(lp1984
I11
aI1
aI12
aI9
aI8
aI5
aI7
aI2
aI16
aI15
aI17
aI0
aI6
aI13
aI10
aI4
aI3
aI14
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1985
g1
(g1554
g1517
(dp1986
g1333
g1450
sVY
I3
sg1335
I2
sg1336
g1451
sg1344
I1
sg1341
I1
sg1342
g1380
sVX
I9
sg1338
I0
sg1346
g1369
sg1348
I0
sg1350
g1361
stRp1987
ag1
(g1554
g1517
(dp1988
g1333
g1356
sVY
I2
sg1335
I2
sg1336
g1357
sg1344
I8
sg1341
I8
sg1342
g1349
sVX
I2
sg1338
I0
sg1346
g1360
sg1348
I0
sg1350
g1361
stRp1989
ag1
(g1554
g1517
(dp1990
g1333
g1415
sVY
I3
sg1335
I2
sg1336
g1416
sg1344
I4
sg1341
I4
sg1342
g1347
sVX
I6
sg1338
I0
sg1346
g1371
sg1348
I0
sg1350
g1419
stRp1991
ag1
(g1554
g1517
(dp1992
g1333
g1490
sVY
I2
sg1335
I2
sg1336
g1491
sg1344
I1
sg1341
I1
sg1342
g1369
sVX
I6
sg1338
I0
sg1346
g1380
sg1348
I0
sg1350
g1419
stRp1993
ag1
(g1554
g1517
(dp1994
g1333
g1482
sVY
I9
sg1335
I3
sg1336
g1483
sg1344
I3
sg1341
I3
sg1342
g1343
sVX
I5
sg1338
g1339
sg1346
g1347
sg1348
I0
sg1350
g1401
stRp1995
ag1
(g1554
g1517
(dp1996
g1333
g1396
sVY
I3
sg1335
I3
sg1336
g1397
sg1344
I9
sg1341
I9
sg1342
g1399
sVX
I5
sg1338
g1371
sg1346
g1360
sg1348
I0
sg1350
g1401
stRp1997
ag1
(g1554
g1517
(dp1998
g1333
g1458
sVY
I2
sg1335
I3
sg1336
g1459
sg1344
I1
sg1341
I1
sg1342
g1369
sVX
I7
sg1338
g1339
sg1346
g1380
sg1348
I0
sg1350
g1410
stRp1999
ag1
(g1554
g1517
(dp2000
g1333
g1406
sVY
I6
sg1335
I3
sg1336
g1407
sg1344
I6
sg1341
I6
sg1342
g1360
sVX
I6
sg1338
g1399
sg1346
g1380
sg1348
I0
sg1350
g1410
stRp2001
ag1
(g1554
g1517
(dp2002
g1333
g1387
sVY
I2
sg1335
I3
sg1336
g1388
sg1344
I6
sg1341
I6
sg1342
g1339
sVX
I2
sg1338
g1389
sg1346
g1349
sg1348
I0
sg1350
g1382
stRp2003
ag1
(g1554
g1517
(dp2004
g1333
g1377
sVY
I6
sg1335
I3
sg1336
g1378
sg1344
I8
sg1341
I8
sg1342
g1380
sVX
I2
sg1338
g1360
sg1346
g1349
sg1348
I0
sg1350
g1382
stRp2005
ag1
(g1554
g1517
(dp2006
g1333
g1474
sVY
I4
sg1335
I4
sg1336
g1475
sg1344
I8
sg1341
I8
sg1342
g1349
sVX
I3
sg1338
g1343
sg1346
g1347
sg1348
g1339
sg1350
g1351
stRp2007
ag1
(g1554
g1517
(dp2008
g1333
g1334
sVY
I8
sg1335
I4
sg1336
g1337
sg1344
I1
sg1341
I1
sg1342
g1343
sVX
I2
sg1338
g1339
sg1346
g1347
sg1348
g1349
sg1350
g1351
stRp2009
ag1
(g1554
g1517
(dp2010
g1333
g1366
sVY
I5
sg1335
I4
sg1336
g1367
sg1344
I6
sg1341
I6
sg1342
g1369
sVX
I4
sg1338
g1343
sg1346
g1349
sg1348
g1371
sg1350
g1372
stRp2011
ag1
(g1554
g1517
(dp2012
g1333
g1466
sVY
I3
sg1335
I4
sg1336
g1467
sg1344
I7
sg1341
I7
sg1342
g1389
sVX
I2
sg1338
g1399
sg1346
g1371
sg1348
g1343
sg1350
g1372
stRp2013
ag1
(g1554
g1517
(dp2014
g1333
g1498
sVY
I3
sg1335
I4
sg1336
g1499
sg1344
I5
sg1341
I5
sg1342
g1343
sVX
I3
sg1338
g1369
sg1346
g1339
sg1348
g1349
sg1350
g1437
stRp2015
ag1
(g1554
g1517
(dp2016
g1333
g1433
sVY
I4
sg1335
I4
sg1336
g1434
sg1344
I5
sg1341
I5
sg1342
g1339
sVX
I8
sg1338
g1360
sg1346
g1380
sg1348
g1399
sg1350
g1437
stRp2017
ag1
(g1554
g1517
(dp2018
g1333
g1424
sVY
I2
sg1335
I4
sg1336
g1425
sg1344
I5
sg1341
I5
sg1342
g1343
sVX
I6
sg1338
g1399
sg1346
g1339
sg1348
g1347
sg1350
g1428
stRp2019
ag1
(g1554
g1517
(dp2020
g1333
g1442
sVY
I2
sg1335
I4
sg1336
g1443
sg1344
I3
sg1341
I3
sg1342
g1343
sVX
I3
sg1338
g1371
sg1346
g1399
sg1348
g1347
sg1350
g1428
stRp2021
asg1567
Nsg1568
I14
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbasS'savePickle'
p2022
I00
sb.