ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cdata/_KRITL_2015_Jul_07_1215
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'KRITL'
p11
sS'dataNames'
p12
(lp13
S'practice_encoding.keys'
p14
aS'practice_encoding.rt'
p15
aS'practice_execution.keys'
p16
aS'practice_execution.corr'
p17
aS'practice_execution.rt'
p18
asS'autoLog'
p19
I01
sS'extraInfo'
p20
(dp21
S'date'
p22
V2015_Jul_07_1215
p23
sS'frameRate'
p24
cnumpy.core.multiarray
scalar
p25
(cnumpy
dtype
p26
(S'f8'
I0
I1
tRp27
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xb7\xab2\xfe]\x94v@'
tRp28
sS'expName'
p29
g11
sVsession
p30
V001
p31
sVparticipant
p32
V
ssS'loopsUnfinished'
p33
(lp34
g1
(cpsychopy.data
TrialHandler
p35
g3
NtRp36
(dp37
S'origin'
p38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p39
sS'thisTrial'
p40
g1
(cpsychopy.data
TrialType
p41
c__builtin__
dict
p42
(dp43
VRule
p44
(S'ADD'
S'DOUBLE'
S'x'
S'y'
tp45
sVY
I4
sVLength
p46
I2
sVIntermediate
p47
(I4
I8
tp48
sVCorrectResponse
p49
I8
sVResult
p50
I8
sVOperatora
p51
Vdouble
p52
sVX
I2
sVOperatorc
p53
I0
sVOperatorb
p54
VADD
p55
sVOperatord
p56
I0
sVStructure
p57
VBUxy
p58
stRp59
sS'_exp'
p60
I86910128
sg10
S'block'
p61
sg6
S'C:\\Users\\CCDL\\Desktop\\Experiments\\KRITL\\kritl.py'
p62
sS'thisRepN'
p63
I0
sg19
I01
sg20
g21
sS'data'
p64
g1
(cpsychopy.data
DataHandler
p65
g42
(dp66
S'ran'
p67
cnumpy.ma.core
_mareconstruct
p68
(cnumpy.ma.core
MaskedArray
p69
cnumpy
ndarray
p70
(I0
tp71
S'b'
tRp72
(I1
(I18
I1
tg26
(S'f4'
I0
I1
tRp73
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p74
g68
(g69
g70
g71
S'b'
tRp75
(I1
(I18
I1
tg73
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp76
(dp77
S'isNumeric'
p78
(dp79
g67
I01
sg74
I01
ssS'trials'
p80
g36
sS'dataTypes'
p81
(lp82
g67
ag74
asS'dataShape'
p83
(lp84
I18
aI1
asbsS'method'
p85
S'fullRandom'
p86
sS'sequenceIndices'
p87
cnumpy.core.multiarray
_reconstruct
p88
(g70
(I0
tS'b'
tRp89
(I1
(I18
I1
tg26
(S'O4'
I0
I1
tRp90
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp91
I0
aI10
aI6
aI7
aI14
aI5
aI1
aI4
aI11
aI3
aI16
aI15
aI9
aI17
aI2
aI12
aI8
aI13
atbsS'finished'
p92
I00
sS'nReps'
p93
I1
sS'nRemaining'
p94
I17
sS'trialList'
p95
(lp96
g59
ag1
(g41
g42
(dp97
g44
(S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp98
sVY
I6
sg46
I2
sg47
(I12
I2
tp99
sg49
I2
sg50
I2
sg51
g52
sVX
I6
sg53
I0
sg54
VDIVIDE
p100
sg56
I0
sg57
g58
stRp101
ag1
(g41
g42
(dp102
g44
(S'DOUBLE'
S'SUBTRACT'
S'x'
S'y'
tp103
sVY
I7
sg46
I2
sg47
(I1
I2
tp104
sg49
I2
sg50
I2
sg51
VSUBTRACT
p105
sVX
I8
sg53
I0
sg54
g52
sg56
I0
sg57
VUBxy
p106
stRp107
ag1
(g41
g42
(dp108
g44
(S'HALF'
S'TIMES'
S'x'
S'y'
tp109
sVY
I4
sg46
I2
sg47
(I16
I8
tp110
sg49
I8
sg50
I8
sg51
VTIMES
p111
sVX
I4
sg53
I0
sg54
Vhalf
p112
sg56
I0
sg57
g106
stRp113
ag1
(g41
g42
(dp114
g44
(S'DIVIDE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp115
sVY
I4
sg46
I3
sg47
(I2
I4
I1
tp116
sg49
I1
sg50
I1
sg51
g52
sVX
I6
sg53
Vthird
p117
sg54
g100
sg56
I0
sg57
VBUUxy
p118
stRp119
ag1
(g41
g42
(dp120
g44
(S'SUBTRACT'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp121
sVY
I4
sg46
I3
sg47
(I12
I6
I2
tp122
sg49
I2
sg50
I2
sg51
g112
sVX
I4
sg53
Vtriple
p123
sg54
g105
sg56
I0
sg57
g118
stRp124
ag1
(g41
g42
(dp125
g44
(S'HALF'
S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp126
sVY
I7
sg46
I3
sg47
(I9
I2
I1
tp127
sg49
I1
sg50
I1
sg51
g105
sVX
I3
sg53
g123
sg54
g112
sg56
I0
sg57
VUBUxy
p128
stRp129
ag1
(g41
g42
(dp130
g44
(S'INCREASE'
S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp131
sVY
I3
sg46
I3
sg47
(I3
I1
I2
tp132
sg49
I2
sg50
I2
sg51
g100
sVX
I9
sg53
g117
sg54
Vincrease
p133
sg56
I0
sg57
g128
stRp134
ag1
(g41
g42
(dp135
g44
(S'DOUBLE'
S'DECREASE'
S'SUBTRACT'
S'x'
S'y'
tp136
sVY
I2
sg46
I3
sg47
(I5
I4
I8
tp137
sg49
I8
sg50
I8
sg51
Vdecrease
p138
sVX
I7
sg53
g105
sg54
g52
sg56
I0
sg57
VUUBxy
p139
stRp140
ag1
(g41
g42
(dp141
g44
(S'DOUBLE'
S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp142
sVY
I3
sg46
I3
sg47
(I1
I3
I6
tp143
sg49
I6
sg50
I6
sg51
g123
sVX
I4
sg53
g105
sg54
g52
sg56
I0
sg57
g139
stRp144
ag1
(g41
g42
(dp145
g44
(S'ADD'
S'THIRD'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp146
sVY
I6
sg46
I4
sg47
(I2
I3
I1
I7
tp147
sg49
I7
sg50
I7
sg51
g117
sVX
I4
sg53
g133
sg54
g55
sg56
g112
sg57
VBUUUxy
p148
stRp149
ag1
(g41
g42
(dp150
g44
(S'DIVIDE'
S'INCREASE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp151
sVY
I5
sg46
I4
sg47
(I2
I4
I5
I1
tp152
sg49
I1
sg50
I1
sg51
g133
sVX
I6
sg53
g52
sg54
g100
sg56
g117
sg57
g148
stRp153
ag1
(g41
g42
(dp154
g44
(S'DECREASE'
S'ADD'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp155
sVY
I4
sg46
I4
sg47
(I3
I6
I10
I9
tp156
sg49
I9
sg50
I9
sg51
g55
sVX
I9
sg53
g52
sg54
Vdecrease 
p157
sg56
g117
sg57
VUBUUxy
p158
stRp159
ag1
(g41
g42
(dp160
g44
(S'DECREASE'
S'TIMES'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp161
sVY
I4
sg46
I4
sg47
(I1
I2
I8
I7
tp162
sg49
I7
sg50
I7
sg51
g111
sVX
I3
sg53
g52
sg54
g138
sg56
g117
sg57
g158
stRp163
ag1
(g41
g42
(dp164
g44
(S'DECREASE'
S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp165
sVY
I6
sg46
I4
sg47
(I2
I12
I4
I3
tp166
sg49
I3
sg50
I3
sg51
g117
sVX
I4
sg53
g111
sg54
g138
sg56
g112
sg57
VUUBUxy
p167
stRp168
ag1
(g41
g42
(dp169
g44
(S'DOUBLE'
S'TRIPLE'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp170
sVY
I8
sg46
I4
sg47
(I8
I1
I3
I6
tp171
sg49
I6
sg50
I6
sg51
g123
sVX
I9
sg53
g100
sg54
g52
sg56
g138
sg57
g167
stRp172
ag1
(g41
g42
(dp173
g44
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp174
sVY
I2
sg46
I4
sg47
(I4
I12
I6
I5
tp175
sg49
I5
sg50
I5
sg51
g112
sVX
I8
sg53
g123
sg54
g138
sg56
g100
sg57
VUUUBxy
p176
stRp177
ag1
(g41
g42
(dp178
g44
(S'DOUBLE'
S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp179
sVY
I4
sg46
I4
sg47
(I1
I3
I2
I4
tp180
sg49
I4
sg50
I4
sg51
g138
sVX
I4
sg53
g123
sg54
g52
sg56
g100
sg57
g176
stRp181
asS'seed'
p182
NsS'thisIndex'
p183
I0
sS'thisN'
p184
I0
sS'thisTrialN'
p185
I0
sS'nTotal'
p186
I18
sS'_warnUseOfNext'
p187
I01
sbasS'saveWideText'
p188
I01
sS'thisEntry'
p189
(dp190
sS'version'
p191
S''
sS'_paramNamesSoFar'
p192
(lp193
Voperationc
p194
aVoperationb
p195
aVoperationa
p196
aVcorrectresponse
p197
aVvaluey
p198
aVoperationd
p199
aVcondition
p200
aVvaluex
p201
asS'entries'
p202
(lp203
(dp204
g18
F0.86723289600922726
sg24
g28
sg17
I1
sg194
Vincrease
p205
sg195
VDIVIDE
p206
sg196
Vtriple
p207
sg30
g31
sg197
I3
sS'practice_trials.thisTrialN'
p208
I0
sg199
I0
sS'practice_trials.thisRepN'
p209
I0
sg32
V
sg200
I3
sg22
g23
sg16
S'3'
sg14
(lp210
S'space'
p211
asS'practice_trials.thisIndex'
p212
I4
sS'practice_trials.thisN'
p213
I0
sg29
g11
sg15
(lp214
F2.9045282720617251
asg198
I3
sg201
I2
sa(dp215
g18
F0.34392871819727588
sg24
g28
sg17
I0
sg194
g205
sg195
g206
sg196
Vdouble
p216
sg30
g31
sg197
I9
sS'practice_trials.thisTrialN'
p217
I1
sg199
g207
sS'practice_trials.thisRepN'
p218
I0
sg32
V
sg200
I4
sg22
g23
sg16
S'2'
sg14
(lp219
S'space'
p220
asS'practice_trials.thisIndex'
p221
I5
sS'practice_trials.thisN'
p222
I1
sg29
g11
sg15
(lp223
F1.7098409409081796
asg198
I8
sg201
I8
sa(dp224
g18
F0.21551116164482664
sg24
g28
sg17
I0
sg194
I0
sg195
Vdecrease
p225
sg196
VTIMES
p226
sg30
g31
sg197
I8
sS'practice_trials.thisTrialN'
p227
I2
sg199
I0
sS'practice_trials.thisRepN'
p228
I0
sg32
V
sg200
I2
sg22
g23
sg16
S'7'
sg14
(lp229
S'space'
p230
asS'practice_trials.thisIndex'
p231
I1
sS'practice_trials.thisN'
p232
I2
sg29
g11
sg15
(lp233
F0.22167396153963637
asg198
I3
sg201
I3
sa(dp234
g18
F0.34385891191777773
sg24
g28
sg17
I0
sg194
I0
sg195
VADD
p235
sg196
Vhalf
p236
sg30
g31
sg197
I7
sS'practice_trials.thisTrialN'
p237
I3
sg199
I0
sS'practice_trials.thisRepN'
p238
I0
sg32
V
sg200
I2
sg22
g23
sg16
S'6'
sg14
(lp239
S'space'
p240
asS'practice_trials.thisIndex'
p241
I2
sS'practice_trials.thisN'
p242
I3
sg29
g11
sg15
(lp243
F0.29966092623362783
asg198
I5
sg201
I4
sa(dp244
g18
F0.19840588454098906
sg24
g28
sg17
I0
sg194
I0
sg195
g235
sg196
g225
sg30
g31
sg197
I7
sS'practice_trials.thisTrialN'
p245
I4
sg199
I0
sS'practice_trials.thisRepN'
p246
I0
sg32
V
sg200
I2
sg22
g23
sg16
S'5'
sg14
(lp247
S'space'
p248
asS'practice_trials.thisIndex'
p249
I0
sS'practice_trials.thisN'
p250
I4
sg29
g11
sg15
(lp251
F0.26972703347564675
asg198
I5
sg201
I3
sa(dp252
g18
F0.071538438118295744
sg24
g28
sg17
I0
sg194
g235
sg195
Vtriple 
p253
sg196
g236
sg30
g31
sg197
I8
sS'practice_trials.thisTrialN'
p254
I5
sg199
I0
sS'practice_trials.thisRepN'
p255
I0
sg32
V
sg200
I3
sg22
g23
sg16
S'4'
sg14
(lp256
S'space'
p257
asS'practice_trials.thisIndex'
p258
I3
sS'practice_trials.thisN'
p259
I5
sg29
g11
sg15
(lp260
F0.33446038544934709
asg198
I2
sg201
I4
sasS'loops'
p261
(lp262
g1
(g35
g3
NtRp263
(dp264
g38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p265
sg40
(lp266
sg60
I86910128
sg10
S'practice_trials'
p267
sg6
g62
sg63
I1
sg19
I01
sg20
g21
sg64
g1
(g65
g42
(dp268
g15
g68
(g69
g70
g71
S'b'
tRp269
(I1
(I6
I1
tg90
I00
S'\xc0a\x12\x03\xa8`\x10\x03\xd0P\x11\x03\x08\xbf\x12\x03\x08?\xe4\x04\xc0\xf6\x19\x05'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg16
g68
(g69
g70
g71
S'b'
tRp270
(I1
(I6
I1
tg90
I00
S'\x08\x86"\x02 \x03\x19\x02\xc0\x02\x19\x02h\xcc\xd3\x01\x08\x03\x19\x02x\x02\x19\x02'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg67
g68
(g69
g70
g71
S'b'
tRp271
(I1
(I6
I1
tg73
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg18
g68
(g69
g70
g71
S'b'
tRp272
(I1
(I6
I1
tg73
I00
S'\xea*K>\xf5\xae\\>F\x0e\xb0>\xbf\x82\x92=\xfa\x02^?m\x17\xb0>'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg14
g68
(g69
g70
g71
S'b'
tRp273
(I1
(I6
I1
tg90
I00
S'\xd0\xcf\x11\x03p\xcb\x1a\x05XU\x11\x03x\xbd\x12\x03X\xb5\xa7\x04\xe0Y\x19\x05'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg74
g68
(g69
g70
g71
S'b'
tRp274
(I1
(I6
I1
tg73
I00
S'\x00\x00\x80@\x00\x00\x00@\x00\x00@@\x00\x00\xa0@\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg17
g68
(g69
g70
g71
S'b'
tRp275
(I1
(I6
I1
tg73
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00'
NtbstRp276
(dp277
g78
(dp278
g16
I00
sg67
I01
sg18
I01
sg14
I00
sg17
I01
sg74
I01
sg15
I00
ssg80
g263
sg81
(lp279
g67
ag74
ag14
ag15
ag16
ag17
ag18
asg83
(lp280
I6
aI1
asbsg85
g86
sg87
g88
(g70
(I0
tS'b'
tRp281
(I1
(I6
I1
tg90
I00
(lp282
I4
aI5
aI1
aI2
aI0
aI3
atbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp283
g1
(g41
g42
(dp284
g194
I0
sg195
g235
sg196
g225
sg197
I7
sg200
I2
sg199
I0
sg198
I5
sg201
I3
stRp285
ag1
(g41
g42
(dp286
g194
I0
sg195
g225
sg196
g226
sg197
I8
sg200
I2
sg199
I0
sg198
I3
sg201
I3
stRp287
ag1
(g41
g42
(dp288
g194
I0
sg195
g235
sg196
g236
sg197
I7
sg200
I2
sg199
I0
sg198
I5
sg201
I4
stRp289
ag1
(g41
g42
(dp290
g194
g235
sg195
g253
sg196
g236
sg197
I8
sg200
I3
sg199
I0
sg198
I2
sg201
I4
stRp291
ag1
(g41
g42
(dp292
g194
g205
sg195
g206
sg196
g207
sg197
I3
sg200
I3
sg199
I0
sg198
I3
sg201
I2
stRp293
ag1
(g41
g42
(dp294
g194
g205
sg195
g206
sg196
g216
sg197
I9
sg200
I4
sg199
g207
sg198
I8
sg201
I8
stRp295
asg182
Nsg183
I3
sg184
I6
sg185
I0
sg186
I6
sg187
I01
sbag36
asS'savePickle'
p296
I00
sb.