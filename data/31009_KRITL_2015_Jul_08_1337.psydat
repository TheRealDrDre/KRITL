ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cdata/31009_KRITL_2015_Jul_08_1337
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'KRITL'
p11
sS'dataNames'
p12
(lp13
S'practice_encoding.keys'
p14
aS'practice_encoding.rt'
p15
aS'practice_execution.keys'
p16
aS'practice_execution.corr'
p17
aS'practice_execution.rt'
p18
aS'encoding.keys'
p19
aS'encoding.rt'
p20
aS'execution.keys'
p21
aS'execution.corr'
p22
aS'execution.rt'
p23
asS'autoLog'
p24
I01
sS'extraInfo'
p25
(dp26
S'date'
p27
V2015_Jul_08_1337
p28
sS'frameRate'
p29
NsS'expName'
p30
g11
sVsession
p31
V001
p32
sVparticipant
p33
V31009
p34
ssS'loopsUnfinished'
p35
(lp36
sS'saveWideText'
p37
I01
sS'thisEntry'
p38
(dp39
sS'version'
p40
S''
sS'_paramNamesSoFar'
p41
(lp42
Voperationc
p43
aVoperationb
p44
aVoperationa
p45
aVcorrectresponse
p46
aVvaluey
p47
aVoperationd
p48
aVcondition
p49
aVvaluex
p50
aVRule
p51
aVOperatora
p52
aVLength
p53
aVIntermediate
p54
aVCorrectResponse
p55
aVResult
p56
aVY
aVX
aVOperatorc
p57
aVOperatorb
p58
aVOperatord
p59
aVStructure
p60
asS'entries'
p61
(lp62
(dp63
g18
F10.874264420519467
sg29
Nsg17
I0
sg43
I0
sg44
VADD
p64
sg45
Vhalf
p65
sg31
g32
sg46
I7
sS'practice_trials.thisTrialN'
p66
I0
sg48
I0
sS'practice_trials.thisRepN'
p67
I0
sg33
g34
sg49
I2
sg27
g28
sg16
S'9'
sg14
(lp68
S'space'
p69
asS'practice_trials.thisIndex'
p70
I2
sS'practice_trials.thisN'
p71
I0
sg30
g11
sg15
(lp72
F2.0570660951489117
asg47
I5
sg50
I4
sa(dp73
g18
F9.2627063865948003
sg29
Nsg17
I1
sg43
Vincrease
p74
sg44
VDIVIDE
p75
sg45
Vtriple
p76
sg31
g32
sg46
I3
sS'practice_trials.thisTrialN'
p77
I1
sg48
I0
sS'practice_trials.thisRepN'
p78
I0
sg33
g34
sg49
I3
sg27
g28
sg16
S'3'
sg14
(lp79
S'space'
p80
asS'practice_trials.thisIndex'
p81
I4
sS'practice_trials.thisN'
p82
I1
sg30
g11
sg15
(lp83
F9.2653059153235517
asg47
I3
sg50
I2
sa(dp84
g18
F5.9273111850779969
sg29
Nsg17
I1
sg43
g64
sg44
Vtriple 
p85
sg45
g65
sg31
g32
sg46
I8
sS'practice_trials.thisTrialN'
p86
I2
sg48
I0
sS'practice_trials.thisRepN'
p87
I0
sg33
g34
sg49
I3
sg27
g28
sg16
S'8'
sg14
(lp88
S'space'
p89
asS'practice_trials.thisIndex'
p90
I3
sS'practice_trials.thisN'
p91
I2
sg30
g11
sg15
(lp92
F8.2787529121414991
asg47
I2
sg50
I4
sa(dp93
g18
F1.9968944240681594
sg29
Nsg17
I1
sg43
I0
sg44
Vdecrease
p94
sg45
VTIMES
p95
sg31
g32
sg46
I8
sS'practice_trials.thisTrialN'
p96
I3
sg48
I0
sS'practice_trials.thisRepN'
p97
I0
sg33
g34
sg49
I2
sg27
g28
sg16
S'8'
sg14
(lp98
S'space'
p99
asS'practice_trials.thisIndex'
p100
I1
sS'practice_trials.thisN'
p101
I3
sg30
g11
sg15
(lp102
F1.7584867019177182
asg47
I3
sg50
I3
sa(dp103
g18
F3.93330710940063
sg29
Nsg17
I1
sg43
I0
sg44
g64
sg45
g94
sg31
g32
sg46
I7
sS'practice_trials.thisTrialN'
p104
I4
sg48
I0
sS'practice_trials.thisRepN'
p105
I0
sg33
g34
sg49
I2
sg27
g28
sg16
S'7'
sg14
(lp106
S'space'
p107
asS'practice_trials.thisIndex'
p108
I0
sS'practice_trials.thisN'
p109
I4
sg30
g11
sg15
(lp110
F2.8695847088383744
asg47
I5
sg50
I3
sa(dp111
g18
F5.975217686034739
sg29
Nsg17
I1
sg43
g74
sg44
g75
sg45
Vdouble
p112
sg31
g32
sg46
I9
sS'practice_trials.thisTrialN'
p113
I5
sg48
g76
sS'practice_trials.thisRepN'
p114
I0
sg33
g34
sg49
I4
sg27
g28
sg16
S'9'
sg14
(lp115
S'space'
p116
asS'practice_trials.thisIndex'
p117
I5
sS'practice_trials.thisN'
p118
I5
sg30
g11
sg15
(lp119
F11.017677355368505
asg47
I8
sg50
I8
sa(dp120
S'block.thisTrialN'
p121
I0
sS'block.thisRepN'
p122
I0
sg29
NsS'block.thisN'
p123
I0
sg51
(S'ADD'
S'THIRD'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp124
sg27
g28
sg53
I4
sg54
(I2
I3
I1
I7
tp125
sg22
I1
sg20
F4.6456182297406485
sg23
F7.3537731837568572
sVY
I6
sVX
I4
sg57
Vincrease
p126
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p127
sg30
g11
sg56
I7
sg52
Vthird
p128
sg55
I7
sS'block.thisIndex'
p129
I10
sg58
VADD
p130
sg59
Vhalf
p131
sg60
VBUUUxy
p132
sa(dp133
S'block.thisTrialN'
p134
I1
sS'block.thisRepN'
p135
I0
sg29
NsS'block.thisN'
p136
I1
sg51
(S'DOUBLE'
S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp137
sg27
g28
sg53
I4
sg54
(I1
I3
I2
I4
tp138
sg22
I1
sg20
F5.2849199686024804
sg23
F3.6241728175664321
sVY
I4
sVX
I4
sg57
Vtriple
p139
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p140
sg30
g11
sg56
I4
sg52
Vdecrease
p141
sg55
I4
sS'block.thisIndex'
p142
I17
sg58
Vdouble
p143
sg59
VDIVIDE
p144
sg60
VUUUBxy
p145
sa(dp146
S'block.thisTrialN'
p147
I2
sS'block.thisRepN'
p148
I0
sg29
NsS'block.thisN'
p149
I2
sg51
(S'DIVIDE'
S'INCREASE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp150
sg27
g28
sg53
I4
sg54
(I2
I4
I5
I1
tp151
sg22
I1
sg20
F2.1864353454730008
sg23
F8.5357783415383892
sVY
I5
sVX
I6
sg57
g143
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p152
sg30
g11
sg56
I1
sg52
g126
sg55
I1
sS'block.thisIndex'
p153
I11
sg58
g144
sg59
g128
sg60
g132
sa(dp154
S'block.thisTrialN'
p155
I3
sS'block.thisRepN'
p156
I0
sg29
NsS'block.thisN'
p157
I3
sg51
(S'DOUBLE'
S'DECREASE'
S'SUBTRACT'
S'x'
S'y'
tp158
sg27
g28
sg53
I3
sg54
(I5
I4
I8
tp159
sg22
I1
sg20
F3.3201749397412641
sg23
F5.217504403408384
sVY
I2
sVX
I7
sg57
VSUBTRACT
p160
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p161
sg30
g11
sg56
I8
sg52
g141
sg55
I8
sS'block.thisIndex'
p162
I8
sg58
g143
sg59
I0
sg60
VUUBxy
p163
sa(dp164
S'block.thisTrialN'
p165
I4
sS'block.thisRepN'
p166
I0
sg29
NsS'block.thisN'
p167
I4
sg51
(S'DOUBLE'
S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp168
sg27
g28
sg53
I3
sg54
(I1
I3
I6
tp169
sg22
I1
sg20
F6.8398402626771713
sg23
F3.4340268093073973
sVY
I3
sVX
I4
sg57
g160
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p170
sg30
g11
sg56
I6
sg52
g139
sg55
I6
sS'block.thisIndex'
p171
I9
sg58
g143
sg59
I0
sg60
g163
sa(dp172
S'block.thisTrialN'
p173
I5
sS'block.thisRepN'
p174
I0
sg29
NsS'block.thisN'
p175
I5
sg51
(S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp176
sg27
g28
sg53
I2
sg54
(I12
I2
tp177
sg22
I1
sg20
F3.1759689876489574
sg23
F2.4541647579171695
sVY
I6
sVX
I6
sg57
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p178
sg30
g11
sg56
I2
sg52
g143
sg55
I2
sS'block.thisIndex'
p179
I1
sg58
g144
sg59
I0
sg60
VBUxy
p180
sa(dp181
S'block.thisTrialN'
p182
I6
sS'block.thisRepN'
p183
I0
sg29
NsS'block.thisN'
p184
I6
sg51
(S'SUBTRACT'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp185
sg27
g28
sg53
I3
sg54
(I12
I6
I2
tp186
sg22
I0
sg20
F2.1914905679586809
sg23
F18.996493015962187
sVY
I4
sVX
I4
sg57
g139
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p187
sg30
g11
sg56
I2
sg52
g131
sg55
I2
sS'block.thisIndex'
p188
I5
sg58
g160
sg59
I0
sg60
VBUUxy
p189
sa(dp190
S'block.thisTrialN'
p191
I7
sS'block.thisRepN'
p192
I0
sg29
NsS'block.thisN'
p193
I7
sg51
(S'DECREASE'
S'ADD'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp194
sg27
g28
sg53
I4
sg54
(I3
I6
I10
I9
tp195
sg22
I1
sg20
F6.446423915665946
sg23
F7.9983586712769466
sVY
I4
sVX
I9
sg57
g143
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p196
sg30
g11
sg56
I9
sg52
g130
sg55
I9
sS'block.thisIndex'
p197
I12
sg58
Vdecrease 
p198
sg59
g128
sg60
VUBUUxy
p199
sa(dp200
S'block.thisTrialN'
p201
I8
sS'block.thisRepN'
p202
I0
sg29
NsS'block.thisN'
p203
I8
sg51
(S'DECREASE'
S'TIMES'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp204
sg27
g28
sg53
I4
sg54
(I1
I2
I8
I7
tp205
sg22
I1
sg20
F4.0808664115902502
sg23
F7.118028683718876
sVY
I4
sVX
I3
sg57
g143
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p206
sg30
g11
sg56
I7
sg52
VTIMES
p207
sg55
I7
sS'block.thisIndex'
p208
I13
sg58
g141
sg59
g128
sg60
g199
sa(dp209
S'block.thisTrialN'
p210
I9
sS'block.thisRepN'
p211
I0
sg29
NsS'block.thisN'
p212
I9
sg51
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp213
sg27
g28
sg53
I4
sg54
(I4
I12
I6
I5
tp214
sg22
I1
sg20
F9.9895749378629262
sg23
F13.121165056421887
sVY
I2
sVX
I8
sg57
g139
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p215
sg30
g11
sg56
I5
sg52
g131
sg55
I5
sS'block.thisIndex'
p216
I16
sg58
g141
sg59
g144
sg60
g145
sa(dp217
S'block.thisTrialN'
p218
I10
sS'block.thisRepN'
p219
I0
sg29
NsS'block.thisN'
p220
I10
sg51
(S'DIVIDE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp221
sg27
g28
sg53
I3
sg54
(I2
I4
I1
tp222
sg22
I1
sg20
F4.423924413495115
sg23
F5.2610402104619425
sVY
I4
sVX
I6
sg57
g128
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p223
sg30
g11
sg56
I1
sg52
g143
sg55
I1
sS'block.thisIndex'
p224
I4
sg58
g144
sg59
I0
sg60
g189
sa(dp225
S'block.thisTrialN'
p226
I11
sS'block.thisRepN'
p227
I0
sg29
NsS'block.thisN'
p228
I11
sg51
(S'ADD'
S'DOUBLE'
S'x'
S'y'
tp229
sg27
g28
sg53
I2
sg54
(I4
I8
tp230
sg22
I1
sg20
F1.166315245005535
sg23
F1.629180095056654
sVY
I4
sVX
I2
sg57
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p231
sg30
g11
sg56
I8
sg52
g143
sg55
I8
sS'block.thisIndex'
p232
I0
sg58
g130
sg59
I0
sg60
g180
sa(dp233
S'block.thisTrialN'
p234
I12
sS'block.thisRepN'
p235
I0
sg29
NsS'block.thisN'
p236
I12
sg51
(S'DOUBLE'
S'SUBTRACT'
S'x'
S'y'
tp237
sg27
g28
sg53
I2
sg54
(I1
I2
tp238
sg22
I1
sg20
F2.4188908887299476
sg23
F1.5802758482022909
sVY
I7
sVX
I8
sg57
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p239
sg30
g11
sg56
I2
sg52
g160
sg55
I2
sS'block.thisIndex'
p240
I2
sg58
g143
sg59
I0
sg60
VUBxy
p241
sa(dp242
S'block.thisTrialN'
p243
I13
sS'block.thisRepN'
p244
I0
sg29
NsS'block.thisN'
p245
I13
sg51
(S'INCREASE'
S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp246
sg27
g28
sg53
I3
sg54
(I3
I1
I2
tp247
sg22
I1
sg20
F10.294568811747013
sg23
F2.205543001589831
sVY
I3
sVX
I9
sg57
g128
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p248
sg30
g11
sg56
I2
sg52
g144
sg55
I2
sS'block.thisIndex'
p249
I7
sg58
g126
sg59
I0
sg60
VUBUxy
p250
sa(dp251
S'block.thisTrialN'
p252
I14
sS'block.thisRepN'
p253
I0
sg29
NsS'block.thisN'
p254
I14
sg51
(S'DOUBLE'
S'TRIPLE'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp255
sg27
g28
sg53
I4
sg54
(I8
I1
I3
I6
tp256
sg22
I1
sg20
F10.041637605114374
sg23
F2.8561062153166858
sVY
I8
sVX
I9
sg57
g144
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p257
sg30
g11
sg56
I6
sg52
g139
sg55
I6
sS'block.thisIndex'
p258
I15
sg58
g143
sg59
g141
sg60
VUUBUxy
p259
sa(dp260
S'block.thisTrialN'
p261
I15
sS'block.thisRepN'
p262
I0
sg29
NsS'block.thisN'
p263
I15
sg51
(S'HALF'
S'TIMES'
S'x'
S'y'
tp264
sg27
g28
sg53
I2
sg54
(I16
I8
tp265
sg22
I1
sg20
F1.5435888265055837
sg23
F2.6497215515555581
sVY
I4
sVX
I4
sg57
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p266
sg30
g11
sg56
I8
sg52
g207
sg55
I8
sS'block.thisIndex'
p267
I3
sg58
g131
sg59
I0
sg60
g241
sa(dp268
S'block.thisTrialN'
p269
I16
sS'block.thisRepN'
p270
I0
sg29
NsS'block.thisN'
p271
I16
sg51
(S'HALF'
S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp272
sg27
g28
sg53
I3
sg54
(I9
I2
I1
tp273
sg22
I1
sg20
F1.4899604226229712
sg23
F3.1003912241721991
sVY
I7
sVX
I3
sg57
g139
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p274
sg30
g11
sg56
I1
sg52
g160
sg55
I1
sS'block.thisIndex'
p275
I6
sg58
g131
sg59
I0
sg60
g250
sa(dp276
S'block.thisTrialN'
p277
I17
sS'block.thisRepN'
p278
I0
sg29
NsS'block.thisN'
p279
I17
sg51
(S'DECREASE'
S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp280
sg27
g28
sg53
I4
sg54
(I2
I12
I4
I3
tp281
sg22
I1
sg20
F7.7374122510373127
sg23
F4.8372736304881983
sVY
I6
sVX
I4
sg57
g207
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p282
sg30
g11
sg56
I3
sg52
g128
sg55
I3
sS'block.thisIndex'
p283
I14
sg58
g141
sg59
g131
sg60
g259
sa(dp284
S'block.thisTrialN'
p285
I0
sS'block.thisRepN'
p286
I0
sg29
NsS'block.thisN'
p287
I0
sVRule
p288
(S'DECREASE'
S'ADD'
S'THIRD'
S'HALF'
S'x'
S'y'
tp289
sg27
g28
sVLength
p290
I4
sVIntermediate
p291
(I3
I1
I7
I6
tp292
sg22
I0
sg20
F16.280900638026651
sg23
F7.5018140357133234
sVY
I6
sVX
I6
sVOperatorc
p293
Vthird
p294
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p295
sg30
g11
sVResult
p296
I6
sVOperatora
p297
VADD
p298
sVCorrectResponse
p299
I6
sS'block.thisIndex'
p300
I12
sVOperatorb
p301
Vdecrease
p302
sVOperatord
p303
Vhalf
p304
sVStructure
p305
VUBUUxy
p306
sa(dp307
S'block.thisTrialN'
p308
I1
sS'block.thisRepN'
p309
I0
sg29
NsS'block.thisN'
p310
I1
sg288
(S'ADD'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp311
sg27
g28
sg290
I3
sg291
(I2
I6
I8
tp312
sg22
I1
sg20
F6.781916407024255
sg23
F3.5346322111290647
sVY
I2
sVX
I4
sg293
g304
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p313
sg30
g11
sg296
I8
sg297
Vtriple
p314
sg299
I8
sS'block.thisIndex'
p315
I5
sg301
g298
sg303
I0
sg305
VBUUxy
p316
sa(dp317
S'block.thisTrialN'
p318
I2
sS'block.thisRepN'
p319
I0
sg29
NsS'block.thisN'
p320
I2
sg288
(S'THIRD'
S'HALF'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp321
sg27
g28
sg290
I4
sg291
(I5
I6
I3
I1
tp322
sg22
I1
sg20
F9.3721858124190476
sg23
F4.5481229533761507
sVY
I2
sVX
I7
sg293
Vincrease
p323
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p324
sg30
g11
sg296
I1
sg297
g304
sg299
I1
sS'block.thisIndex'
p325
I17
sg301
g294
sg303
VSUBTRACT
p326
sg305
VUUUBxy
p327
sa(dp328
S'block.thisTrialN'
p329
I3
sS'block.thisRepN'
p330
I0
sg29
NsS'block.thisN'
p331
I3
sg288
(S'INCREASE'
S'HALF'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp332
sg27
g28
sg290
I4
sg291
(I12
I4
I2
I3
tp333
sg22
I1
sg20
F13.803584395966027
sg23
F4.3816838212951552
sVY
I4
sVX
I3
sg293
g294
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p334
sg30
g11
sg296
I3
sg297
g304
sg299
I3
sS'block.thisIndex'
p335
I16
sg301
g323
sg303
VTIMES
p336
sg305
g327
sa(dp337
S'block.thisTrialN'
p338
I4
sS'block.thisRepN'
p339
I0
sg29
NsS'block.thisN'
p340
I4
sg288
(S'HALF'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp341
sg27
g28
sg290
I3
sg291
(I9
I10
I5
tp342
sg22
I1
sg20
F3.7315468630840769
sg23
F2.9855003130360274
sVY
I3
sVX
I3
sg293
g336
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p343
sg30
g11
sg296
I5
sg297
g323
sg299
I5
sS'block.thisIndex'
p344
I9
sg301
g304
sg303
I0
sg305
VUUBxy
p345
sa(dp346
S'block.thisTrialN'
p347
I5
sS'block.thisRepN'
p348
I0
sg29
NsS'block.thisN'
p349
I5
sg288
(S'DOUBLE'
S'THIRD'
S'ADD'
S'x'
S'y'
tp350
sg27
g28
sg290
I3
sg291
(I9
I3
I6
tp351
sg22
I1
sg20
F12.120266350204474
sg23
F3.5277722269674996
sVY
I4
sVX
I5
sg293
g298
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p352
sg30
g11
sg296
I6
sg297
g294
sg299
I6
sS'block.thisIndex'
p353
I8
sg301
Vdouble
p354
sg303
I0
sg305
g345
sa(dp355
S'block.thisTrialN'
p356
I6
sS'block.thisRepN'
p357
I0
sg29
NsS'block.thisN'
p358
I6
sg288
(S'HALF'
S'ADD'
S'x'
S'y'
tp359
sg27
g28
sg290
I2
sg291
(I12
I6
tp360
sg22
I1
sg20
F0.74200307196588255
sg23
F1.5994667956401827
sVY
I8
sVX
I4
sg293
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p361
sg30
g11
sg296
I6
sg297
g298
sg299
I6
sS'block.thisIndex'
p362
I3
sg301
g304
sg303
I0
sg305
VUBxy
p363
sa(dp364
S'block.thisTrialN'
p365
I7
sS'block.thisRepN'
p366
I0
sg29
NsS'block.thisN'
p367
I7
sg288
(S'ADD'
S'DECREASE'
S'x'
S'y'
tp368
sg27
g28
sg290
I2
sg291
(I2
I7
tp369
sg22
I1
sg20
F1.1544668813730823
sg23
F3.2268011832929915
sVY
I5
sVX
I3
sg293
I0
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p370
sg30
g11
sg296
I7
sg297
g302
sg299
I7
sS'block.thisIndex'
p371
I0
sg301
g298
sg303
I0
sg305
VBUxy
p372
sa(dp373
S'block.thisTrialN'
p374
I8
sS'block.thisRepN'
p375
I0
sg29
NsS'block.thisN'
p376
I8
sg288
(S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp377
sg27
g28
sg290
I3
sg291
(I4
I1
I2
tp378
sg22
I1
sg20
F1.1141850347921718
sg23
F2.5102292575902538
sVY
I3
sVX
I3
sg293
g323
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p379
sg30
g11
sg296
I2
sg297
g326
sg299
I2
sS'block.thisIndex'
p380
I6
sg301
g354
sg303
I0
sg305
VUBUxy
p381
sa(dp382
S'block.thisTrialN'
p383
I9
sS'block.thisRepN'
p384
I0
sg29
NsS'block.thisN'
p385
I9
sg288
(S'ADD'
S'TRIPLE'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp386
sg27
g28
sg290
I4
sg291
(I1
I2
I6
I8
tp387
sg22
I1
sg20
F2.9735305120993871
sg23
F5.3535135108686518
sVY
I2
sVX
I2
sg293
g354
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p388
sg30
g11
sg296
I8
sg297
g314
sg299
I8
sS'block.thisIndex'
p389
I11
sg301
g298
sg303
g302
sg305
VBUUUxy
p390
sa(dp391
S'block.thisTrialN'
p392
I10
sS'block.thisRepN'
p393
I0
sg29
NsS'block.thisN'
p394
I10
sg288
(S'DECREASE'
S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp395
sg27
g28
sg290
I4
sg291
(I1
I3
I6
I5
tp396
sg22
I1
sg20
F9.492801076194155
sg23
F4.2939294284587959
sVY
I3
sVX
I3
sg293
g336
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p397
sg30
g11
sg296
I5
sg297
g354
sg299
I5
sS'block.thisIndex'
p398
I14
sg301
g302
sg303
g294
sg305
VUUBUxy
p399
sa(dp400
S'block.thisTrialN'
p401
I11
sS'block.thisRepN'
p402
I0
sg29
NsS'block.thisN'
p403
I11
sg288
(S'INCREASE'
S'ADD'
S'HALF'
S'x'
S'y'
tp404
sg27
g28
sg290
I3
sg291
(I1
I4
I5
tp405
sg22
I1
sg20
F7.1739447988657048
sg23
F3.0288142432254972
sVY
I3
sVX
I2
sg293
g304
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p406
sg30
g11
sg296
I5
sg297
g298
sg299
I5
sS'block.thisIndex'
p407
I7
sg301
g323
sg303
I0
sg305
g381
sa(dp408
S'block.thisTrialN'
p409
I12
sS'block.thisRepN'
p410
I0
sg29
NsS'block.thisN'
p411
I12
sg288
(S'DECREASE'
S'SUBTRACT'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp412
sg27
g28
sg290
I4
sg291
(I3
I6
I4
I3
tp413
sg22
I1
sg20
F5.3254635878838599
sg23
F5.669087130765547
sVY
I2
sVX
I9
sg293
g354
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p414
sg30
g11
sg296
I3
sg297
g326
sg299
I3
sS'block.thisIndex'
p415
I13
sg301
g302
sg303
g294
sg305
g306
sa(dp416
S'block.thisTrialN'
p417
I13
sS'block.thisRepN'
p418
I0
sg29
NsS'block.thisN'
p419
I13
sg288
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp420
sg27
g28
sg290
I3
sg291
(I1
I2
I7
tp421
sg22
I1
sg20
F2.2681231213500723
sg23
F1.891633808016195
sVY
I5
sVX
I2
sg293
g302
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p422
sg30
g11
sg296
I7
sg297
g354
sg299
I7
sS'block.thisIndex'
p423
I4
sg301
g298
sg303
I0
sg305
g316
sa(dp424
S'block.thisTrialN'
p425
I14
sS'block.thisRepN'
p426
I0
sg29
NsS'block.thisN'
p427
I14
sg288
(S'DECREASE'
S'TIMES'
S'x'
S'y'
tp428
sg27
g28
sg290
I2
sg291
(I9
I8
tp429
sg22
I1
sg20
F4.3016671210352797
sg23
F1.0380424302711617
sVY
I3
sVX
I3
sg293
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p430
sg30
g11
sg296
I8
sg297
g336
sg299
I8
sS'block.thisIndex'
p431
I2
sg301
g302
sg303
I0
sg305
g363
sa(dp432
S'block.thisTrialN'
p433
I15
sS'block.thisRepN'
p434
I0
sg29
NsS'block.thisN'
p435
I15
sg288
(S'ADD'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp436
sg27
g28
sg290
I4
sg291
(I18
I6
I5
I9
tp437
sg22
I1
sg20
F1.3536083509679884
sg23
F6.5364163249469129
sVY
I4
sVX
I9
sg293
g294
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p438
sg30
g11
sg296
I9
sg297
g302
sg299
I9
sS'block.thisIndex'
p439
I10
sg301
g298
sg303
g354
sg305
g390
sa(dp440
S'block.thisTrialN'
p441
I16
sS'block.thisRepN'
p442
I0
sg29
NsS'block.thisN'
p443
I16
sg288
(S'DECREASE'
S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'x'
S'y'
tp444
sg27
g28
sg290
I4
sg291
(I6
I3
I9
I8
tp445
sg22
I1
sg20
F5.9400894016580423
sg23
F10.068138239774271
sVY
I3
sVX
I3
sg293
g326
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p446
sg30
g11
sg296
I8
sg297
g314
sg299
I8
sS'block.thisIndex'
p447
I15
sg301
g302
sg303
g354
sg305
g399
sa(dp448
S'block.thisTrialN'
p449
I17
sS'block.thisRepN'
p450
I0
sg29
NsS'block.thisN'
p451
I17
sg288
(S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp452
sg27
g28
sg290
I2
sg291
(I8
I2
tp453
sg22
I1
sg20
F3.7658922791451914
sg23
F1.3493702932173619
sVY
I4
sVX
I9
sg293
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p454
sg30
g11
sg296
I2
sg297
g302
sg299
I2
sS'block.thisIndex'
p455
I1
sg301
VDIVIDE
p456
sg303
I0
sg305
g372
sa(dp457
S'block.thisTrialN'
p458
I0
sS'block.thisRepN'
p459
I0
sg29
NsS'block.thisN'
p460
I0
sVRule
p461
(S'THIRD'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp462
sg27
g28
sVLength
p463
I4
sVIntermediate
p464
(I18
I2
I3
I1
tp465
sg22
I0
sg20
F18.774932535801781
sg23
F4.3203600704291603
sVY
I9
sVX
I9
sVOperatorc
p466
VDIVIDE
p467
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p468
sg30
g11
sVResult
p469
I1
sVOperatora
p470
Vincrese
p471
sVCorrectResponse
p472
I1
sS'block.thisIndex'
p473
I15
sVOperatorb
p474
Vthird
p475
sVOperatord
p476
Vdouble
p477
sVStructure
p478
VUUBUxy
p479
sa(dp480
S'block.thisTrialN'
p481
I1
sS'block.thisRepN'
p482
I0
sg29
NsS'block.thisN'
p483
I1
sg461
(S'INCREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp484
sg27
g28
sg463
I3
sg464
(I2
I6
I7
tp485
sg22
I1
sg20
F10.945503336726688
sg23
F2.2322084690531483
sVY
I3
sVX
I6
sg466
g467
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p486
sg30
g11
sg469
I7
sg470
Vtriple
p487
sg472
I7
sS'block.thisIndex'
p488
I8
sg474
Vincrease
p489
sg476
I0
sg478
VUUBxy
p490
sa(dp491
S'block.thisTrialN'
p492
I2
sS'block.thisRepN'
p493
I0
sg29
NsS'block.thisN'
p494
I2
sg461
(S'DIVIDE'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp495
sg27
g28
sg463
I3
sg464
(I9
I8
I4
tp496
sg22
I1
sg20
F4.6903827585629188
sg23
F7.3758138838165905
sVY
I2
sVX
I3
sg466
g487
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p497
sg30
g11
sg469
I4
sg470
Vdecrease
p498
sg472
I4
sS'block.thisIndex'
p499
I5
sg474
g467
sg476
I0
sg478
VBUUxy
p500
sa(dp501
S'block.thisTrialN'
p502
I3
sS'block.thisRepN'
p503
I0
sg29
NsS'block.thisN'
p504
I3
sg461
(S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp505
sg27
g28
sg463
I3
sg464
(I4
I2
I3
tp506
sg22
I1
sg20
F2.0134193496924127
sg23
F3.7034041997685563
sVY
I2
sVX
I8
sg466
Vhalf
p507
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p508
sg30
g11
sg469
I3
sg470
VSUBTRACT
p509
sg472
I3
sS'block.thisIndex'
p510
I7
sg474
g489
sg476
I0
sg478
VUBUxy
p511
sa(dp512
S'block.thisTrialN'
p513
I4
sS'block.thisRepN'
p514
I0
sg29
NsS'block.thisN'
p515
I4
sg461
(S'DECREASE'
S'DIVIDE'
S'x'
S'y'
tp516
sg27
g28
sg463
I2
sg464
(I2
I1
tp517
sg22
I1
sg20
F1.0422087455081055
sg23
F4.76008883472241
sVY
I4
sVX
I8
sg466
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p518
sg30
g11
sg469
I1
sg470
g467
sg472
I1
sS'block.thisIndex'
p519
I2
sg474
g498
sg476
I0
sg478
VUBxy
p520
sa(dp521
S'block.thisTrialN'
p522
I5
sS'block.thisRepN'
p523
I0
sg29
NsS'block.thisN'
p524
I5
sg461
(S'THIRD'
S'HALF'
S'ADD'
S'x'
S'y'
tp525
sg27
g28
sg463
I3
sg464
(I6
I3
I1
tp526
sg22
I1
sg20
F1.2826893013698282
sg23
F2.8932796862645773
sVY
I3
sVX
I3
sg466
VADD
p527
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p528
sg30
g11
sg469
I1
sg470
g507
sg472
I1
sS'block.thisIndex'
p529
I9
sg474
g475
sg476
I0
sg478
g490
sa(dp530
S'block.thisTrialN'
p531
I6
sS'block.thisRepN'
p532
I0
sg29
NsS'block.thisN'
p533
I6
sg461
(S'THIRD'
S'DOUBLE'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp534
sg27
g28
sg463
I4
sg464
(I5
I12
I24
I8
tp535
sg22
I0
sg20
F1.9845743096666411
sg23
F3.871458763271221
sVY
I7
sVX
I6
sg466
g527
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p536
sg30
g11
sg469
I8
sg470
g477
sg472
I8
sS'block.thisIndex'
p537
I14
sg474
g475
sg476
g498
sg478
g479
sa(dp538
S'block.thisTrialN'
p539
I7
sS'block.thisRepN'
p540
I0
sg29
NsS'block.thisN'
p541
I7
sg461
(S'INCREASE'
S'ADD'
S'x'
S'y'
tp542
sg27
g28
sg463
I2
sg464
(I5
I6
tp543
sg22
I1
sg20
F11.1355797022552
sg23
F5.4858007566799643
sVY
I2
sVX
I3
sg466
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p544
sg30
g11
sg469
I6
sg470
g527
sg472
I6
sS'block.thisIndex'
p545
I3
sg474
g489
sg476
I0
sg478
g520
sa(dp546
S'block.thisTrialN'
p547
I8
sS'block.thisRepN'
p548
I0
sg29
NsS'block.thisN'
p549
I8
sg461
(S'DOUBLE'
S'ADD'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp550
sg27
g28
sg463
I4
sg464
(I1
I2
I4
I8
tp551
sg22
I1
sg20
F2.706771548386314
sg23
F4.6237892575882142
sVY
I2
sVX
I3
sg466
g489
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p552
sg30
g11
sg469
I8
sg470
g527
sg472
I8
sS'block.thisIndex'
p553
I12
sg474
g477
sg476
g475
sg478
VUBUUxy
p554
sa(dp555
S'block.thisTrialN'
p556
I9
sS'block.thisRepN'
p557
I0
sg29
NsS'block.thisN'
p558
I9
sg461
(S'HALF'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp559
sg27
g28
sg463
I3
sg464
(I9
I12
I6
tp560
sg22
I1
sg20
F1.0690001998300431
sg23
F5.7930536448548082
sVY
I3
sVX
I3
sg466
g487
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p561
sg30
g11
sg469
I6
sg470
g527
sg472
I6
sS'block.thisIndex'
p562
I6
sg474
g507
sg476
I0
sg478
g511
sa(dp563
S'block.thisTrialN'
p564
I10
sS'block.thisRepN'
p565
I0
sg29
NsS'block.thisN'
p566
I10
sg461
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp567
sg27
g28
sg463
I4
sg464
(I3
I4
I12
I6
tp568
sg22
I1
sg20
F13.782307316243532
sg23
F4.9494677230541129
sVY
I3
sVX
I9
sg466
g489
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p569
sg30
g11
sg469
I6
sg470
g487
sg472
I6
sS'block.thisIndex'
p570
I16
sg474
g507
sg476
g467
sg478
VUUUBxy
p571
sa(dp572
S'block.thisTrialN'
p573
I11
sS'block.thisRepN'
p574
I0
sg29
NsS'block.thisN'
p575
I11
sg461
(S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp576
sg27
g28
sg463
I2
sg464
(I5
I3
tp577
sg22
I1
sg20
F7.8902930979093071
sg23
F1.8439929293381283
sVY
I2
sVX
I6
sg466
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p578
sg30
g11
sg469
I3
sg470
g498
sg472
I3
sS'block.thisIndex'
p579
I1
sg474
g509
sg476
I0
sg478
VBUxy
p580
sa(dp581
S'block.thisTrialN'
p582
I12
sS'block.thisRepN'
p583
I0
sg29
NsS'block.thisN'
p584
I12
sg461
(S'DIVIDE'
S'INCREASE'
S'x'
S'y'
tp585
sg27
g28
sg463
I2
sg464
(I4
I2
tp586
sg22
I1
sg20
F1.0684367586218286
sg23
F1.8381222919269931
sVY
I2
sVX
I3
sg466
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p587
sg30
g11
sg469
I2
sg470
g489
sg472
I2
sS'block.thisIndex'
p588
I0
sg474
g467
sg476
I0
sg478
g580
sa(dp589
S'block.thisTrialN'
p590
I13
sS'block.thisRepN'
p591
I0
sg29
NsS'block.thisN'
p592
I13
sg461
(S'ADD'
S'HALF'
S'THIRD'
S'x'
S'y'
tp593
sg27
g28
sg463
I3
sg464
(I2
I1
I9
tp594
sg22
I1
sg20
F0.88419673407042865
sg23
F7.1402156684926013
sVY
I8
sVX
I6
sg466
g475
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p595
sg30
g11
sg469
I9
sg470
g507
sg472
I9
sS'block.thisIndex'
p596
I4
sg474
g527
sg476
I0
sg478
g500
sa(dp597
S'block.thisTrialN'
p598
I14
sS'block.thisRepN'
p599
I0
sg29
NsS'block.thisN'
p600
I14
sg461
(S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp601
sg27
g28
sg463
I4
sg464
(I6
I18
I17
I8
tp602
sg22
I0
sg20
F2.3395643164549256
sg23
F19.604827186281909
sVY
I9
sVX
I3
sg466
g487
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p603
sg30
g11
sg469
I8
sg470
g498
sg472
I8
sS'block.thisIndex'
p604
I11
sg474
g509
sg476
g477
sg478
VBUUUxy
p605
sa(dp606
S'block.thisTrialN'
p607
I15
sS'block.thisRepN'
p608
I0
sg29
NsS'block.thisN'
p609
I15
sg461
(S'THIRD'
S'TIMES'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp610
sg27
g28
sg463
I4
sg464
(I1
I2
I6
I2
tp611
sg22
I1
sg20
F7.6618939813633915
sg23
F10.421055762839387
sVY
I3
sVX
I2
sg466
g477
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p612
sg30
g11
sg469
I2
sg470
VTIMES
p613
sg472
I2
sS'block.thisIndex'
p614
I13
sg474
g475
sg476
g498
sg478
g554
sa(dp615
S'block.thisTrialN'
p616
I16
sS'block.thisRepN'
p617
I0
sg29
NsS'block.thisN'
p618
I16
sg461
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'THIRD'
S'x'
S'y'
tp619
sg27
g28
sg463
I4
sg464
(I2
I1
I2
I8
tp620
sg22
I0
sg20
F13.533220458455617
sg23
F1.69216232286999
sVY
I6
sVX
I6
sg466
g498
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p621
sg30
g11
sg469
I8
sg470
g477
sg472
I8
sS'block.thisIndex'
p622
I10
sg474
g527
sg476
g475
sg478
g605
sa(dp623
S'block.thisTrialN'
p624
I17
sS'block.thisRepN'
p625
I0
sg29
NsS'block.thisN'
p626
I17
sg461
(S'THIRD'
S'DOUBLE'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp627
sg27
g28
sg463
I4
sg464
(I8
I9
I18
I6
tp628
sg22
I1
sg20
F6.6649841589096468
sg23
F6.338270501466468
sVY
I4
sVX
I2
sg466
g489
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p629
sg30
g11
sg469
I6
sg470
g477
sg472
I6
sS'block.thisIndex'
p630
I17
sg474
g475
sg476
g613
sg478
g571
sa(dp631
S'block.thisTrialN'
p632
I0
sS'block.thisRepN'
p633
I0
sg29
NsS'block.thisN'
p634
I0
sVRule
p635
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'x'
S'y'
tp636
sg27
g28
sVLength
p637
I3
sVIntermediate
p638
(I6
I2
I3
tp639
sg22
I1
sg20
F7.0104005647008307
sg23
F3.8670845697197365
sVY
I3
sVX
I2
sVOperatorc
p640
Vtriple
p641
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p642
sg30
g11
sVResult
p643
I3
sVOperatora
p644
VDIVIDE
p645
sVCorrectResponse
p646
I3
sS'block.thisIndex'
p647
I7
sVOperatorb
p648
Vincrease
p649
sVOperatord
p650
I0
sVStructure
p651
VUBUxy
p652
sa(dp653
S'block.thisTrialN'
p654
I1
sS'block.thisRepN'
p655
I0
sg29
NsS'block.thisN'
p656
I1
sg635
(S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp657
sg27
g28
sg637
I2
sg638
(I4
I5
tp658
sg22
I1
sg20
F3.7475328449509107
sg23
F3.3848005960608134
sVY
I2
sVX
I8
sg640
I0
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p659
sg30
g11
sg643
I5
sg644
g645
sg646
I5
sS'block.thisIndex'
p660
I3
sg648
g649
sg650
I0
sg651
VUBxy
p661
sa(dp662
S'block.thisTrialN'
p663
I2
sS'block.thisRepN'
p664
I0
sg29
NsS'block.thisN'
p665
I2
sg635
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp666
sg27
g28
sg637
I4
sg638
(I5
I1
I2
I6
tp667
sg22
I1
sg20
F5.6603891383856535
sg23
F4.0687461263441946
sVY
I4
sVX
I4
sg640
VSUBTRACT
p668
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p669
sg30
g11
sg643
I6
sg644
Vdouble
p670
sg646
I6
sS'block.thisIndex'
p671
I14
sg648
g641
sg650
g649
sg651
VUUBUxy
p672
sa(dp673
S'block.thisTrialN'
p674
I3
sS'block.thisRepN'
p675
I0
sg29
NsS'block.thisN'
p676
I3
sg635
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp677
sg27
g28
sg637
I4
sg638
(I9
I10
I20
I5
tp678
sg22
I1
sg20
F4.0676377919880906
sg23
F3.9867094368673861
sVY
I4
sVX
I3
sg640
g649
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p679
sg30
g11
sg643
I5
sg644
g670
sg646
I5
sS'block.thisIndex'
p680
I10
sg648
g645
sg650
g641
sg651
VBUUUxy
p681
sa(dp682
S'block.thisTrialN'
p683
I4
sS'block.thisRepN'
p684
I0
sg29
NsS'block.thisN'
p685
I4
sg635
(S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp686
sg27
g28
sg637
I2
sg638
(I12
I9
tp687
sg22
I1
sg20
F1.0371696213551331
sg23
F2.3527470908447867
sVY
I3
sVX
I4
sg640
I0
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p688
sg30
g11
sg643
I9
sg644
g641
sg646
I9
sS'block.thisIndex'
p689
I1
sg648
g668
sg650
I0
sg651
VBUxy
p690
sa(dp691
S'block.thisTrialN'
p692
I5
sS'block.thisRepN'
p693
I0
sg29
NsS'block.thisN'
p694
I5
sg635
(S'THIRD'
S'INCREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp695
sg27
g28
sg637
I4
sg638
(I28
I14
I15
I5
tp696
sg22
I1
sg20
F1.5935447136143921
sg23
F8.652297282780637
sVY
I4
sVX
I7
sg640
Vhalf
p697
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p698
sg30
g11
sg643
I5
sg644
g649
sg646
I5
sS'block.thisIndex'
p699
I17
sg648
Vthird
p700
sg650
VTIMES
p701
sg651
VUUUBxy
p702
sa(dp703
S'block.thisTrialN'
p704
I6
sS'block.thisRepN'
p705
I0
sg29
NsS'block.thisN'
p706
I6
sg635
(S'HALF'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp707
sg27
g28
sg637
I3
sg638
(I8
I16
I8
tp708
sg22
I1
sg20
F3.3883863218798069
sg23
F3.1444330784142949
sVY
I2
sVX
I9
sg640
Vdecrease
p709
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p710
sg30
g11
sg643
I8
sg644
g701
sg646
I8
sS'block.thisIndex'
p711
I6
sg648
g697
sg650
I0
sg651
g652
sa(dp712
S'block.thisTrialN'
p713
I7
sS'block.thisRepN'
p714
I0
sg29
NsS'block.thisN'
p715
I7
sg635
(S'HALF'
S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp716
sg27
g28
sg637
I4
sg638
(I15
I14
I10
I5
tp717
sg22
I1
sg20
F4.1469951610488351
sg23
F6.3368272520747269
sVY
I4
sVX
I5
sg640
g709
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p718
sg30
g11
sg643
I5
sg644
g668
sg646
I5
sS'block.thisIndex'
p719
I12
sg648
g697
sg650
g641
sg651
VUBUUxy
p720
sa(dp721
S'block.thisTrialN'
p722
I8
sS'block.thisRepN'
p723
I0
sg29
NsS'block.thisN'
p724
I8
sg635
(S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp725
sg27
g28
sg637
I3
sg638
(I4
I5
I3
tp726
sg22
I1
sg20
F3.1739024532726035
sg23
F2.0991691516974242
sVY
I2
sVX
I8
sg640
g697
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p727
sg30
g11
sg643
I3
sg644
g649
sg646
I3
sS'block.thisIndex'
p728
I5
sg648
g668
sg650
I0
sg651
VBUUxy
p729
sa(dp730
S'block.thisTrialN'
p731
I9
sS'block.thisRepN'
p732
I0
sg29
NsS'block.thisN'
p733
I9
sg635
(S'ADD'
S'HALF'
S'x'
S'y'
tp734
sg27
g28
sg637
I2
sg638
(I2
I7
tp735
sg22
I1
sg20
F1.1519478442351101
sg23
F3.1700108593649929
sVY
I5
sVX
I4
sg640
I0
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p736
sg30
g11
sg643
I7
sg644
g697
sg646
I7
sS'block.thisIndex'
p737
I0
sg648
VADD
p738
sg650
I0
sg651
g690
sa(dp739
S'block.thisTrialN'
p740
I10
sS'block.thisRepN'
p741
I0
sg29
NsS'block.thisN'
p742
I10
sg635
(S'DOUBLE'
S'DIVIDE'
S'x'
S'y'
tp743
sg27
g28
sg637
I2
sg638
(I1
I2
tp744
sg22
I1
sg20
F0.74180534260813147
sg23
F2.7323552787274821
sVY
I8
sVX
I8
sg640
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p745
sg30
g11
sg643
I2
sg644
g645
sg646
I2
sS'block.thisIndex'
p746
I2
sg648
Vdpuble
p747
sg650
I0
sg651
g661
sa(dp748
S'block.thisTrialN'
p749
I11
sS'block.thisRepN'
p750
I0
sg29
NsS'block.thisN'
p751
I11
sg635
(S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp752
sg27
g28
sg637
I4
sg638
(I16
I2
I3
I9
tp753
sg22
I0
sg20
F5.9392851855955087
sg23
F10.974308830875088
sVY
I8
sVX
I8
sg640
g645
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p754
sg30
g11
sg643
I9
sg644
g649
sg646
I9
sS'block.thisIndex'
p755
I15
sg648
g641
sg650
g670
sg651
g672
sa(dp756
S'block.thisTrialN'
p757
I12
sS'block.thisRepN'
p758
I0
sg29
NsS'block.thisN'
p759
I12
sg635
(S'DECREASE'
S'THIRD'
S'DOUBLE'
S'ADD'
S'x'
S'y'
tp760
sg27
g28
sg637
I4
sg638
(I9
I18
I6
I5
tp761
sg22
I1
sg20
F3.3695292396296281
sg23
F14.868912428981275
sVY
I4
sVX
I5
sg640
g670
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p762
sg30
g11
sg643
I5
sg644
g700
sg646
I5
sS'block.thisIndex'
p763
I16
sg648
g709
sg650
g738
sg651
g702
sa(dp764
S'block.thisTrialN'
p765
I13
sS'block.thisRepN'
p766
I0
sg29
NsS'block.thisN'
p767
I13
sg635
(S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp768
sg27
g28
sg637
I3
sg638
(I1
I2
I6
tp769
sg22
I1
sg20
F6.5624875544308452
sg23
F5.5529013547347859
sVY
I2
sVX
I3
sg640
g668
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p770
sg30
g11
sg643
I6
sg644
g649
sg646
I6
sS'block.thisIndex'
p771
I9
sg648
g641
sg650
I0
sg651
VUUBxy
p772
sa(dp773
S'block.thisTrialN'
p774
I14
sS'block.thisRepN'
p775
I0
sg29
NsS'block.thisN'
p776
I14
sg635
(S'TIMES'
S'HALF'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp777
sg27
g28
sg637
I4
sg638
(I1
I2
I1
I9
tp778
sg22
I1
sg20
F2.5606023011496291
sg23
F9.1892721494514262
sVY
I9
sVX
I3
sg640
g649
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p779
sg30
g11
sg643
I9
sg644
g697
sg646
I9
sS'block.thisIndex'
p780
I11
sg648
g701
sg650
g700
sg651
g681
sa(dp781
S'block.thisTrialN'
p782
I15
sS'block.thisRepN'
p783
I0
sg29
NsS'block.thisN'
p784
I15
sg635
(S'DIVIDE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp785
sg27
g28
sg637
I3
sg638
(I6
I18
I9
tp786
sg22
I1
sg20
F2.138655881251907
sg23
F4.7467961718211882
sVY
I2
sVX
I7
sg640
g709
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p787
sg30
g11
sg643
I9
sg644
g641
sg646
I9
sS'block.thisIndex'
p788
I4
sg648
g645
sg650
I0
sg651
g729
sa(dp789
S'block.thisTrialN'
p790
I16
sS'block.thisRepN'
p791
I0
sg29
NsS'block.thisN'
p792
I16
sg635
(S'INCREASE'
S'TIMES'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp793
sg27
g28
sg637
I4
sg638
(I1
I3
I6
I7
tp794
sg22
I1
sg20
F5.0438486743951216
sg23
F3.0610833259561332
sVY
I2
sVX
I2
sg640
g641
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p795
sg30
g11
sg643
I7
sg644
g701
sg646
I7
sS'block.thisIndex'
p796
I13
sg648
g649
sg650
g697
sg651
g720
sa(dp797
S'block.thisTrialN'
p798
I17
sS'block.thisRepN'
p799
I0
sg29
NsS'block.thisN'
p800
I17
sg635
(S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp801
sg27
g28
sg637
I3
sg638
(I6
I3
I9
tp802
sg22
I1
sg20
F1.6504967206710717
sg23
F5.4477047820109874
sVY
I3
sVX
I3
sg640
g738
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p803
sg30
g11
sg643
I9
sg644
g697
sg646
I9
sS'block.thisIndex'
p804
I8
sg648
g641
sg650
I0
sg651
g772
sa(dp805
S'block.thisTrialN'
p806
I0
sS'block.thisRepN'
p807
I0
sg29
NsS'block.thisN'
p808
I0
sVRule
p809
(S'ADD'
S'THIRD'
S'x'
S'y'
tp810
sg27
g28
sVLength
p811
I2
sVIntermediate
p812
(I1
I7
tp813
sg22
I0
sg20
F2.654664785717614
sg23
F4.9609986697905697
sVY
I6
sVX
I3
sVOperatorc
p814
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p815
sg30
g11
sVResult
p816
I7
sVOperatora
p817
Vthird
p818
sVCorrectResponse
p819
I7
sS'block.thisIndex'
p820
I0
sVOperatorb
p821
VADD
p822
sVOperatord
p823
I0
sVStructure
p824
VBUxy
p825
sa(dp826
S'block.thisTrialN'
p827
I1
sS'block.thisRepN'
p828
I0
sg29
NsS'block.thisN'
p829
I1
sg809
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp830
sg27
g28
sg811
I4
sg812
(I2
I3
I6
I2
tp831
sg22
I1
sg20
F2.9943897354387445
sg23
F8.2326259754772764
sVY
I3
sVX
I6
sg814
Vincrease
p832
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p833
sg30
g11
sg816
I2
sg817
Vdouble
p834
sg819
I2
sS'block.thisIndex'
p835
I10
sg821
VDIVIDE
p836
sg823
g818
sg824
VBUUUxy
p837
sa(dp838
S'block.thisTrialN'
p839
I2
sS'block.thisRepN'
p840
I0
sg29
NsS'block.thisN'
p841
I2
sg809
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp842
sg27
g28
sg811
I4
sg812
(I2
I6
I2
I3
tp843
sg22
I1
sg20
F2.1248557712970069
sg23
F4.4477163308038143
sVY
I3
sVX
I4
sg814
Vtriple
p844
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p845
sg30
g11
sg816
I3
sg817
g836
sg819
I3
sS'block.thisIndex'
p846
I12
sg821
g832
sg823
Vhalf
p847
sg824
VUBUUxy
p848
sa(dp849
S'block.thisTrialN'
p850
I3
sS'block.thisRepN'
p851
I0
sg29
NsS'block.thisN'
p852
I3
sg809
(S'TIMES'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp853
sg27
g28
sg811
I3
sg812
(I6
I2
I4
tp854
sg22
I1
sg20
F2.8989301966212224
sg23
F7.0851205676590325
sVY
I2
sVX
I3
sg814
g834
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p855
sg30
g11
sg816
I4
sg817
g818
sg819
I4
sS'block.thisIndex'
p856
I5
sg821
VTIMES
p857
sg823
I0
sg824
VBUUxy
p858
sa(dp859
S'block.thisTrialN'
p860
I4
sS'block.thisRepN'
p861
I0
sg29
NsS'block.thisN'
p862
I4
sg809
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp863
sg27
g28
sg811
I4
sg812
(I6
I3
I9
I8
tp864
sg22
I1
sg20
F2.1262097800208721
sg23
F5.6830954689794453
sVY
I2
sVX
I4
sg814
g847
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p865
sg30
g11
sg816
I8
sg817
g844
sg819
I8
sS'block.thisIndex'
p866
I16
sg821
Vdecrease
p867
sg823
g822
sg824
VUUUBxy
p868
sa(dp869
S'block.thisTrialN'
p870
I5
sS'block.thisRepN'
p871
I0
sg29
NsS'block.thisN'
p872
I5
sg809
(S'THIRD'
S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp873
sg27
g28
sg811
I4
sg812
(I8
I4
I12
I4
tp874
sg22
I1
sg20
F3.3574271524848882
sg23
F7.4780900113109965
sVY
I3
sVX
I7
sg814
g847
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p875
sg30
g11
sg816
I4
sg817
g857
sg819
I4
sS'block.thisIndex'
p876
I13
sg821
g818
sg823
g832
sg824
g848
sa(dp877
S'block.thisTrialN'
p878
I6
sS'block.thisRepN'
p879
I0
sg29
NsS'block.thisN'
p880
I6
sg809
(S'INCREASE'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp881
sg27
g28
sg811
I3
sg812
(I6
I8
I9
tp882
sg22
I1
sg20
F2.3239632944314508
sg23
F2.6874276669259416
sVY
I2
sVX
I2
sg814
g844
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p883
sg30
g11
sg816
I9
sg817
g822
sg819
I9
sS'block.thisIndex'
p884
I6
sg821
g832
sg823
I0
sg824
VUBUxy
p885
sa(dp886
S'block.thisTrialN'
p887
I7
sS'block.thisRepN'
p888
I0
sg29
NsS'block.thisN'
p889
I7
sg809
(S'INCREASE'
S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp890
sg27
g28
sg811
I3
sg812
(I3
I1
I2
tp891
sg22
I1
sg20
F0.072165619523730129
sg23
F14.875186574281543
sVY
I2
sVX
I9
sg814
g818
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p892
sg30
g11
sg816
I2
sg817
VSUBTRACT
p893
sg819
I2
sS'block.thisIndex'
p894
I7
sg821
g832
sg823
I0
sg824
g885
sa(dp895
S'block.thisTrialN'
p896
I8
sS'block.thisRepN'
p897
I0
sg29
NsS'block.thisN'
p898
I8
sg809
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp899
sg27
g28
sg811
I4
sg812
(I4
I1
I2
I6
tp900
sg22
I0
sVY
I3
sVX
I5
sg814
g893
sg31
g32
sg33
g34
sg21
Nsg19
Nsg30
g11
sg816
I6
sg817
g834
sg819
I6
sS'block.thisIndex'
p901
I15
sg821
g844
sg823
g867
sg824
VUUBUxy
p902
sa(dp903
S'block.thisTrialN'
p904
I9
sS'block.thisRepN'
p905
I0
sg29
NsS'block.thisN'
p906
I9
sg809
(S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp907
sg27
g28
sg811
I3
sg812
(I4
I12
I4
tp908
sg22
I1
sg20
F3.7103271773667075
sg23
F5.4052433628530707
sVY
I3
sVX
I8
sg814
g847
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p909
sg30
g11
sg816
I4
sg817
g844
sg819
I4
sS'block.thisIndex'
p910
I4
sg821
g836
sg823
I0
sg824
g858
sa(dp911
S'block.thisTrialN'
p912
I10
sS'block.thisRepN'
p913
I0
sg29
NsS'block.thisN'
p914
I10
sg809
(S'DOUBLE'
S'TIMES'
S'x'
S'y'
tp915
sg27
g28
sg811
I2
sg812
(I4
I8
tp916
sg22
I1
sg20
F0.87211949433549307
sg23
F2.8938231795618776
sVY
I2
sVX
I2
sg814
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p917
sg30
g11
sg816
I8
sg817
g857
sg819
I8
sS'block.thisIndex'
p918
I3
sg821
g834
sg823
I0
sg824
VUBxy
p919
sa(dp920
S'block.thisTrialN'
p921
I11
sS'block.thisRepN'
p922
I0
sg29
NsS'block.thisN'
p923
I11
sg809
(S'THIRD'
S'INCREASE'
S'ADD'
S'DOUBLE'
S'x'
S'y'
tp924
sg27
g28
sg811
I4
sg812
(I16
I20
I21
I7
tp925
sg22
I1
sg20
F7.7880208200222114
sg23
F6.9097262200666592
sVY
I4
sVX
I8
sg814
g822
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p926
sg30
g11
sg816
I7
sg817
g832
sg819
I7
sS'block.thisIndex'
p927
I14
sg821
g818
sg823
g834
sg824
g902
sa(dp928
S'block.thisTrialN'
p929
I12
sS'block.thisRepN'
p930
I0
sg29
NsS'block.thisN'
p931
I12
sg809
(S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp932
sg27
g28
sg811
I2
sg812
(I6
I2
tp933
sg22
I1
sg20
F1.8511328842869261
sg23
F4.9151601030462189
sVY
I4
sVX
I5
sg814
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p934
sg30
g11
sg816
I2
sg817
g832
sg819
I2
sS'block.thisIndex'
p935
I1
sg821
g893
sg823
I0
sg824
g825
sa(dp936
S'block.thisTrialN'
p937
I13
sS'block.thisRepN'
p938
I0
sg29
NsS'block.thisN'
p939
I13
sg809
(S'DOUBLE'
S'ADD'
S'x'
S'y'
tp940
sg27
g28
sg811
I2
sg812
(I4
I8
tp941
sg22
I0
sg20
F0.93980593125161249
sg23
F2.7447278876352357
sVY
I2
sVX
I2
sg814
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p942
sg30
g11
sg816
I8
sg817
g822
sg819
I8
sS'block.thisIndex'
p943
I2
sg821
g834
sg823
I0
sg824
g919
sa(dp944
S'block.thisTrialN'
p945
I14
sS'block.thisRepN'
p946
I0
sg29
NsS'block.thisN'
p947
I14
sg809
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp948
sg27
g28
sg811
I3
sg812
(I2
I6
I5
tp949
sg22
I1
sg20
F1.7410259739408502
sg23
F2.1093317412305623
sVY
I4
sVX
I8
sg814
g836
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p950
sg30
g11
sg816
I5
sg817
g844
sg819
I5
sS'block.thisIndex'
p951
I8
sg821
g867
sg823
I0
sg824
VUUBxy
p952
sa(dp953
S'block.thisTrialN'
p954
I15
sS'block.thisRepN'
p955
I0
sg29
NsS'block.thisN'
p956
I15
sg809
(S'TIMES'
S'INCREASE'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp957
sg27
g28
sg811
I4
sg812
(I6
I3
I4
I8
tp958
sg22
I1
sg20
F3.039267302461667
sg23
F5.7321176535187988
sVY
I2
sVX
I2
sg814
g847
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p959
sg30
g11
sg816
I8
sg817
g832
sg819
I8
sS'block.thisIndex'
p960
I11
sg821
g857
sg823
g844
sg824
g837
sa(dp961
S'block.thisTrialN'
p962
I16
sS'block.thisRepN'
p963
I0
sg29
NsS'block.thisN'
p964
I16
sg809
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp965
sg27
g28
sg811
I3
sg812
(I2
I3
I1
tp966
sg22
I1
sg20
F4.6618820825970033
sg23
F1.8414381959300954
sVY
I6
sVX
I8
sg814
g893
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p967
sg30
g11
sg816
I1
sg817
g832
sg819
I1
sS'block.thisIndex'
p968
I9
sg821
g818
sg823
I0
sg824
g952
sa(dp969
S'block.thisTrialN'
p970
I17
sS'block.thisRepN'
p971
I0
sg29
NsS'block.thisN'
p972
I17
sg809
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp973
sg27
g28
sg811
I4
sg812
(I4
I2
I1
I3
tp974
sg22
I1
sg20
F9.3814482958696317
sg23
F2.9695430281863082
sVY
I5
sVX
I9
sg814
g847
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p975
sg30
g11
sg816
I3
sg817
g867
sg819
I3
sS'block.thisIndex'
p976
I17
sg821
g844
sg823
g893
sg824
g868
sa(dp977
S'block.thisTrialN'
p978
I0
sS'block.thisRepN'
p979
I0
sg29
NsS'block.thisN'
p980
I0
sVRule
p981
(S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp982
sg27
g28
sVLength
p983
I3
sVIntermediate
p984
(I8
I16
I7
tp985
sg22
I1
sg20
F7.3535922526498325
sg23
F4.9221656720183091
sVY
I9
sVX
I9
sVOperatorc
p986
Vdecrease
p987
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p988
sg30
g11
sVResult
p989
I7
sVOperatora
p990
Vdouble
p991
sVCorrectResponse
p992
I7
sS'block.thisIndex'
p993
I5
sVOperatorb
p994
VSUBTRACT
p995
sVOperatord
p996
I0
sVStructure
p997
VBUUxy
p998
sa(dp999
S'block.thisTrialN'
p1000
I1
sS'block.thisRepN'
p1001
I0
sg29
NsS'block.thisN'
p1002
I1
sg981
(S'TRIPLE'
S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp1003
sg27
g28
sg983
I4
sg984
(I3
I4
I1
I3
tp1004
sg22
I1
sg20
F7.6384359292133013
sg23
F4.9120569768419955
sVY
I3
sVX
I6
sg986
Vincrease
p1005
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1006
sg30
g11
sg989
I3
sg990
g995
sg992
I3
sS'block.thisIndex'
p1007
I13
sg994
Vtriple
p1008
sg996
Vhalf
p1009
sg997
VUBUUxy
p1010
sa(dp1011
S'block.thisTrialN'
p1012
I2
sS'block.thisRepN'
p1013
I0
sg29
NsS'block.thisN'
p1014
I2
sg981
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'ADD'
S'x'
S'y'
tp1015
sg27
g28
sg983
I4
sg984
(I4
I12
I6
I5
tp1016
sg22
I1
sg20
F1.5642867166898213
sg23
F10.198087729542749
sVY
I2
sVX
I2
sg986
g1008
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1017
sg30
g11
sg989
I5
sg990
g1009
sg992
I5
sS'block.thisIndex'
p1018
I16
sg994
g987
sg996
VADD
p1019
sg997
VUUUBxy
p1020
sa(dp1021
S'block.thisTrialN'
p1022
I3
sS'block.thisRepN'
p1023
I0
sg29
NsS'block.thisN'
p1024
I3
sg981
(S'TIMES'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1025
sg27
g28
sg983
I4
sg984
(I6
I2
I1
I2
tp1026
sg22
I1
sg20
F4.8766669198084855
sg23
F11.4076056163467
sVY
I2
sVX
I3
sg986
Vthird
p1027
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1028
sg30
g11
sg989
I2
sg990
g987
sg992
I2
sS'block.thisIndex'
p1029
I11
sg994
VTIMES
p1030
sg996
g991
sg997
VBUUUxy
p1031
sa(dp1032
S'block.thisTrialN'
p1033
I4
sS'block.thisRepN'
p1034
I0
sg29
NsS'block.thisN'
p1035
I4
sg981
(S'TRIPLE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp1036
sg27
g28
sg983
I3
sg984
(I6
I3
I9
tp1037
sg22
I1
sg20
F7.711484856554307
sg23
F3.1142431287298677
sVY
I3
sVX
I2
sg986
g1030
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1038
sg30
g11
sg989
I9
sg990
g1009
sg992
I9
sS'block.thisIndex'
p1039
I9
sg994
g1008
sg996
I0
sg997
VUUBxy
p1040
sa(dp1041
S'block.thisTrialN'
p1042
I5
sS'block.thisRepN'
p1043
I0
sg29
NsS'block.thisN'
p1044
I5
sg981
(S'DECREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp1045
sg27
g28
sg983
I3
sg984
(I4
I2
I1
tp1046
sg22
I1
sg20
F7.4570971019275021
sg23
F2.8417353149270639
sVY
I2
sVX
I8
sg986
VDIVIDE
p1047
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1048
sg30
g11
sg989
I1
sg990
g1009
sg992
I1
sS'block.thisIndex'
p1049
I8
sg994
g987
sg996
I0
sg997
g1040
sa(dp1050
S'block.thisTrialN'
p1051
I6
sS'block.thisRepN'
p1052
I0
sg29
NsS'block.thisN'
p1053
I6
sg981
(S'INCREASE'
S'HALF'
S'TIMES'
S'TRIPLE'
S'x'
S'y'
tp1054
sg27
g28
sg983
I4
sg984
(I6
I12
I6
I7
tp1055
sg22
I1
sg20
F5.3186620476190001
sg23
F5.5877132721216185
sVY
I2
sVX
I2
sg986
g1030
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p1056
sg30
g11
sg989
I7
sg990
g1009
sg992
I7
sS'block.thisIndex'
p1057
I14
sg994
g1005
sg996
g1008
sg997
VUUBUxy
p1058
sa(dp1059
S'block.thisTrialN'
p1060
I7
sS'block.thisRepN'
p1061
I0
sg29
NsS'block.thisN'
p1062
I7
sg981
(S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp1063
sg27
g28
sg983
I2
sg984
(I2
I6
tp1064
sg22
I1
sg20
F2.2013647875719471
sg23
F1.3980474137497367
sVY
I6
sVX
I8
sg986
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1065
sg30
g11
sg989
I6
sg990
g995
sg992
I6
sS'block.thisIndex'
p1066
I3
sg994
g1008
sg996
I0
sg997
VUBxy
p1067
sa(dp1068
S'block.thisTrialN'
p1069
I8
sS'block.thisRepN'
p1070
I0
sg29
NsS'block.thisN'
p1071
I8
sg981
(S'DIVIDE'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1072
sg27
g28
sg983
I4
sg984
(I12
I4
I3
I1
tp1073
sg22
I1
sg20
F1.7328179304458899
sg23
F8.8778203994297655
sVY
I3
sVX
I6
sg986
g1027
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1074
sg30
g11
sg989
I1
sg990
g987
sg992
I1
sS'block.thisIndex'
p1075
I10
sg994
g1047
sg996
g991
sg997
g1031
sa(dp1076
S'block.thisTrialN'
p1077
I9
sS'block.thisRepN'
p1078
I0
sg29
NsS'block.thisN'
p1079
I9
sg981
(S'INCREASE'
S'TIMES'
S'x'
S'y'
tp1080
sg27
g28
sg983
I2
sg984
(I8
I9
tp1081
sg22
I1
sg20
F0.64602803697925992
sg23
F1.6804500950238435
sVY
I4
sVX
I2
sg986
I0
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1082
sg30
g11
sg989
I9
sg990
g1030
sg992
I9
sS'block.thisIndex'
p1083
I2
sg994
g1005
sg996
I0
sg997
g1067
sa(dp1084
S'block.thisTrialN'
p1085
I10
sS'block.thisRepN'
p1086
I0
sg29
NsS'block.thisN'
p1087
I10
sg981
(S'INCREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp1088
sg27
g28
sg983
I4
sg984
(I4
I2
I6
I7
tp1089
sg22
I0
sg20
F0.65501509918249212
sg23
F11.325137071937206
sVY
I2
sVX
I2
sg986
g1009
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1090
sg30
g11
sg989
I7
sg990
g1008
sg992
I7
sS'block.thisIndex'
p1091
I17
sg994
g1005
sg996
g1019
sg997
g1020
sa(dp1092
S'block.thisTrialN'
p1093
I11
sS'block.thisRepN'
p1094
I0
sg29
NsS'block.thisN'
p1095
I11
sg981
(S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp1096
sg27
g28
sg983
I3
sg984
(I1
I4
I8
tp1097
sg22
I1
sg20
F3.5323850956192473
sg23
F4.100730688762269
sVY
I4
sVX
I3
sg986
g1027
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1098
sg30
g11
sg989
I8
sg990
g1030
sg992
I8
sS'block.thisIndex'
p1099
I6
sg994
g991
sg996
I0
sg997
VUBUxy
p1100
sa(dp1101
S'block.thisTrialN'
p1102
I12
sS'block.thisRepN'
p1103
I0
sg29
NsS'block.thisN'
p1104
I12
sg981
(S'TIMES'
S'THIRD'
S'x'
S'y'
tp1105
sg27
g28
sg983
I2
sg984
(I1
I4
tp1106
sg22
I1
sg20
F2.4595646944217151
sg23
F1.4952462710498367
sVY
I4
sVX
I3
sg986
I0
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1107
sg30
g11
sg989
I4
sg990
g1027
sg992
I4
sS'block.thisIndex'
p1108
I1
sg994
g1030
sg996
I0
sg997
VBUxy
p1109
sa(dp1110
S'block.thisTrialN'
p1111
I13
sS'block.thisRepN'
p1112
I0
sg29
NsS'block.thisN'
p1113
I13
sg981
(S'DECREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp1114
sg27
g28
sg983
I4
sg984
(I6
I18
I2
I1
tp1115
sg22
I1
sg20
F5.7003497185069136
sg23
F14.808687913406175
sVY
I9
sVX
I3
sg986
g1008
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1116
sg30
g11
sg989
I1
sg990
g1047
sg992
I1
sS'block.thisIndex'
p1117
I12
sg994
g987
sg996
g991
sg997
g1010
sa(dp1118
S'block.thisTrialN'
p1119
I14
sS'block.thisRepN'
p1120
I0
sg29
NsS'block.thisN'
p1121
I14
sg981
(S'ADD'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp1122
sg27
g28
sg983
I3
sg984
(I3
I2
I6
tp1123
sg22
I1
sg20
F2.1557851938268868
sg23
F3.3464410988672171
sVY
I4
sVX
I6
sg986
g1009
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1124
sg30
g11
sg989
I6
sg990
g987
sg992
I6
sS'block.thisIndex'
p1125
I4
sg994
g1019
sg996
I0
sg997
g998
sa(dp1126
S'block.thisTrialN'
p1127
I15
sS'block.thisRepN'
p1128
I0
sg29
NsS'block.thisN'
p1129
I15
sg981
(S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp1130
sg27
g28
sg983
I2
sg984
(I3
I1
tp1131
sg22
I1
sg20
F0.80618742434307933
sg23
F3.5845433029026026
sVY
I2
sVX
I9
sg986
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1132
sg30
g11
sg989
I1
sg990
g1027
sg992
I1
sS'block.thisIndex'
p1133
I0
sg994
g995
sg996
I0
sg997
g1109
sa(dp1134
S'block.thisTrialN'
p1135
I16
sS'block.thisRepN'
p1136
I0
sg29
NsS'block.thisN'
p1137
I16
sg981
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp1138
sg27
g28
sg983
I4
sg984
(I4
I2
I3
I1
tp1139
sg22
I1
sg20
F2.9558101112197619
sg23
F3.1960663404752268
sVY
I2
sVX
I8
sg986
g995
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1140
sg30
g11
sg989
I1
sg990
g1005
sg992
I1
sS'block.thisIndex'
p1141
I15
sg994
g1027
sg996
g1009
sg997
g1058
sa(dp1142
S'block.thisTrialN'
p1143
I17
sS'block.thisRepN'
p1144
I0
sg29
NsS'block.thisN'
p1145
I17
sg981
(S'INCREASE'
S'DIVIDE'
S'HALF'
S'x'
S'y'
tp1146
sg27
g28
sg983
I3
sg984
(I2
I1
I2
tp1147
sg22
I1
sg20
F3.545418435591273
sg23
F4.1377008309209486
sVY
I2
sVX
I4
sg986
g1009
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1148
sg30
g11
sg989
I2
sg990
g1047
sg992
I2
sS'block.thisIndex'
p1149
I7
sg994
g1005
sg996
I0
sg997
g1100
sa(dp1150
S'block.thisTrialN'
p1151
I0
sS'block.thisRepN'
p1152
I0
sg29
NsS'block.thisN'
p1153
I0
sVRule
p1154
(S'THIRD'
S'DIVIDE'
S'x'
S'y'
tp1155
sg27
g28
sVLength
p1156
I2
sVIntermediate
p1157
(I3
I1
tp1158
sg22
I1
sg20
F1.2895688834832981
sg23
F8.4501338785194093
sVY
I2
sVX
I6
sVOperatorc
p1159
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1160
sg30
g11
sVResult
p1161
I1
sVOperatora
p1162
VDIVIDE
p1163
sVCorrectResponse
p1164
I1
sS'block.thisIndex'
p1165
I3
sVOperatorb
p1166
Vthird
p1167
sVOperatord
p1168
I0
sVStructure
p1169
VUBxy
p1170
sa(dp1171
S'block.thisTrialN'
p1172
I1
sS'block.thisRepN'
p1173
I0
sg29
NsS'block.thisN'
p1174
I1
sg1154
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp1175
sg27
g28
sg1156
I4
sg1157
(I6
I2
I6
I5
tp1176
sg22
I1
sg20
F6.4218638285092311
sg23
F4.534170959261246
sVY
I3
sVX
I3
sg1159
g1163
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1177
sg30
g11
sg1161
I5
sg1162
Vtriple
p1178
sg1164
I5
sS'block.thisIndex'
p1179
I14
sg1166
Vdecrease
p1180
sg1168
Vdouble
p1181
sg1169
VUUBUxy
p1182
sa(dp1183
S'block.thisTrialN'
p1184
I2
sS'block.thisRepN'
p1185
I0
sg29
NsS'block.thisN'
p1186
I2
sg1154
(S'INCREASE'
S'ADD'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp1187
sg27
g28
sg1156
I4
sg1157
(I6
I3
I6
I7
tp1188
sg22
I0
sg20
F7.8259603610349586
sg23
F8.2188528127007885
sVY
I3
sVX
I2
sg1159
Vhalf
p1189
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1190
sg30
g11
sg1161
I7
sg1162
VADD
p1191
sg1164
I7
sS'block.thisIndex'
p1192
I13
sg1166
Vincrease
p1193
sg1168
g1178
sg1169
VUBUUxy
p1194
sa(dp1195
S'block.thisTrialN'
p1196
I3
sS'block.thisRepN'
p1197
I0
sg29
NsS'block.thisN'
p1198
I3
sg1154
(S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp1199
sg27
g28
sg1156
I3
sg1157
(I3
I18
I6
tp1200
sg22
I1
sg20
F1.0719878380768932
sg23
F5.3547019868565258
sVY
I6
sVX
I6
sg1159
g1189
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1201
sg30
g11
sg1161
I6
sg1162
VTIMES
p1202
sg1164
I6
sS'block.thisIndex'
p1203
I7
sg1166
g1167
sg1168
I0
sg1169
VUBUxy
p1204
sa(dp1205
S'block.thisTrialN'
p1206
I4
sS'block.thisRepN'
p1207
I0
sg29
NsS'block.thisN'
p1208
I4
sg1154
(S'THIRD'
S'DECREASE'
S'TIMES'
S'HALF'
S'x'
S'y'
tp1209
sg27
g28
sg1156
I4
sg1157
(I4
I16
I15
I5
tp1210
sg22
I0
sg20
F11.750413744332036
sg23
F7.8814337723888457
sVY
I4
sVX
I8
sg1159
g1202
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1211
sg30
g11
sg1161
I5
sg1162
g1180
sg1164
I5
sS'block.thisIndex'
p1212
I15
sg1166
g1167
sg1168
g1189
sg1169
g1182
sa(dp1213
S'block.thisTrialN'
p1214
I5
sS'block.thisRepN'
p1215
I0
sg29
NsS'block.thisN'
p1216
I5
sg1154
(S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1217
sg27
g28
sg1156
I2
sg1157
(I3
I4
tp1218
sg22
I0
sg20
F0.72396875385311432
sg23
F2.3243234068504535
sVY
I3
sVX
I6
sg1159
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1219
sg30
g11
sg1161
I4
sg1162
VSUBTRACT
p1220
sg1164
I4
sS'block.thisIndex'
p1221
I2
sg1166
g1193
sg1168
I0
sg1169
g1170
sa(dp1222
S'block.thisTrialN'
p1223
I6
sS'block.thisRepN'
p1224
I0
sg29
NsS'block.thisN'
p1225
I6
sg1154
(S'DOUBLE'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp1226
sg27
g28
sg1156
I3
sg1157
(I12
I4
I8
tp1227
sg22
I1
sg20
F1.3875012642383808
sg23
F6.6353244039055426
sVY
I6
sVX
I2
sg1159
g1202
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1228
sg30
g11
sg1161
I8
sg1162
g1167
sg1164
I8
sS'block.thisIndex'
p1229
I9
sg1166
g1181
sg1168
I0
sg1169
VUUBxy
p1230
sa(dp1231
S'block.thisTrialN'
p1232
I7
sS'block.thisRepN'
p1233
I0
sg29
NsS'block.thisN'
p1234
I7
sg1154
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1235
sg27
g28
sg1156
I4
sg1157
(I1
I2
I6
I3
tp1236
sg22
I1
sg20
F3.5618184242484858
sg23
F5.7619905362807913
sVY
I2
sVX
I3
sg1159
g1193
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1237
sg30
g11
sg1161
I3
sg1162
g1178
sg1164
I3
sS'block.thisIndex'
p1238
I17
sg1166
g1189
sg1168
g1220
sg1169
VUUUBxy
p1239
sa(dp1240
S'block.thisTrialN'
p1241
I8
sS'block.thisRepN'
p1242
I0
sg29
NsS'block.thisN'
p1243
I8
sg1154
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp1244
sg27
g28
sg1156
I4
sg1157
(I4
I2
I6
I5
tp1245
sg22
I1
sg20
F1.757293326445506
sg23
F6.6609137336636195
sVY
I2
sVX
I6
sg1159
g1189
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1246
sg30
g11
sg1161
I5
sg1162
g1178
sg1164
I5
sS'block.thisIndex'
p1247
I16
sg1166
g1180
sg1168
g1220
sg1169
g1239
sa(dp1248
S'block.thisTrialN'
p1249
I9
sS'block.thisRepN'
p1250
I0
sg29
NsS'block.thisN'
p1251
I9
sg1154
(S'DOUBLE'
S'DIVIDE'
S'TRIPLE'
S'INCREASE'
S'x'
S'y'
tp1252
sg27
g28
sg1156
I4
sg1157
(I5
I15
I3
I6
tp1253
sg22
I1
sg20
F6.0325238561490551
sg23
F5.4344037199771265
sVY
I5
sVX
I4
sg1159
g1178
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1254
sg30
g11
sg1161
I6
sg1162
g1163
sg1164
I6
sS'block.thisIndex'
p1255
I12
sg1166
g1181
sg1168
g1193
sg1169
g1194
sa(dp1256
S'block.thisTrialN'
p1257
I10
sS'block.thisRepN'
p1258
I0
sg29
NsS'block.thisN'
p1259
I10
sg1154
(S'THIRD'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp1260
sg27
g28
sg1156
I3
sg1157
(I6
I3
I1
tp1261
sg22
I1
sg20
F1.3263325471925782
sg23
F5.1309818820300279
sVY
I2
sVX
I7
sg1159
g1180
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1262
sg30
g11
sg1161
I1
sg1162
g1163
sg1164
I1
sS'block.thisIndex'
p1263
I6
sg1166
g1167
sg1168
I0
sg1169
g1204
sa(dp1264
S'block.thisTrialN'
p1265
I11
sS'block.thisRepN'
p1266
I0
sg29
NsS'block.thisN'
p1267
I11
sg1154
(S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp1268
sg27
g28
sg1156
I2
sg1157
(I3
I1
tp1269
sg22
I1
sg20
F0.82036094533395953
sg23
F1.2352304037194699
sVY
I3
sVX
I9
sg1159
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1270
sg30
g11
sg1161
I1
sg1162
g1167
sg1164
I1
sS'block.thisIndex'
p1271
I0
sg1166
g1163
sg1168
I0
sg1169
VBUxy
p1272
sa(dp1273
S'block.thisTrialN'
p1274
I12
sS'block.thisRepN'
p1275
I0
sg29
NsS'block.thisN'
p1276
I12
sg1154
(S'SUBTRACT'
S'DOUBLE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp1277
sg27
g28
sg1156
I4
sg1157
(I2
I6
I12
I8
tp1278
sg22
I0
sg20
F2.6842870946420589
sg23
F8.45473624826991
sVY
I4
sVX
I3
sg1159
g1178
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1279
sg30
g11
sg1161
I8
sg1162
g1181
sg1164
I8
sS'block.thisIndex'
p1280
I10
sg1166
g1220
sg1168
g1180
sg1169
VBUUUxy
p1281
sa(dp1282
S'block.thisTrialN'
p1283
I13
sS'block.thisRepN'
p1284
I0
sg29
NsS'block.thisN'
p1285
I13
sg1154
(S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp1286
sg27
g28
sg1156
I3
sg1157
(I6
I3
I9
tp1287
sg22
I1
sg20
F1.6010850267775822
sg23
F6.8635212415538263
sVY
I3
sVX
I5
sg1159
g1193
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1288
sg30
g11
sg1161
I9
sg1162
g1189
sg1164
I9
sS'block.thisIndex'
p1289
I5
sg1166
g1202
sg1168
I0
sg1169
VBUUxy
p1290
sa(dp1291
S'block.thisTrialN'
p1292
I14
sS'block.thisRepN'
p1293
I0
sg29
NsS'block.thisN'
p1294
I14
sg1154
(S'TIMES'
S'DOUBLE'
S'x'
S'y'
tp1295
sg27
g28
sg1156
I2
sg1157
(I4
I8
tp1296
sg22
I1
sg20
F0.62278416247863788
sg23
F2.65920241222193
sVY
I2
sVX
I2
sg1159
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1297
sg30
g11
sg1161
I8
sg1162
g1181
sg1164
I8
sS'block.thisIndex'
p1298
I1
sg1166
g1202
sg1168
I0
sg1169
g1272
sa(dp1299
S'block.thisTrialN'
p1300
I15
sS'block.thisRepN'
p1301
I0
sg29
NsS'block.thisN'
p1302
I15
sg1154
(S'DOUBLE'
S'DECREASE'
S'ADD'
S'x'
S'y'
tp1303
sg27
g28
sg1156
I3
sg1157
(I4
I3
I6
tp1304
sg22
I1
sg20
F1.2349315348983509
sg23
F3.6267328004323645
sVY
I2
sVX
I2
sg1159
g1191
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1305
sg30
g11
sg1161
I6
sg1162
g1180
sg1164
I6
sS'block.thisIndex'
p1306
I8
sg1166
g1181
sg1168
I0
sg1169
g1230
sa(dp1307
S'block.thisTrialN'
p1308
I16
sS'block.thisRepN'
p1309
I0
sg29
NsS'block.thisN'
p1310
I16
sg1154
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp1311
sg27
g28
sg1156
I3
sg1157
(I4
I12
I3
tp1312
sg22
I1
sg20
F1.840806161868386
sg23
F2.9651691845938331
sVY
I9
sVX
I5
sg1159
g1180
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1313
sg30
g11
sg1161
I3
sg1162
g1178
sg1164
I3
sS'block.thisIndex'
p1314
I4
sg1166
g1220
sg1168
I0
sg1169
g1290
sa(dp1315
S'block.thisTrialN'
p1316
I17
sS'block.thisRepN'
p1317
I0
sg29
NsS'block.thisN'
p1318
I17
sg1154
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'DOUBLE'
S'x'
S'y'
tp1319
sg27
g28
sg1156
I4
sg1157
(I4
I3
I9
I1
tp1320
sg22
I1
sg20
F4.5533878039859701
sg23
F7.9360354247037321
sVY
I8
sVX
I2
sg1159
g1180
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1321
sg30
g11
sg1161
I1
sg1162
g1178
sg1164
I1
sS'block.thisIndex'
p1322
I11
sg1166
g1220
sg1168
g1181
sg1169
g1281
sa(dp1323
S'block.thisTrialN'
p1324
I0
sS'block.thisRepN'
p1325
I0
sg29
NsS'block.thisN'
p1326
I0
sVRule
p1327
(S'TRIPLE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp1328
sg27
g28
sVLength
p1329
I3
sVIntermediate
p1330
(I2
I1
I3
tp1331
sg22
I1
sg20
F6.3686938767932588
sg23
F3.3161857060185866
sVY
I2
sVX
I4
sVOperatorc
p1332
VDIVIDE
p1333
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1334
sg30
g11
sVResult
p1335
I3
sVOperatora
p1336
Vhalf
p1337
sVCorrectResponse
p1338
I3
sS'block.thisIndex'
p1339
I9
sVOperatorb
p1340
Vtriple
p1341
sVOperatord
p1342
I0
sVStructure
p1343
VUUBxy
p1344
sa(dp1345
S'block.thisTrialN'
p1346
I1
sS'block.thisRepN'
p1347
I0
sg29
NsS'block.thisN'
p1348
I1
sg1327
(S'TIMES'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp1349
sg27
g28
sg1329
I3
sg1330
(I4
I3
I9
tp1350
sg22
I1
sg20
F4.9395529076573439
sg23
F2.5860572449309984
sVY
I3
sVX
I8
sg1332
g1337
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1351
sg30
g11
sg1335
I9
sg1336
Vdecrease
p1352
sg1338
I9
sS'block.thisIndex'
p1353
I4
sg1340
VTIMES
p1354
sg1342
I0
sg1343
VBUUxy
p1355
sa(dp1356
S'block.thisTrialN'
p1357
I2
sS'block.thisRepN'
p1358
I0
sg29
NsS'block.thisN'
p1359
I2
sg1327
(S'SUBTRACT'
S'HALF'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp1360
sg27
g28
sg1329
I4
sg1330
(I15
I16
I8
I3
tp1361
sg22
I1
sg20
F2.8641567752347328
sg23
F4.0511226653470658
sVY
I5
sVX
I5
sg1332
Vincrease
p1362
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1363
sg30
g11
sg1335
I3
sg1336
g1337
sg1338
I3
sS'block.thisIndex'
p1364
I10
sg1340
VSUBTRACT
p1365
sg1342
g1341
sg1343
VBUUUxy
p1366
sa(dp1367
S'block.thisTrialN'
p1368
I3
sS'block.thisRepN'
p1369
I0
sg29
NsS'block.thisN'
p1370
I3
sg1327
(S'TIMES'
S'INCREASE'
S'x'
S'y'
tp1371
sg27
g28
sg1329
I2
sg1330
(I3
I6
tp1372
sg22
I1
sg20
F0.88188662513857707
sg23
F1.9427235767943785
sVY
I2
sVX
I2
sg1332
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1373
sg30
g11
sg1335
I6
sg1336
g1362
sg1338
I6
sS'block.thisIndex'
p1374
I1
sg1340
g1354
sg1342
I0
sg1343
VBUxy
p1375
sa(dp1376
S'block.thisTrialN'
p1377
I4
sS'block.thisRepN'
p1378
I0
sg29
NsS'block.thisN'
p1379
I4
sg1327
(S'THIRD'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp1380
sg27
g28
sg1329
I3
sg1330
(I8
I15
I5
tp1381
sg22
I1
sg20
F2.8291012832924025
sg23
F3.8058892554545309
sVY
I7
sVX
I7
sg1332
g1362
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1382
sg30
g11
sg1335
I5
sg1336
VADD
p1383
sg1338
I5
sS'block.thisIndex'
p1384
I6
sg1340
Vthird
p1385
sg1342
I0
sg1343
VUBUxy
p1386
sa(dp1387
S'block.thisTrialN'
p1388
I5
sS'block.thisRepN'
p1389
I0
sg29
NsS'block.thisN'
p1390
I5
sg1327
(S'THIRD'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp1391
sg27
g28
sg1329
I3
sg1330
(I3
I15
I5
tp1392
sg22
I1
sg20
F2.017107264851802
sg23
F3.1735020950436592
sVY
I5
sVX
I4
sg1332
g1352
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1393
sg30
g11
sg1335
I5
sg1336
g1354
sg1338
I5
sS'block.thisIndex'
p1394
I7
sg1340
g1385
sg1342
I0
sg1343
g1386
sa(dp1395
S'block.thisTrialN'
p1396
I6
sS'block.thisRepN'
p1397
I0
sg29
NsS'block.thisN'
p1398
I6
sg1327
(S'THIRD'
S'ADD'
S'x'
S'y'
tp1399
sg27
g28
sg1329
I2
sg1330
(I9
I3
tp1400
sg22
I1
sg20
F0.51165535875770729
sg23
F2.1524748892406933
sVY
I5
sVX
I4
sg1332
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1401
sg30
g11
sg1335
I3
sg1336
g1383
sg1338
I3
sS'block.thisIndex'
p1402
I2
sg1340
g1385
sg1342
I0
sg1343
VUBxy
p1403
sa(dp1404
S'block.thisTrialN'
p1405
I7
sS'block.thisRepN'
p1406
I0
sg29
NsS'block.thisN'
p1407
I7
sg1327
(S'TIMES'
S'DECREASE'
S'x'
S'y'
tp1408
sg27
g28
sg1329
I2
sg1330
(I2
I4
tp1409
sg22
I1
sg20
F1.8255684019386536
sg23
F2.5952042404387612
sVY
I2
sVX
I3
sg1332
I0
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1410
sg30
g11
sg1335
I4
sg1336
g1352
sg1338
I4
sS'block.thisIndex'
p1411
I0
sg1340
g1354
sg1342
I0
sg1343
g1375
sa(dp1412
S'block.thisTrialN'
p1413
I8
sS'block.thisRepN'
p1414
I0
sg29
NsS'block.thisN'
p1415
I8
sg1327
(S'THIRD'
S'DECREASE'
S'TIMES'
S'x'
S'y'
tp1416
sg27
g28
sg1329
I3
sg1330
(I25
I24
I8
tp1417
sg22
I1
sg20
F2.9557103716215352
sg23
F4.4893724839785136
sVY
I5
sVX
I5
sg1332
g1354
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1418
sg30
g11
sg1335
I8
sg1336
g1352
sg1338
I8
sS'block.thisIndex'
p1419
I8
sg1340
Vthid
p1420
sg1342
I0
sg1343
g1344
sa(dp1421
S'block.thisTrialN'
p1422
I9
sS'block.thisRepN'
p1423
I0
sg29
NsS'block.thisN'
p1424
I9
sg1327
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp1425
sg27
g28
sg1329
I4
sg1330
(I6
I18
I3
I4
tp1426
sg22
I1
sg20
F6.1017966775107197
sg23
F7.0065936619503191
sVY
I6
sVX
I3
sg1332
g1341
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1427
sg30
g11
sg1335
I4
sg1336
g1333
sg1338
I4
sS'block.thisIndex'
p1428
I12
sg1340
g1362
sg1342
Vdouble
p1429
sg1343
VUBUUxy
p1430
sa(dp1431
S'block.thisTrialN'
p1432
I10
sS'block.thisRepN'
p1433
I0
sg29
NsS'block.thisN'
p1434
I10
sg1327
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp1435
sg27
g28
sg1329
I4
sg1330
(I6
I3
I2
I6
tp1436
sg22
I1
sg20
F5.1378205184300896
sg23
F5.9591722103796201
sVY
I2
sVX
I3
sg1332
g1337
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1437
sg30
g11
sg1335
I6
sg1336
g1352
sg1338
I6
sS'block.thisIndex'
p1438
I17
sg1340
g1341
sg1342
g1354
sg1343
VUUUBxy
p1439
sa(dp1440
S'block.thisTrialN'
p1441
I11
sS'block.thisRepN'
p1442
I0
sg29
NsS'block.thisN'
p1443
I11
sg1327
(S'TRIPLE'
S'HALF'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp1444
sg27
g28
sg1329
I4
sg1330
(I1
I4
I2
I6
tp1445
sg22
I1
sg20
F3.5035442551597953
sg23
F6.0439172672340646
sVY
I3
sVX
I2
sg1332
g1383
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1446
sg30
g11
sg1335
I6
sg1336
g1337
sg1338
I6
sS'block.thisIndex'
p1447
I15
sg1340
g1341
sg1342
g1352
sg1343
VUUBUxy
p1448
sa(dp1449
S'block.thisTrialN'
p1450
I12
sS'block.thisRepN'
p1451
I0
sg29
NsS'block.thisN'
p1452
I12
sg1327
(S'TIMES'
S'THIRD'
S'HALF'
S'x'
S'y'
tp1453
sg27
g28
sg1329
I3
sg1330
(I3
I1
I5
tp1454
sg22
I1
sg20
F1.8851297367218649
sg23
F3.8287863161531277
sVY
I5
sVX
I6
sg1332
g1337
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1455
sg30
g11
sg1335
I5
sg1336
g1385
sg1338
I5
sS'block.thisIndex'
p1456
I5
sg1340
g1354
sg1342
I0
sg1343
g1355
sa(dp1457
S'block.thisTrialN'
p1458
I13
sS'block.thisRepN'
p1459
I0
sg29
NsS'block.thisN'
p1460
I13
sg1327
(S'THIRD'
S'DOUBLE'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp1461
sg27
g28
sg1329
I4
sg1330
(I10
I12
I24
I8
tp1462
sg22
I1
sg20
F5.5602351894631283
sg23
F5.652686792134773
sVY
I2
sVX
I9
sg1332
g1383
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1463
sg30
g11
sg1335
I8
sg1336
g1429
sg1338
I8
sS'block.thisIndex'
p1464
I14
sg1340
g1385
sg1342
g1362
sg1343
g1448
sa(dp1465
S'block.thisTrialN'
p1466
I14
sS'block.thisRepN'
p1467
I0
sg29
NsS'block.thisN'
p1468
I14
sg1327
(S'THIRD'
S'INCREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp1469
sg27
g28
sg1329
I4
sg1330
(I4
I2
I3
I1
tp1470
sg22
I1
sg20
F2.3829527888738085
sg23
F7.0730576764326543
sVY
I2
sVX
I8
sg1332
g1337
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1471
sg30
g11
sg1335
I1
sg1336
g1362
sg1338
I1
sS'block.thisIndex'
p1472
I16
sg1340
g1385
sg1342
g1333
sg1343
g1439
sa(dp1473
S'block.thisTrialN'
p1474
I15
sS'block.thisRepN'
p1475
I0
sg29
NsS'block.thisN'
p1476
I15
sg1327
(S'TIMES'
S'INCREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1477
sg27
g28
sg1329
I4
sg1330
(I6
I2
I3
I9
tp1478
sg22
I1
sg20
F3.712925656218431
sg23
F6.7073055926593952
sVY
I3
sVX
I3
sg1332
g1385
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1479
sg30
g11
sg1335
I9
sg1336
g1362
sg1338
I9
sS'block.thisIndex'
p1480
I11
sg1340
g1354
sg1342
g1429
sg1343
g1366
sa(dp1481
S'block.thisTrialN'
p1482
I16
sS'block.thisRepN'
p1483
I0
sg29
NsS'block.thisN'
p1484
I16
sg1327
(S'THIRD'
S'SUBTRACT'
S'x'
S'y'
tp1485
sg27
g28
sg1329
I2
sg1330
(I3
I1
tp1486
sg22
I1
sg20
F0.65802723485103343
sg23
F1.8092667530145263
sVY
I2
sVX
I5
sg1332
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1487
sg30
g11
sg1335
I1
sg1336
g1365
sg1338
I1
sS'block.thisIndex'
p1488
I3
sg1340
g1385
sg1342
I0
sg1343
g1403
sa(dp1489
S'block.thisTrialN'
p1490
I17
sS'block.thisRepN'
p1491
I0
sg29
NsS'block.thisN'
p1492
I17
sg1327
(S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1493
sg27
g28
sg1329
I4
sg1330
(I2
I4
I1
I3
tp1494
sg22
I1
sg20
F4.4534658808261156
sg23
F4.7399106403172482
sVY
I3
sVX
I3
sg1332
g1429
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1495
sg30
g11
sg1335
I3
sg1336
g1365
sg1338
I3
sS'block.thisIndex'
p1496
I13
sg1340
g1341
sg1342
g1352
sg1343
g1430
sasS'loops'
p1497
(lp1498
g1
(cpsychopy.data
TrialHandler
p1499
g3
NtRp1500
(dp1501
S'origin'
p1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1503
sS'thisTrial'
p1504
(lp1505
sS'_exp'
p1506
I155641424
sg10
S'practice_trials'
p1507
sg6
S'C:\\Users\\experimenter\\Desktop\\Experiments\\KRITL\\kritl_experimenter.py'
p1508
sS'thisRepN'
p1509
I1
sg24
I01
sg25
g26
sS'data'
p1510
g1
(cpsychopy.data
DataHandler
p1511
c__builtin__
dict
p1512
(dp1513
g15
cnumpy.ma.core
_mareconstruct
p1514
(cnumpy.ma.core
MaskedArray
p1515
cnumpy
ndarray
p1516
(I0
tp1517
S'b'
tRp1518
(I1
(I6
I1
tcnumpy
dtype
p1519
(S'O4'
I0
I1
tRp1520
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'\xc0{\xe6\x03\xc01\xe5\x03\x10l\x95\x04\xe0I\xe4\x03\xe8\xa1\xe3\x03\xd0/\xe7\x03'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg16
g1514
(g1515
g1516
g1517
S'b'
tRp1521
(I1
(I6
I1
tg1520
I00
S'\x08\x03\x94\x01\xf0\xe84\x01`r\xa7\x01\xf0\xe84\x018\xec4\x01`r\xa7\x01'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'ran'
p1522
g1514
(g1515
g1516
g1517
S'b'
tRp1523
(I1
(I6
I1
tg1519
(S'f4'
I0
I1
tRp1524
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg18
g1514
(g1515
g1516
g1517
S'b'
tRp1525
(I1
(I6
I1
tg1524
I00
S'N\xbb{@=\x9a\xff?\xfd\xfc-A\x89\xac\xbd@\x0c4\x14A\xfc4\xbf@'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg14
g1514
(g1515
g1516
g1517
S'b'
tRp1526
(I1
(I6
I1
tg1520
I00
S'\xa8z\xe6\x03\xa85\xe5\x03\xb8n\x95\x04\x08O\xe4\x03\x90n\x95\x04`\x92&\x04'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1527
g1514
(g1515
g1516
g1517
S'b'
tRp1528
(I1
(I6
I1
tg1524
I00
S'\x00\x00\x80@\x00\x00@@\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x80?\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1514
(g1515
g1516
g1517
S'b'
tRp1529
(I1
(I6
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
NtbstRp1530
(dp1531
S'isNumeric'
p1532
(dp1533
g16
I00
sg1522
I01
sg18
I01
sg14
I00
sg17
I01
sg1527
I01
sg15
I00
ssS'trials'
p1534
g1500
sS'dataTypes'
p1535
(lp1536
g1522
ag1527
ag14
ag15
ag16
ag17
ag18
asS'dataShape'
p1537
(lp1538
I6
aI1
asbsS'method'
p1539
S'fullRandom'
p1540
sS'sequenceIndices'
p1541
cnumpy.core.multiarray
_reconstruct
p1542
(g1516
(I0
tS'b'
tRp1543
(I1
(I6
I1
tg1520
I00
(lp1544
I2
aI4
aI3
aI1
aI0
aI5
atbsS'finished'
p1545
I01
sS'nReps'
p1546
I1
sS'nRemaining'
p1547
I-1
sS'trialList'
p1548
(lp1549
g1
(cpsychopy.data
TrialType
p1550
g1512
(dp1551
g43
I0
sg44
g64
sg45
g94
sg46
I7
sg49
I2
sg48
I0
sg47
I5
sg50
I3
stRp1552
ag1
(g1550
g1512
(dp1553
g43
I0
sg44
g94
sg45
g95
sg46
I8
sg49
I2
sg48
I0
sg47
I3
sg50
I3
stRp1554
ag1
(g1550
g1512
(dp1555
g43
I0
sg44
g64
sg45
g65
sg46
I7
sg49
I2
sg48
I0
sg47
I5
sg50
I4
stRp1556
ag1
(g1550
g1512
(dp1557
g43
g64
sg44
g85
sg45
g65
sg46
I8
sg49
I3
sg48
I0
sg47
I2
sg50
I4
stRp1558
ag1
(g1550
g1512
(dp1559
g43
g74
sg44
g75
sg45
g76
sg46
I3
sg49
I3
sg48
I0
sg47
I3
sg50
I2
stRp1560
ag1
(g1550
g1512
(dp1561
g43
g74
sg44
g75
sg45
g112
sg46
I9
sg49
I4
sg48
g76
sg47
I8
sg50
I8
stRp1562
asS'seed'
p1563
NsS'thisIndex'
p1564
I5
sS'thisN'
p1565
I6
sS'thisTrialN'
p1566
I0
sS'nTotal'
p1567
I6
sS'_warnUseOfNext'
p1568
I01
sbag1
(g1499
g3
NtRp1569
(dp1570
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1571
sg1504
(lp1572
sg1506
I155641424
sg10
S'block'
p1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1574
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1575
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1576
(I1
(I18
I1
tg1520
I00
S"\xe0yb\x04@\x92'\x04 \xd8\x1e\x04\xe0{a\x04`ya\x04\x80\xe2\xe6\x03`\xde`\x04\xc0\xd5\x1e\x04 \xe7)\x04 \x10(\x04\xa0\x0e)\x04\xa0\xcb_\x04\xc0\xfe\xe5\x03\xe0\x80\xe5\x03@\x84\xe4\x03\xa0sb\x04\x80\xd6`\x04 \xe2)\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1577
(I1
(I18
I1
tg1524
I00
S"\xf9\x88\xd0?\t\x11\x1d@{F\xca?\n\x95)@qZ\xa8@\xd1\xf8\x97A\xcflF@\x9e'\r@\xcc\xf5\xa6@\x18\xc7[@\x1cR\xeb@\x8c\x92\x08A\x8e\xf2\xff@\xe4\xc6\xe3@\xf2\xca\x9a@r\xca6@K\xf0QAs\xf2g@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1578
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1579
(I1
(I18
I1
tg1520
I00
S'\xf0\xe84\x01x\x02\x94\x01x\x02\x94\x01\xf0\xe84\x01\xe8\xe74\x018\xec4\x01\xe8\xe74\x01x\x02\x94\x01\xf0\xe84\x01\xc0\x02\x94\x01\x08\x03\x94\x01\xe8\xe74\x01`r\xa7\x01\x08\x03\x94\x018\xec4\x01\xc0\x02\x94\x01\xf0\x05\x9d\x01 \xe94\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1580
(I1
(I18
I1
tg1524
I00
S'\x00\x000A\x00\x00\xa0@\x00\x00@A\x00\x00pA\x00\x00 A\x00\x00\xc0@\x00\x00\x80A\x00\x00PA\x00\x00@@\x00\x00\x80@\x00\x00\x00\x00\x00\x00\x00@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x88A\x00\x00`A\x00\x00\x10A\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1581
(I1
(I18
I1
tg1524
I00
S'\xd1I\x95?\x13CK@\x1c\xcf\x1a@R\x94\xc5?\xca\x90\x8d@bA\x0c@\x06\xb7\xbe?\x8e\xb6$A\xbf}T@\xf9\xdf\xda@\xe8\xa8\x94@\x8f\xee\x0b@\x1bI\xce@u\x96\x82@\xe2\x98\xf7@\x8c\xaa AM\xd5\x1fA\x10\x1e\xa9@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1582
(dp1583
g1532
(dp1584
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1569
sg1535
(lp1585
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1586
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1587
(I1
(I18
I1
tg1520
I00
(lp1588
I10
aI17
aI11
aI8
aI9
aI1
aI5
aI12
aI13
aI16
aI4
aI0
aI2
aI7
aI15
aI3
aI6
aI14
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1589
g1
(g1550
g1512
(dp1590
g51
g229
sVY
I4
sg53
I2
sg54
g230
sg55
I8
sg56
I8
sg52
g143
sVX
I2
sg57
I0
sg58
g130
sg59
I0
sg60
g180
stRp1591
ag1
(g1550
g1512
(dp1592
g51
g176
sVY
I6
sg53
I2
sg54
g177
sg55
I2
sg56
I2
sg52
g143
sVX
I6
sg57
I0
sg58
g144
sg59
I0
sg60
g180
stRp1593
ag1
(g1550
g1512
(dp1594
g51
g237
sVY
I7
sg53
I2
sg54
g238
sg55
I2
sg56
I2
sg52
g160
sVX
I8
sg57
I0
sg58
g143
sg59
I0
sg60
g241
stRp1595
ag1
(g1550
g1512
(dp1596
g51
g264
sVY
I4
sg53
I2
sg54
g265
sg55
I8
sg56
I8
sg52
g207
sVX
I4
sg57
I0
sg58
g131
sg59
I0
sg60
g241
stRp1597
ag1
(g1550
g1512
(dp1598
g51
g221
sVY
I4
sg53
I3
sg54
g222
sg55
I1
sg56
I1
sg52
g143
sVX
I6
sg57
g128
sg58
g144
sg59
I0
sg60
g189
stRp1599
ag1
(g1550
g1512
(dp1600
g51
g185
sVY
I4
sg53
I3
sg54
g186
sg55
I2
sg56
I2
sg52
g131
sVX
I4
sg57
g139
sg58
g160
sg59
I0
sg60
g189
stRp1601
ag1
(g1550
g1512
(dp1602
g51
g272
sVY
I7
sg53
I3
sg54
g273
sg55
I1
sg56
I1
sg52
g160
sVX
I3
sg57
g139
sg58
g131
sg59
I0
sg60
g250
stRp1603
ag1
(g1550
g1512
(dp1604
g51
g246
sVY
I3
sg53
I3
sg54
g247
sg55
I2
sg56
I2
sg52
g144
sVX
I9
sg57
g128
sg58
g126
sg59
I0
sg60
g250
stRp1605
ag1
(g1550
g1512
(dp1606
g51
g158
sVY
I2
sg53
I3
sg54
g159
sg55
I8
sg56
I8
sg52
g141
sVX
I7
sg57
g160
sg58
g143
sg59
I0
sg60
g163
stRp1607
ag1
(g1550
g1512
(dp1608
g51
g168
sVY
I3
sg53
I3
sg54
g169
sg55
I6
sg56
I6
sg52
g139
sVX
I4
sg57
g160
sg58
g143
sg59
I0
sg60
g163
stRp1609
ag1
(g1550
g1512
(dp1610
g51
g124
sVY
I6
sg53
I4
sg54
g125
sg55
I7
sg56
I7
sg52
g128
sVX
I4
sg57
g126
sg58
g130
sg59
g131
sg60
g132
stRp1611
ag1
(g1550
g1512
(dp1612
g51
g150
sVY
I5
sg53
I4
sg54
g151
sg55
I1
sg56
I1
sg52
g126
sVX
I6
sg57
g143
sg58
g144
sg59
g128
sg60
g132
stRp1613
ag1
(g1550
g1512
(dp1614
g51
g194
sVY
I4
sg53
I4
sg54
g195
sg55
I9
sg56
I9
sg52
g130
sVX
I9
sg57
g143
sg58
g198
sg59
g128
sg60
g199
stRp1615
ag1
(g1550
g1512
(dp1616
g51
g204
sVY
I4
sg53
I4
sg54
g205
sg55
I7
sg56
I7
sg52
g207
sVX
I3
sg57
g143
sg58
g141
sg59
g128
sg60
g199
stRp1617
ag1
(g1550
g1512
(dp1618
g51
g280
sVY
I6
sg53
I4
sg54
g281
sg55
I3
sg56
I3
sg52
g128
sVX
I4
sg57
g207
sg58
g141
sg59
g131
sg60
g259
stRp1619
ag1
(g1550
g1512
(dp1620
g51
g255
sVY
I8
sg53
I4
sg54
g256
sg55
I6
sg56
I6
sg52
g139
sVX
I9
sg57
g144
sg58
g143
sg59
g141
sg60
g259
stRp1621
ag1
(g1550
g1512
(dp1622
g51
g213
sVY
I2
sg53
I4
sg54
g214
sg55
I5
sg56
I5
sg52
g131
sVX
I8
sg57
g139
sg58
g141
sg59
g144
sg60
g145
stRp1623
ag1
(g1550
g1512
(dp1624
g51
g137
sVY
I4
sg53
I4
sg54
g138
sg55
I4
sg56
I4
sg52
g141
sVX
I4
sg57
g139
sg58
g143
sg59
g144
sg60
g145
stRp1625
asg1563
Nsg1564
I14
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1626
(dp1627
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1628
sg1504
(lp1629
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1630
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1631
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1632
(I1
(I18
I1
tg1520
I00
S'`\xe4)\x04\xc0\xf4B\t`\xd6\x1e\x04\x00.`\x04`xb\x04\xa0\xe6)\x04\x00\x12(\x04\xc0\x87\xe4\x03 \xe2\x1f\x04@[B\t\xc0\xa9D\t`\xc7(\x04\x80\x12(\x04\x80\xd1`\x04\x80\xe0\xe6\x03\xa0\xa4D\t\xe0\xd8!\x04\x80,_\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1633
(I1
(I18
I1
tg1524
I00
S'\xe9\x83N@*\xb8\xac?\x93\xde\x84?T\xbb\xcc?\x0e!\xf2?j7b@\x99\xa7 @\x18\xd8A@\x05\xc7a@p\x12?@S*\xd1@\xfcO\xab@\xdc\x0e\xf0@)i\xb5@\xdfg\x89@\x18\x17!A\xc16\x8c@9\x8a\x91@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1634
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1635
(I1
(I18
I1
tg1520
I00
S'\x08\x03\x94\x01x\x02\x94\x01\xf0\xe84\x01\xc0\x02\x94\x01\x08\x03\x94\x01\xf0\xe84\x01x\x02\x94\x01\xf0\x05\x9d\x01\xc0\x02\x94\x01\xf0\x05\x9d\x01`r\xa7\x01\xf0\xe84\x01\xe8\xe74\x018\xec4\x01\xf0\x05\x9d\x01\xf0\xe84\x018\xec4\x01\xe8\xe74\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1636
(I1
(I18
I1
tg1524
I00
S'\x00\x00\xe0@\x00\x00\x88A\x00\x00`A\x00\x00\xc0@\x00\x00PA\x00\x00\x80?\x00\x00\x00A\x00\x000A\x00\x00\xa0@\x00\x00\x80@\x00\x00pA\x00\x00\x10A\x00\x00\x00\x00\x00\x00@A\x00\x00 A\x00\x00\x80A\x00\x00@@\x00\x00\x00@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1637
(I1
(I18
I1
tg1524
I00
S'\x92\xc5\x93?a\x04q@B\xa7\x89@\xea\xf3=?\xee(\x11@v\x05\xd9@\x9d\x9d\x8e?\xf5\x90\xe5@\x9c\xecAA\xaa\xd1n@\nC\xad?SN>@I?\x82A3j\xaa@\x83\xe2\x17A6\x15\xbe@{\xdb\\Ay\xf4\x15A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1638
(dp1639
g1532
(dp1640
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1626
sg1535
(lp1641
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1642
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1643
(I1
(I18
I1
tg1520
I00
(lp1644
I12
aI5
aI17
aI16
aI9
aI8
aI3
aI0
aI6
aI11
aI14
aI7
aI13
aI4
aI2
aI10
aI15
aI1
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1645
g1
(g1550
g1512
(dp1646
g288
g368
sVY
I5
sg290
I2
sg291
g369
sg299
I7
sg296
I7
sg297
g302
sVX
I3
sg293
I0
sg301
g298
sg303
I0
sg305
g372
stRp1647
ag1
(g1550
g1512
(dp1648
g288
g452
sVY
I4
sg290
I2
sg291
g453
sg299
I2
sg296
I2
sg297
g302
sVX
I9
sg293
I0
sg301
g456
sg303
I0
sg305
g372
stRp1649
ag1
(g1550
g1512
(dp1650
g288
g428
sVY
I3
sg290
I2
sg291
g429
sg299
I8
sg296
I8
sg297
g336
sVX
I3
sg293
I0
sg301
g302
sg303
I0
sg305
g363
stRp1651
ag1
(g1550
g1512
(dp1652
g288
g359
sVY
I8
sg290
I2
sg291
g360
sg299
I6
sg296
I6
sg297
g298
sVX
I4
sg293
I0
sg301
g304
sg303
I0
sg305
g363
stRp1653
ag1
(g1550
g1512
(dp1654
g288
g420
sVY
I5
sg290
I3
sg291
g421
sg299
I7
sg296
I7
sg297
g354
sVX
I2
sg293
g302
sg301
g298
sg303
I0
sg305
g316
stRp1655
ag1
(g1550
g1512
(dp1656
g288
g311
sVY
I2
sg290
I3
sg291
g312
sg299
I8
sg296
I8
sg297
g314
sVX
I4
sg293
g304
sg301
g298
sg303
I0
sg305
g316
stRp1657
ag1
(g1550
g1512
(dp1658
g288
g377
sVY
I3
sg290
I3
sg291
g378
sg299
I2
sg296
I2
sg297
g326
sVX
I3
sg293
g323
sg301
g354
sg303
I0
sg305
g381
stRp1659
ag1
(g1550
g1512
(dp1660
g288
g404
sVY
I3
sg290
I3
sg291
g405
sg299
I5
sg296
I5
sg297
g298
sVX
I2
sg293
g304
sg301
g323
sg303
I0
sg305
g381
stRp1661
ag1
(g1550
g1512
(dp1662
g288
g350
sVY
I4
sg290
I3
sg291
g351
sg299
I6
sg296
I6
sg297
g294
sVX
I5
sg293
g298
sg301
g354
sg303
I0
sg305
g345
stRp1663
ag1
(g1550
g1512
(dp1664
g288
g341
sVY
I3
sg290
I3
sg291
g342
sg299
I5
sg296
I5
sg297
g323
sVX
I3
sg293
g336
sg301
g304
sg303
I0
sg305
g345
stRp1665
ag1
(g1550
g1512
(dp1666
g288
g436
sVY
I4
sg290
I4
sg291
g437
sg299
I9
sg296
I9
sg297
g302
sVX
I9
sg293
g294
sg301
g298
sg303
g354
sg305
g390
stRp1667
ag1
(g1550
g1512
(dp1668
g288
g386
sVY
I2
sg290
I4
sg291
g387
sg299
I8
sg296
I8
sg297
g314
sVX
I2
sg293
g354
sg301
g298
sg303
g302
sg305
g390
stRp1669
ag1
(g1550
g1512
(dp1670
g288
g289
sVY
I6
sg290
I4
sg291
g292
sg299
I6
sg296
I6
sg297
g298
sVX
I6
sg293
g294
sg301
g302
sg303
g304
sg305
g306
stRp1671
ag1
(g1550
g1512
(dp1672
g288
g412
sVY
I2
sg290
I4
sg291
g413
sg299
I3
sg296
I3
sg297
g326
sVX
I9
sg293
g354
sg301
g302
sg303
g294
sg305
g306
stRp1673
ag1
(g1550
g1512
(dp1674
g288
g395
sVY
I3
sg290
I4
sg291
g396
sg299
I5
sg296
I5
sg297
g354
sVX
I3
sg293
g336
sg301
g302
sg303
g294
sg305
g399
stRp1675
ag1
(g1550
g1512
(dp1676
g288
g444
sVY
I3
sg290
I4
sg291
g445
sg299
I8
sg296
I8
sg297
g314
sVX
I3
sg293
g326
sg301
g302
sg303
g354
sg305
g399
stRp1677
ag1
(g1550
g1512
(dp1678
g288
g332
sVY
I4
sg290
I4
sg291
g333
sg299
I3
sg296
I3
sg297
g304
sVX
I3
sg293
g294
sg301
g323
sg303
g336
sg305
g327
stRp1679
ag1
(g1550
g1512
(dp1680
g288
g321
sVY
I2
sg290
I4
sg291
g322
sg299
I1
sg296
I1
sg297
g304
sVX
I7
sg293
g323
sg301
g294
sg303
g326
sg305
g327
stRp1681
asg1563
Nsg1564
I1
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1682
(dp1683
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1684
sg1504
(lp1685
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1686
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1687
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1688
(I1
(I18
I1
tg1520
I00
S"\xc0G\x16\x04\x00\xa32\x04\xa0r{\x04\x00)\x18\x04\xe0\xa2D\t\x00\xcdi\x04\xe0ih\x04@(\x18\x04`jh\x04\x00\xbc@\x04\xe0h\x18\x04\xa0\x99y\x04@\xc3i\x04\xe0\xd0y\x04\xa0t{\x04`\xfei\x04\xc0'j\x04``z\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1689
(I1
(I18
I1
tg1524
I00
S'\x97G\xeb?\xf6\x07\xec?\xa6R\x98@\xae\x8b\xaf@\xa6|\xe4@\xab\x06\xec@\xb2`\xb9@\x93\x04m@\x81\xdc\x0e@\x7f+9@\xc6\x98\xd8?\xb0\xd6\x9cA\x15\xf6\x93@\xa5\xbc&A\xfb\xc5w@d@\x8a@\nb\x9e@\x1d\xd3\xca@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1690
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1691
(I1
(I18
I1
tg1520
I00
S'x\x02\x94\x018\xec4\x01\xe8\xe74\x01\xc0\x02\x94\x01`r\xa7\x01 \xe94\x01\xc0\x02\x94\x018\xec4\x01\x08\x03\x94\x01\xe8\xe74\x01\xe8\xe74\x01x\x02\x94\x01\xf0\xe84\x01x\x02\x94\x01\xf0\x05\x9d\x01\xc0\x02\x94\x01\xc0\x02\x94\x01\xc0\x02\x94\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1692
(I1
(I18
I1
tg1524
I00
S'\x00\x00@A\x00\x000A\x00\x00\x80@\x00\x00\xe0@\x00\x00PA\x00\x00\x00@\x00\x00\x10A\x00\x00@@\x00\x00\x80?\x00\x00\xa0@\x00\x00\x80A\x00\x00`A\x00\x00\x00A\x00\x00pA\x00\x00\xc0@\x00\x00\x00\x00\x00\x00 A\x00\x00\x88A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1693
(I1
(I18
I1
tg1524
I00
S'\x89\xc2\x88?H}\xfc@\x19g\x85?V+2A\xb8Zb?\x9e\x17\x96@\x00\xd5\x88?\xdd\xdb\x00@\xc8 /A*/\xa4?\x12\x88XAl\xbb\x15@\xbf;-@<.\xf5@\x88\x06\xfe?\x103\x96AU\x84\\A\x8dG\xd5@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1694
(dp1695
g1532
(dp1696
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1682
sg1535
(lp1697
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1698
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1699
(I1
(I18
I1
tg1520
I00
(lp1700
I15
aI8
aI5
aI7
aI2
aI9
aI14
aI3
aI12
aI6
aI16
aI1
aI0
aI4
aI11
aI13
aI10
aI17
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1701
g1
(g1550
g1512
(dp1702
g461
g585
sVY
I2
sg463
I2
sg464
g586
sg472
I2
sg469
I2
sg470
g489
sVX
I3
sg466
I0
sg474
g467
sg476
I0
sg478
g580
stRp1703
ag1
(g1550
g1512
(dp1704
g461
g576
sVY
I2
sg463
I2
sg464
g577
sg472
I3
sg469
I3
sg470
g498
sVX
I6
sg466
I0
sg474
g509
sg476
I0
sg478
g580
stRp1705
ag1
(g1550
g1512
(dp1706
g461
g516
sVY
I4
sg463
I2
sg464
g517
sg472
I1
sg469
I1
sg470
g467
sVX
I8
sg466
I0
sg474
g498
sg476
I0
sg478
g520
stRp1707
ag1
(g1550
g1512
(dp1708
g461
g542
sVY
I2
sg463
I2
sg464
g543
sg472
I6
sg469
I6
sg470
g527
sVX
I3
sg466
I0
sg474
g489
sg476
I0
sg478
g520
stRp1709
ag1
(g1550
g1512
(dp1710
g461
g593
sVY
I8
sg463
I3
sg464
g594
sg472
I9
sg469
I9
sg470
g507
sVX
I6
sg466
g475
sg474
g527
sg476
I0
sg478
g500
stRp1711
ag1
(g1550
g1512
(dp1712
g461
g495
sVY
I2
sg463
I3
sg464
g496
sg472
I4
sg469
I4
sg470
g498
sVX
I3
sg466
g487
sg474
g467
sg476
I0
sg478
g500
stRp1713
ag1
(g1550
g1512
(dp1714
g461
g559
sVY
I3
sg463
I3
sg464
g560
sg472
I6
sg469
I6
sg470
g527
sVX
I3
sg466
g487
sg474
g507
sg476
I0
sg478
g511
stRp1715
ag1
(g1550
g1512
(dp1716
g461
g505
sVY
I2
sg463
I3
sg464
g506
sg472
I3
sg469
I3
sg470
g509
sVX
I8
sg466
g507
sg474
g489
sg476
I0
sg478
g511
stRp1717
ag1
(g1550
g1512
(dp1718
g461
g484
sVY
I3
sg463
I3
sg464
g485
sg472
I7
sg469
I7
sg470
g487
sVX
I6
sg466
g467
sg474
g489
sg476
I0
sg478
g490
stRp1719
ag1
(g1550
g1512
(dp1720
g461
g525
sVY
I3
sg463
I3
sg464
g526
sg472
I1
sg469
I1
sg470
g507
sVX
I3
sg466
g527
sg474
g475
sg476
I0
sg478
g490
stRp1721
ag1
(g1550
g1512
(dp1722
g461
g619
sVY
I6
sg463
I4
sg464
g620
sg472
I8
sg469
I8
sg470
g477
sVX
I6
sg466
g498
sg474
g527
sg476
g475
sg478
g605
stRp1723
ag1
(g1550
g1512
(dp1724
g461
g601
sVY
I9
sg463
I4
sg464
g602
sg472
I8
sg469
I8
sg470
g498
sVX
I3
sg466
g487
sg474
g509
sg476
g477
sg478
g605
stRp1725
ag1
(g1550
g1512
(dp1726
g461
g550
sVY
I2
sg463
I4
sg464
g551
sg472
I8
sg469
I8
sg470
g527
sVX
I3
sg466
g489
sg474
g477
sg476
g475
sg478
g554
stRp1727
ag1
(g1550
g1512
(dp1728
g461
g610
sVY
I3
sg463
I4
sg464
g611
sg472
I2
sg469
I2
sg470
g613
sVX
I2
sg466
g477
sg474
g475
sg476
g498
sg478
g554
stRp1729
ag1
(g1550
g1512
(dp1730
g461
g534
sVY
I7
sg463
I4
sg464
g535
sg472
I8
sg469
I8
sg470
g477
sVX
I6
sg466
g527
sg474
g475
sg476
g498
sg478
g479
stRp1731
ag1
(g1550
g1512
(dp1732
g461
g462
sVY
I9
sg463
I4
sg464
g465
sg472
I1
sg469
I1
sg470
g471
sVX
I9
sg466
g467
sg474
g475
sg476
g477
sg478
g479
stRp1733
ag1
(g1550
g1512
(dp1734
g461
g567
sVY
I3
sg463
I4
sg464
g568
sg472
I6
sg469
I6
sg470
g487
sVX
I9
sg466
g489
sg474
g507
sg476
g467
sg478
g571
stRp1735
ag1
(g1550
g1512
(dp1736
g461
g627
sVY
I4
sg463
I4
sg464
g628
sg472
I6
sg469
I6
sg470
g477
sVX
I2
sg466
g489
sg474
g475
sg476
g613
sg478
g571
stRp1737
asg1563
Nsg1564
I17
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1738
(dp1739
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1740
sg1504
(lp1741
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1742
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1743
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1744
(I1
(I18
I1
tg1520
I00
S'@2\x17\x04\xc05\x17\x04`(\x18\x04\x80,j\x04\x80\x83\x1f\x04@\x02\x17\x04\xc0\x94\x18\x04\x00\xdf\x1e\x04\xa0]j\x04\x80\xf6i\x04\x80Vj\x04@\xa52\x04`\x99\x18\x04@\x96y\x04\xc0oh\x04\x80wx\x04 !i\x04@\n\x17\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1745
(I1
(I18
I1
tg1524
I00
S'u\xe1J@i\x93\x16@\xe9\xde.@\x93\xa0X@\xc1\xe5\x97@\xcaX\x06@d>I@P~w@\x99S\xae@^\xb1\xb1@?&\x7f@B\x07\x13AJ\xc7\xca@\xca\xe8C@+3\x82@\xc5\x96/A\x11\xe7mA\xcfo\nA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1746
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1747
(I1
(I18
I1
tg1520
I00
S'\x08\x03\x94\x01`r\xa7\x01x\x02\x94\x01\xf0\x05\x9d\x01`r\xa7\x018\xec4\x01\xf0\xe84\x018\xec4\x01`r\xa7\x01\xc0\x02\x94\x01\xf0\x05\x9d\x01`r\xa7\x01\xf0\x05\x9d\x01\x08\x03\x94\x01\xc0\x02\x94\x01 \xe94\x01\xf0\x05\x9d\x01\xf0\x05\x9d\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1748
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x10A\x00\x00\x80@\x00\x00 A\x00\x00\x80?\x00\x00pA\x00\x00\x00A\x00\x00\xc0@\x00\x00\x00\x00\x00\x00\x88A\x00\x00PA\x00\x00@@\x00\x00`A\x00\x00\xe0@\x00\x00\x80A\x00\x00\x00@\x00\x000A\x00\x00@A\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1749
(I1
(I18
I1
tg1524
I00
S'\x07s\x93?\xf9\xc1\x84?\xf4\xe6=?\x94\xd7o@\xbd\xdf\x08@8!K@R\xdbX@4U\xe0@zC\xd3?\xe6\xff\xd1@\x17*\x82@\xe8\xe0#@/\xb4\x84@5g\xa1@\xe8!\xb5@\xa0\x0e\xbe@^\xa6W@F\xf9\xcb?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1750
(dp1751
g1532
(dp1752
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1738
sg1535
(lp1753
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1754
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1755
(I1
(I18
I1
tg1520
I00
(lp1756
I7
aI3
aI14
aI10
aI1
aI17
aI6
aI12
aI5
aI0
aI2
aI15
aI16
aI9
aI11
aI4
aI13
aI8
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1757
g1
(g1550
g1512
(dp1758
g635
g734
sVY
I5
sg637
I2
sg638
g735
sg646
I7
sg643
I7
sg644
g697
sVX
I4
sg640
I0
sg648
g738
sg650
I0
sg651
g690
stRp1759
ag1
(g1550
g1512
(dp1760
g635
g686
sVY
I3
sg637
I2
sg638
g687
sg646
I9
sg643
I9
sg644
g641
sVX
I4
sg640
I0
sg648
g668
sg650
I0
sg651
g690
stRp1761
ag1
(g1550
g1512
(dp1762
g635
g743
sVY
I8
sg637
I2
sg638
g744
sg646
I2
sg643
I2
sg644
g645
sVX
I8
sg640
I0
sg648
g747
sg650
I0
sg651
g661
stRp1763
ag1
(g1550
g1512
(dp1764
g635
g657
sVY
I2
sg637
I2
sg638
g658
sg646
I5
sg643
I5
sg644
g645
sVX
I8
sg640
I0
sg648
g649
sg650
I0
sg651
g661
stRp1765
ag1
(g1550
g1512
(dp1766
g635
g785
sVY
I2
sg637
I3
sg638
g786
sg646
I9
sg643
I9
sg644
g641
sVX
I7
sg640
g709
sg648
g645
sg650
I0
sg651
g729
stRp1767
ag1
(g1550
g1512
(dp1768
g635
g725
sVY
I2
sg637
I3
sg638
g726
sg646
I3
sg643
I3
sg644
g649
sVX
I8
sg640
g697
sg648
g668
sg650
I0
sg651
g729
stRp1769
ag1
(g1550
g1512
(dp1770
g635
g707
sVY
I2
sg637
I3
sg638
g708
sg646
I8
sg643
I8
sg644
g701
sVX
I9
sg640
g709
sg648
g697
sg650
I0
sg651
g652
stRp1771
ag1
(g1550
g1512
(dp1772
g635
g636
sVY
I3
sg637
I3
sg638
g639
sg646
I3
sg643
I3
sg644
g645
sVX
I2
sg640
g641
sg648
g649
sg650
I0
sg651
g652
stRp1773
ag1
(g1550
g1512
(dp1774
g635
g801
sVY
I3
sg637
I3
sg638
g802
sg646
I9
sg643
I9
sg644
g697
sVX
I3
sg640
g738
sg648
g641
sg650
I0
sg651
g772
stRp1775
ag1
(g1550
g1512
(dp1776
g635
g768
sVY
I2
sg637
I3
sg638
g769
sg646
I6
sg643
I6
sg644
g649
sVX
I3
sg640
g668
sg648
g641
sg650
I0
sg651
g772
stRp1777
ag1
(g1550
g1512
(dp1778
g635
g677
sVY
I4
sg637
I4
sg638
g678
sg646
I5
sg643
I5
sg644
g670
sVX
I3
sg640
g649
sg648
g645
sg650
g641
sg651
g681
stRp1779
ag1
(g1550
g1512
(dp1780
g635
g777
sVY
I9
sg637
I4
sg638
g778
sg646
I9
sg643
I9
sg644
g697
sVX
I3
sg640
g649
sg648
g701
sg650
g700
sg651
g681
stRp1781
ag1
(g1550
g1512
(dp1782
g635
g716
sVY
I4
sg637
I4
sg638
g717
sg646
I5
sg643
I5
sg644
g668
sVX
I5
sg640
g709
sg648
g697
sg650
g641
sg651
g720
stRp1783
ag1
(g1550
g1512
(dp1784
g635
g793
sVY
I2
sg637
I4
sg638
g794
sg646
I7
sg643
I7
sg644
g701
sVX
I2
sg640
g641
sg648
g649
sg650
g697
sg651
g720
stRp1785
ag1
(g1550
g1512
(dp1786
g635
g666
sVY
I4
sg637
I4
sg638
g667
sg646
I6
sg643
I6
sg644
g670
sVX
I4
sg640
g668
sg648
g641
sg650
g649
sg651
g672
stRp1787
ag1
(g1550
g1512
(dp1788
g635
g752
sVY
I8
sg637
I4
sg638
g753
sg646
I9
sg643
I9
sg644
g649
sVX
I8
sg640
g645
sg648
g641
sg650
g670
sg651
g672
stRp1789
ag1
(g1550
g1512
(dp1790
g635
g760
sVY
I4
sg637
I4
sg638
g761
sg646
I5
sg643
I5
sg644
g700
sVX
I5
sg640
g670
sg648
g709
sg650
g738
sg651
g702
stRp1791
ag1
(g1550
g1512
(dp1792
g635
g695
sVY
I4
sg637
I4
sg638
g696
sg646
I5
sg643
I5
sg644
g649
sVX
I7
sg640
g697
sg648
g700
sg650
g701
sg651
g702
stRp1793
asg1563
Nsg1564
I8
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1794
(dp1795
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1796
sg1504
(lp1797
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1798
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1799
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1800
(I1
(I18
I1
tg1520
I00
S"@cz\x04\xa0?\x17\x04\xc0'\x18\x04\xc0Zy\x04@Q@\x04\xa0/j\x04\x00\x01\x17\x04\xa0-3\x04\xe0\x7fx\x04\x80\xd8\x1e\x04\xa0\xa82\x04`/i\x04\x00\xf3i\x04@,\x18\x04\xe0\x00\x17\x04\xcc\x18\x1f\x1e\xe0\xcci\x04\x80GD\t"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1801
(I1
(I18
I1
tg1524
I00
S'\x80\xc0\x9e@\xfeH\x9d@\x9f\xa9/@f49@\xc1\xf7\xac@O\xb9\xe2@\xd1\xfe+@\xc4\x00nAK\xff\x06@?\xb4\xeb?\xd6\xb8\x03A\x82m\xb7@\xb1S\x8e@\x83L\xef@z\x1c\xdd@\x00\x00\x00\x00\xeb\xdb\xb5@\xfe\x0c>@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1802
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1803
(I1
(I18
I1
tg1520
I00
S'8\xec4\x01x\x02\x94\x018\xec4\x01\xf0\xe84\x01 \xe94\x01 \xe94\x01`r\xa7\x01x\x02\x94\x01\xf0\x05\x9d\x01\xe8\xe74\x01x\x02\x94\x01\xf0\xe84\x018\xec4\x01 \xe94\x01\x08\x03\x94\x01\xcc\x18\x1f\x1e\xf0\xe84\x018\xec4\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1804
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x00\x00\x00\x00@A\x00\x00PA\x00\x00 A\x00\x00\x10A\x00\x00@@\x00\x00\xc0@\x00\x00\xe0@\x00\x00`A\x00\x00\x80A\x00\x00\x80?\x00\x00pA\x00\x00\x00@\x00\x00\xa0@\x00\x000A\x00\x00\x00A\x00\x00\x80@\x00\x00\x88A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1805
(I1
(I18
I1
tg1524
I00
S'\x07\xe6)@\xec\xf1\xec?\x1f\x97p?9C_?\x00vm@\x13\x889@\xd1\xbb\x14@\x91\xcb\x93=\xf0\xd9\xde?#.\x95@\x15\xa4?@[\x83B@\xa3\xfd\x07@\x16\xe0V@w7\xf9@\x00\x00\x00\x00\xd2\x13\x08@j\x1a\x16A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00'
NtbstRp1806
(dp1807
g1532
(dp1808
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1794
sg1535
(lp1809
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1810
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1811
(I1
(I18
I1
tg1520
I00
(lp1812
I0
aI10
aI12
aI5
aI16
aI13
aI6
aI7
aI15
aI4
aI3
aI14
aI1
aI2
aI8
aI11
aI9
aI17
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1813
g1
(g1550
g1512
(dp1814
g809
g810
sVY
I6
sg811
I2
sg812
g813
sg819
I7
sg816
I7
sg817
g818
sVX
I3
sg814
I0
sg821
g822
sg823
I0
sg824
g825
stRp1815
ag1
(g1550
g1512
(dp1816
g809
g932
sVY
I4
sg811
I2
sg812
g933
sg819
I2
sg816
I2
sg817
g832
sVX
I5
sg814
I0
sg821
g893
sg823
I0
sg824
g825
stRp1817
ag1
(g1550
g1512
(dp1818
g809
g940
sVY
I2
sg811
I2
sg812
g941
sg819
I8
sg816
I8
sg817
g822
sVX
I2
sg814
I0
sg821
g834
sg823
I0
sg824
g919
stRp1819
ag1
(g1550
g1512
(dp1820
g809
g915
sVY
I2
sg811
I2
sg812
g916
sg819
I8
sg816
I8
sg817
g857
sVX
I2
sg814
I0
sg821
g834
sg823
I0
sg824
g919
stRp1821
ag1
(g1550
g1512
(dp1822
g809
g907
sVY
I3
sg811
I3
sg812
g908
sg819
I4
sg816
I4
sg817
g844
sVX
I8
sg814
g847
sg821
g836
sg823
I0
sg824
g858
stRp1823
ag1
(g1550
g1512
(dp1824
g809
g853
sVY
I2
sg811
I3
sg812
g854
sg819
I4
sg816
I4
sg817
g818
sVX
I3
sg814
g834
sg821
g857
sg823
I0
sg824
g858
stRp1825
ag1
(g1550
g1512
(dp1826
g809
g881
sVY
I2
sg811
I3
sg812
g882
sg819
I9
sg816
I9
sg817
g822
sVX
I2
sg814
g844
sg821
g832
sg823
I0
sg824
g885
stRp1827
ag1
(g1550
g1512
(dp1828
g809
g890
sVY
I2
sg811
I3
sg812
g891
sg819
I2
sg816
I2
sg817
g893
sVX
I9
sg814
g818
sg821
g832
sg823
I0
sg824
g885
stRp1829
ag1
(g1550
g1512
(dp1830
g809
g948
sVY
I4
sg811
I3
sg812
g949
sg819
I5
sg816
I5
sg817
g844
sVX
I8
sg814
g836
sg821
g867
sg823
I0
sg824
g952
stRp1831
ag1
(g1550
g1512
(dp1832
g809
g965
sVY
I6
sg811
I3
sg812
g966
sg819
I1
sg816
I1
sg817
g832
sVX
I8
sg814
g893
sg821
g818
sg823
I0
sg824
g952
stRp1833
ag1
(g1550
g1512
(dp1834
g809
g830
sVY
I3
sg811
I4
sg812
g831
sg819
I2
sg816
I2
sg817
g834
sVX
I6
sg814
g832
sg821
g836
sg823
g818
sg824
g837
stRp1835
ag1
(g1550
g1512
(dp1836
g809
g957
sVY
I2
sg811
I4
sg812
g958
sg819
I8
sg816
I8
sg817
g832
sVX
I2
sg814
g847
sg821
g857
sg823
g844
sg824
g837
stRp1837
ag1
(g1550
g1512
(dp1838
g809
g842
sVY
I3
sg811
I4
sg812
g843
sg819
I3
sg816
I3
sg817
g836
sVX
I4
sg814
g844
sg821
g832
sg823
g847
sg824
g848
stRp1839
ag1
(g1550
g1512
(dp1840
g809
g873
sVY
I3
sg811
I4
sg812
g874
sg819
I4
sg816
I4
sg817
g857
sVX
I7
sg814
g847
sg821
g818
sg823
g832
sg824
g848
stRp1841
ag1
(g1550
g1512
(dp1842
g809
g924
sVY
I4
sg811
I4
sg812
g925
sg819
I7
sg816
I7
sg817
g832
sVX
I8
sg814
g822
sg821
g818
sg823
g834
sg824
g902
stRp1843
ag1
(g1550
g1512
(dp1844
g809
g899
sVY
I3
sg811
I4
sg812
g900
sg819
I6
sg816
I6
sg817
g834
sVX
I5
sg814
g893
sg821
g844
sg823
g867
sg824
g902
stRp1845
ag1
(g1550
g1512
(dp1846
g809
g863
sVY
I2
sg811
I4
sg812
g864
sg819
I8
sg816
I8
sg817
g844
sVX
I4
sg814
g847
sg821
g867
sg823
g822
sg824
g868
stRp1847
ag1
(g1550
g1512
(dp1848
g809
g973
sVY
I5
sg811
I4
sg812
g974
sg819
I3
sg816
I3
sg817
g867
sVX
I9
sg814
g847
sg821
g844
sg823
g893
sg824
g868
stRp1849
asg1563
Nsg1564
I17
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1850
(dp1851
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1852
sg1504
(lp1853
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1854
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1855
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1856
(I1
(I18
I1
tg1520
I00
S"@7\x17\x04`\xc6\x18\x04\xa0#3\x04\x80$z\x04\xa0s{\x04@sb\x04 \x11'\x04 kh\x04\xa0\xbch\x04\x00dh\x04\xc0]y\x04`*j\x04@Wy\x04`~b\x04`;\x17\x04@\xcfi\x04\x00C\x16\x04@\x8c>\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1857
(I1
(I18
I1
tg1524
I00
S'(ie@;d\xbf?\xfd\x18\xd7?8\xf3\xb2?\x17,V@b\x82\x9d@09\x83@\x0ch\x84@\xfe\xde5@\xc2OG@\x8d\x0b\x0eA\x8d\x856Ac\xf0lA\x92/\x9d@\x8c\xce\xb2@Z\x8cL@^+#A\xc335A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1858
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1859
(I1
(I18
I1
tg1520
I00
S'\xe8\xe74\x01 \xe94\x01`r\xa7\x01\xc0\x02\x94\x01\xc0\x02\x94\x01\x08\x03\x94\x01\xf0\xe84\x01x\x02\x94\x01\xe8\xe74\x01`r\xa7\x01\xe8\xe74\x01x\x02\x94\x01\xe8\xe74\x018\xec4\x01\x08\x03\x94\x01\xe8\xe74\x01\xf0\x05\x9d\x018\xec4\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1860
(I1
(I18
I1
tg1524
I00
S'\x00\x00pA\x00\x00@A\x00\x00\x10A\x00\x00\xe0@\x00\x00`A\x00\x00\x00\x00\x00\x000A\x00\x00\x88A\x00\x00\xa0@\x00\x00\x80@\x00\x00\x00A\x00\x00@@\x00\x00PA\x00\x00\x80?\x00\x00\xc0@\x00\x00\x80A\x00\x00\x00@\x00\x00 A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1861
(I1
(I18
I1
tg1524
I00
S"MbN?\x82i\x1d@\x18b%?)\xe3\x0c@b\xf8\t@\xa1P\xeb@\x99\x12b@#\xe8b@\x8a\xa0\xee@|\xc4\xf6@\xfa\xcc\xdd?\xa8\r\x9c@Di\xb6@\x11n\xf4@{2\xaa@\xfe+=@\x8c:\xc8?\x12\xaf'?"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1862
(dp1863
g1532
(dp1864
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1850
sg1535
(lp1865
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1866
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1867
(I1
(I18
I1
tg1520
I00
(lp1868
I5
aI13
aI16
aI11
aI9
aI8
aI14
aI3
aI10
aI2
aI17
aI6
aI1
aI12
aI4
aI0
aI15
aI7
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1869
g1
(g1550
g1512
(dp1870
g981
g1130
sVY
I2
sg983
I2
sg984
g1131
sg992
I1
sg989
I1
sg990
g1027
sVX
I9
sg986
I0
sg994
g995
sg996
I0
sg997
g1109
stRp1871
ag1
(g1550
g1512
(dp1872
g981
g1105
sVY
I4
sg983
I2
sg984
g1106
sg992
I4
sg989
I4
sg990
g1027
sVX
I3
sg986
I0
sg994
g1030
sg996
I0
sg997
g1109
stRp1873
ag1
(g1550
g1512
(dp1874
g981
g1080
sVY
I4
sg983
I2
sg984
g1081
sg992
I9
sg989
I9
sg990
g1030
sVX
I2
sg986
I0
sg994
g1005
sg996
I0
sg997
g1067
stRp1875
ag1
(g1550
g1512
(dp1876
g981
g1063
sVY
I6
sg983
I2
sg984
g1064
sg992
I6
sg989
I6
sg990
g995
sVX
I8
sg986
I0
sg994
g1008
sg996
I0
sg997
g1067
stRp1877
ag1
(g1550
g1512
(dp1878
g981
g1122
sVY
I4
sg983
I3
sg984
g1123
sg992
I6
sg989
I6
sg990
g987
sVX
I6
sg986
g1009
sg994
g1019
sg996
I0
sg997
g998
stRp1879
ag1
(g1550
g1512
(dp1880
g981
g982
sVY
I9
sg983
I3
sg984
g985
sg992
I7
sg989
I7
sg990
g991
sVX
I9
sg986
g987
sg994
g995
sg996
I0
sg997
g998
stRp1881
ag1
(g1550
g1512
(dp1882
g981
g1096
sVY
I4
sg983
I3
sg984
g1097
sg992
I8
sg989
I8
sg990
g1030
sVX
I3
sg986
g1027
sg994
g991
sg996
I0
sg997
g1100
stRp1883
ag1
(g1550
g1512
(dp1884
g981
g1146
sVY
I2
sg983
I3
sg984
g1147
sg992
I2
sg989
I2
sg990
g1047
sVX
I4
sg986
g1009
sg994
g1005
sg996
I0
sg997
g1100
stRp1885
ag1
(g1550
g1512
(dp1886
g981
g1045
sVY
I2
sg983
I3
sg984
g1046
sg992
I1
sg989
I1
sg990
g1009
sVX
I8
sg986
g1047
sg994
g987
sg996
I0
sg997
g1040
stRp1887
ag1
(g1550
g1512
(dp1888
g981
g1036
sVY
I3
sg983
I3
sg984
g1037
sg992
I9
sg989
I9
sg990
g1009
sVX
I2
sg986
g1030
sg994
g1008
sg996
I0
sg997
g1040
stRp1889
ag1
(g1550
g1512
(dp1890
g981
g1072
sVY
I3
sg983
I4
sg984
g1073
sg992
I1
sg989
I1
sg990
g987
sVX
I6
sg986
g1027
sg994
g1047
sg996
g991
sg997
g1031
stRp1891
ag1
(g1550
g1512
(dp1892
g981
g1025
sVY
I2
sg983
I4
sg984
g1026
sg992
I2
sg989
I2
sg990
g987
sVX
I3
sg986
g1027
sg994
g1030
sg996
g991
sg997
g1031
stRp1893
ag1
(g1550
g1512
(dp1894
g981
g1114
sVY
I9
sg983
I4
sg984
g1115
sg992
I1
sg989
I1
sg990
g1047
sVX
I3
sg986
g1008
sg994
g987
sg996
g991
sg997
g1010
stRp1895
ag1
(g1550
g1512
(dp1896
g981
g1003
sVY
I3
sg983
I4
sg984
g1004
sg992
I3
sg989
I3
sg990
g995
sVX
I6
sg986
g1005
sg994
g1008
sg996
g1009
sg997
g1010
stRp1897
ag1
(g1550
g1512
(dp1898
g981
g1054
sVY
I2
sg983
I4
sg984
g1055
sg992
I7
sg989
I7
sg990
g1009
sVX
I2
sg986
g1030
sg994
g1005
sg996
g1008
sg997
g1058
stRp1899
ag1
(g1550
g1512
(dp1900
g981
g1138
sVY
I2
sg983
I4
sg984
g1139
sg992
I1
sg989
I1
sg990
g1005
sVX
I8
sg986
g995
sg994
g1027
sg996
g1009
sg997
g1058
stRp1901
ag1
(g1550
g1512
(dp1902
g981
g1015
sVY
I2
sg983
I4
sg984
g1016
sg992
I5
sg989
I5
sg990
g1009
sVX
I2
sg986
g1008
sg994
g987
sg996
g1019
sg997
g1020
stRp1903
ag1
(g1550
g1512
(dp1904
g981
g1088
sVY
I2
sg983
I4
sg984
g1089
sg992
I7
sg989
I7
sg990
g1008
sVX
I2
sg986
g1009
sg994
g1005
sg996
g1019
sg997
g1020
stRp1905
asg1563
Nsg1564
I7
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1906
(dp1907
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1908
sg1504
(lp1909
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1910
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1911
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1912
(I1
(I18
I1
tg1520
I00
S' \x85>\x04\x80\xc3\x18\x04\xe0\xf2i\x04@\xf5a\x04`\x0c\x17\x04 \x83>\x04@\xc9\x18\x04\x80\xd2\t\x04\xa0\x98\x18\x04\x80mh\x04 \x81\x07\x04\xc0+\x18\x04`*z\x04@Z2\x04\xa0V2\x04 ub\x04`<\x17\x04@\xbeh\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1913
(I1
(I18
I1
tg1524
I00
S'\x08\x1c\x9e?_0*@\xb7\xc1\x14@\xc03\x07AU\xc5=@\xf7\xa1\xdb@\x011\xa4@\xb8Y\xab@d\x1ch@\x94T\xd4@\x9aF\x07A\x01\xf4\xfd@\xa3\xe6\xad@l\x80\x03A\xee\x17\x91@\xb54\xfc@5&\xd5@:b\xb8@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1914
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1915
(I1
(I18
I1
tg1520
I00
S'\xe8\xe74\x01\xf0\xe84\x018\xec4\x01\xe8\xe74\x018\xec4\x01`r\xa7\x01\xe8\xe74\x01\xc0\x02\x94\x01\xc0\x02\x94\x01\xf0\xe84\x018\xec4\x01\xe8\xe74\x01\xc0\x02\x94\x01x\x02\x94\x01\xf0\x05\x9d\x018\xec4\x01\xf0\x05\x9d\x018\xec4\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1916
(I1
(I18
I1
tg1524
I00
S'\x00\x000A\x00\x00`A\x00\x00\xa0@\x00\x00\x00\x00\x00\x00\x80A\x00\x00PA\x00\x00 A\x00\x00@@\x00\x00pA\x00\x00\xc0@\x00\x00@A\x00\x00\x88A\x00\x00\x10A\x00\x00\x00@\x00\x00\x80?\x00\x00\x80@\x00\x00\x00A\x00\x00\xe0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1917
(I1
(I18
I1
tg1524
I00
S'-\x03R?\xc8n\x1f?\x04V9?\x98\x10\xa5?\x89\x9f\xeb?[\xf0\xcc?D\xc5\xa9?\xe66\x89?=\x12\x9e?\xa4\x99\xb1?\\\xcb+@Z\xb5\x91@o\n\xc1@Dn\xfa@\xe9\x7f\xcd@\xb2\x01<A\xfd\xee\xe0?\xd5\xf4c@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1918
(dp1919
g1532
(dp1920
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1906
sg1535
(lp1921
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1922
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1923
(I1
(I18
I1
tg1520
I00
(lp1924
I3
aI14
aI13
aI7
aI15
aI2
aI9
aI17
aI16
aI12
aI6
aI0
aI10
aI5
aI1
aI8
aI4
aI11
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1925
g1
(g1550
g1512
(dp1926
g1154
g1268
sVY
I3
sg1156
I2
sg1157
g1269
sg1164
I1
sg1161
I1
sg1162
g1167
sVX
I9
sg1159
I0
sg1166
g1163
sg1168
I0
sg1169
g1272
stRp1927
ag1
(g1550
g1512
(dp1928
g1154
g1295
sVY
I2
sg1156
I2
sg1157
g1296
sg1164
I8
sg1161
I8
sg1162
g1181
sVX
I2
sg1159
I0
sg1166
g1202
sg1168
I0
sg1169
g1272
stRp1929
ag1
(g1550
g1512
(dp1930
g1154
g1217
sVY
I3
sg1156
I2
sg1157
g1218
sg1164
I4
sg1161
I4
sg1162
g1220
sVX
I6
sg1159
I0
sg1166
g1193
sg1168
I0
sg1169
g1170
stRp1931
ag1
(g1550
g1512
(dp1932
g1154
g1155
sVY
I2
sg1156
I2
sg1157
g1158
sg1164
I1
sg1161
I1
sg1162
g1163
sVX
I6
sg1159
I0
sg1166
g1167
sg1168
I0
sg1169
g1170
stRp1933
ag1
(g1550
g1512
(dp1934
g1154
g1311
sVY
I9
sg1156
I3
sg1157
g1312
sg1164
I3
sg1161
I3
sg1162
g1178
sVX
I5
sg1159
g1180
sg1166
g1220
sg1168
I0
sg1169
g1290
stRp1935
ag1
(g1550
g1512
(dp1936
g1154
g1286
sVY
I3
sg1156
I3
sg1157
g1287
sg1164
I9
sg1161
I9
sg1162
g1189
sVX
I5
sg1159
g1193
sg1166
g1202
sg1168
I0
sg1169
g1290
stRp1937
ag1
(g1550
g1512
(dp1938
g1154
g1260
sVY
I2
sg1156
I3
sg1157
g1261
sg1164
I1
sg1161
I1
sg1162
g1163
sVX
I7
sg1159
g1180
sg1166
g1167
sg1168
I0
sg1169
g1204
stRp1939
ag1
(g1550
g1512
(dp1940
g1154
g1199
sVY
I6
sg1156
I3
sg1157
g1200
sg1164
I6
sg1161
I6
sg1162
g1202
sVX
I6
sg1159
g1189
sg1166
g1167
sg1168
I0
sg1169
g1204
stRp1941
ag1
(g1550
g1512
(dp1942
g1154
g1303
sVY
I2
sg1156
I3
sg1157
g1304
sg1164
I6
sg1161
I6
sg1162
g1180
sVX
I2
sg1159
g1191
sg1166
g1181
sg1168
I0
sg1169
g1230
stRp1943
ag1
(g1550
g1512
(dp1944
g1154
g1226
sVY
I6
sg1156
I3
sg1157
g1227
sg1164
I8
sg1161
I8
sg1162
g1167
sVX
I2
sg1159
g1202
sg1166
g1181
sg1168
I0
sg1169
g1230
stRp1945
ag1
(g1550
g1512
(dp1946
g1154
g1277
sVY
I4
sg1156
I4
sg1157
g1278
sg1164
I8
sg1161
I8
sg1162
g1181
sVX
I3
sg1159
g1178
sg1166
g1220
sg1168
g1180
sg1169
g1281
stRp1947
ag1
(g1550
g1512
(dp1948
g1154
g1319
sVY
I8
sg1156
I4
sg1157
g1320
sg1164
I1
sg1161
I1
sg1162
g1178
sVX
I2
sg1159
g1180
sg1166
g1220
sg1168
g1181
sg1169
g1281
stRp1949
ag1
(g1550
g1512
(dp1950
g1154
g1252
sVY
I5
sg1156
I4
sg1157
g1253
sg1164
I6
sg1161
I6
sg1162
g1163
sVX
I4
sg1159
g1178
sg1166
g1181
sg1168
g1193
sg1169
g1194
stRp1951
ag1
(g1550
g1512
(dp1952
g1154
g1187
sVY
I3
sg1156
I4
sg1157
g1188
sg1164
I7
sg1161
I7
sg1162
g1191
sVX
I2
sg1159
g1189
sg1166
g1193
sg1168
g1178
sg1169
g1194
stRp1953
ag1
(g1550
g1512
(dp1954
g1154
g1175
sVY
I3
sg1156
I4
sg1157
g1176
sg1164
I5
sg1161
I5
sg1162
g1178
sVX
I3
sg1159
g1163
sg1166
g1180
sg1168
g1181
sg1169
g1182
stRp1955
ag1
(g1550
g1512
(dp1956
g1154
g1209
sVY
I4
sg1156
I4
sg1157
g1210
sg1164
I5
sg1161
I5
sg1162
g1180
sVX
I8
sg1159
g1202
sg1166
g1167
sg1168
g1189
sg1169
g1182
stRp1957
ag1
(g1550
g1512
(dp1958
g1154
g1244
sVY
I2
sg1156
I4
sg1157
g1245
sg1164
I5
sg1161
I5
sg1162
g1178
sVX
I6
sg1159
g1189
sg1166
g1180
sg1168
g1220
sg1169
g1239
stRp1959
ag1
(g1550
g1512
(dp1960
g1154
g1235
sVY
I2
sg1156
I4
sg1157
g1236
sg1164
I3
sg1161
I3
sg1162
g1178
sVX
I3
sg1159
g1193
sg1166
g1189
sg1168
g1220
sg1169
g1239
stRp1961
asg1563
Nsg1564
I11
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbag1
(g1499
g3
NtRp1962
(dp1963
g1502
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1964
sg1504
(lp1965
sg1506
I155641424
sg10
g1573
sg6
g1508
sg1509
I1
sg24
I01
sg25
g26
sg1510
g1
(g1511
g1512
(dp1966
g22
g1514
(g1515
g1516
g1517
S'b'
tRp1967
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1514
(g1515
g1516
g1517
S'b'
tRp1968
(I1
(I18
I1
tg1520
I00
S"@\xf4a\x04\x00\x8a\xe4\x03\xe0\xd5\x1e\x04\xc0\x8e>\x04\xc0\xd6\t\x04 )3\x04\xc0\xda\x07\x04\xc0\x92\x07\x04`)i\x04\x00K\x16\x04\xa0\x923\x04\xa0\\g\x04\x80\x7fb\x04`'z\x04\xa0_y\x04 x{\x04\x80\\\x19\x04 )\x18\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1514
(g1515
g1516
g1517
S'b'
tRp1969
(I1
(I18
I1
tg1524
I00
S'\xd4\x17&@+\xab\xf8?&\xc2\t@\x0e\x96\xe7?\xf6\x81%@\xd6\nu@\xb1\x93s@\xa9\x1aK@\xf0\xa8\x8f@c<T@\xcc\xa2\x81@?\xa2\xd6@\x046\xe0@Y\xad\x97@\xcf\xe2\xb4@\xc5g\xc1@}V\xe2@\x8a\xb1\xbe@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1522
g1514
(g1515
g1516
g1517
S'b'
tRp1970
(I1
(I18
I1
tg1524
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1514
(g1515
g1516
g1517
S'b'
tRp1971
(I1
(I18
I1
tg1520
I00
S' \xe94\x01\xc0\x02\x94\x018\xec4\x01\xe8\xe74\x01`r\xa7\x01\xf0\x05\x9d\x01\xf0\x05\x9d\x01\xf0\x05\x9d\x01\xf0\xe84\x018\xec4\x018\xec4\x01`r\xa7\x01 \xe94\x018\xec4\x01\xf0\xe84\x01\xc0\x02\x94\x01\xe8\xe74\x01\xc0\x02\x94\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1527
g1514
(g1515
g1516
g1517
S'b'
tRp1972
(I1
(I18
I1
tg1524
I00
S'\x00\x00\xe0@\x00\x00@@\x00\x00\xc0@\x00\x00\x80A\x00\x00\x80?\x00\x00@A\x00\x00\x80@\x00\x00\xa0@\x00\x00\x00A\x00\x00\x00\x00\x00\x00\x00@\x00\x00pA\x00\x00\x10A\x00\x00\x88A\x00\x00PA\x00\x000A\x00\x00`A\x00\x00 A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1514
(g1515
g1516
g1517
S'b'
tRp1973
(I1
(I18
I1
tg1524
I00
S':\xac\xe9?R\xc3a?\xd8\xfb\x02?yt(?\xd1\x10\x9e@\xeeK\xf1?\xff\x0f5@I\x18\x01@\\*=@W\xcc\xcb@XN7@\x93\xa0m@\xebA\xc3@\xcb\x82\x8e@r\xed\xb1@\x12:`@L\x82\x18@\x07i\xa4@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1974
(dp1975
g1532
(dp1976
g1522
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1527
I01
ssg1534
g1962
sg1535
(lp1977
g1522
ag1527
ag19
ag20
ag21
ag22
ag23
asg1537
(lp1978
I18
aI1
asbsg1539
g1540
sg1541
g1542
(g1516
(I0
tS'b'
tRp1979
(I1
(I18
I1
tg1520
I00
(lp1980
I9
aI4
aI10
aI1
aI6
aI7
aI2
aI0
aI8
aI12
aI17
aI15
aI5
aI14
aI16
aI11
aI3
aI13
atbsg1545
I01
sg1546
I1
sg1547
I-1
sg1548
(lp1981
g1
(g1550
g1512
(dp1982
g1327
g1408
sVY
I2
sg1329
I2
sg1330
g1409
sg1338
I4
sg1335
I4
sg1336
g1352
sVX
I3
sg1332
I0
sg1340
g1354
sg1342
I0
sg1343
g1375
stRp1983
ag1
(g1550
g1512
(dp1984
g1327
g1371
sVY
I2
sg1329
I2
sg1330
g1372
sg1338
I6
sg1335
I6
sg1336
g1362
sVX
I2
sg1332
I0
sg1340
g1354
sg1342
I0
sg1343
g1375
stRp1985
ag1
(g1550
g1512
(dp1986
g1327
g1399
sVY
I5
sg1329
I2
sg1330
g1400
sg1338
I3
sg1335
I3
sg1336
g1383
sVX
I4
sg1332
I0
sg1340
g1385
sg1342
I0
sg1343
g1403
stRp1987
ag1
(g1550
g1512
(dp1988
g1327
g1485
sVY
I2
sg1329
I2
sg1330
g1486
sg1338
I1
sg1335
I1
sg1336
g1365
sVX
I5
sg1332
I0
sg1340
g1385
sg1342
I0
sg1343
g1403
stRp1989
ag1
(g1550
g1512
(dp1990
g1327
g1349
sVY
I3
sg1329
I3
sg1330
g1350
sg1338
I9
sg1335
I9
sg1336
g1352
sVX
I8
sg1332
g1337
sg1340
g1354
sg1342
I0
sg1343
g1355
stRp1991
ag1
(g1550
g1512
(dp1992
g1327
g1453
sVY
I5
sg1329
I3
sg1330
g1454
sg1338
I5
sg1335
I5
sg1336
g1385
sVX
I6
sg1332
g1337
sg1340
g1354
sg1342
I0
sg1343
g1355
stRp1993
ag1
(g1550
g1512
(dp1994
g1327
g1380
sVY
I7
sg1329
I3
sg1330
g1381
sg1338
I5
sg1335
I5
sg1336
g1383
sVX
I7
sg1332
g1362
sg1340
g1385
sg1342
I0
sg1343
g1386
stRp1995
ag1
(g1550
g1512
(dp1996
g1327
g1391
sVY
I5
sg1329
I3
sg1330
g1392
sg1338
I5
sg1335
I5
sg1336
g1354
sVX
I4
sg1332
g1352
sg1340
g1385
sg1342
I0
sg1343
g1386
stRp1997
ag1
(g1550
g1512
(dp1998
g1327
g1416
sVY
I5
sg1329
I3
sg1330
g1417
sg1338
I8
sg1335
I8
sg1336
g1352
sVX
I5
sg1332
g1354
sg1340
g1420
sg1342
I0
sg1343
g1344
stRp1999
ag1
(g1550
g1512
(dp2000
g1327
g1328
sVY
I2
sg1329
I3
sg1330
g1331
sg1338
I3
sg1335
I3
sg1336
g1337
sVX
I4
sg1332
g1333
sg1340
g1341
sg1342
I0
sg1343
g1344
stRp2001
ag1
(g1550
g1512
(dp2002
g1327
g1360
sVY
I5
sg1329
I4
sg1330
g1361
sg1338
I3
sg1335
I3
sg1336
g1337
sVX
I5
sg1332
g1362
sg1340
g1365
sg1342
g1341
sg1343
g1366
stRp2003
ag1
(g1550
g1512
(dp2004
g1327
g1477
sVY
I3
sg1329
I4
sg1330
g1478
sg1338
I9
sg1335
I9
sg1336
g1362
sVX
I3
sg1332
g1385
sg1340
g1354
sg1342
g1429
sg1343
g1366
stRp2005
ag1
(g1550
g1512
(dp2006
g1327
g1425
sVY
I6
sg1329
I4
sg1330
g1426
sg1338
I4
sg1335
I4
sg1336
g1333
sVX
I3
sg1332
g1341
sg1340
g1362
sg1342
g1429
sg1343
g1430
stRp2007
ag1
(g1550
g1512
(dp2008
g1327
g1493
sVY
I3
sg1329
I4
sg1330
g1494
sg1338
I3
sg1335
I3
sg1336
g1365
sVX
I3
sg1332
g1429
sg1340
g1341
sg1342
g1352
sg1343
g1430
stRp2009
ag1
(g1550
g1512
(dp2010
g1327
g1461
sVY
I2
sg1329
I4
sg1330
g1462
sg1338
I8
sg1335
I8
sg1336
g1429
sVX
I9
sg1332
g1383
sg1340
g1385
sg1342
g1362
sg1343
g1448
stRp2011
ag1
(g1550
g1512
(dp2012
g1327
g1444
sVY
I3
sg1329
I4
sg1330
g1445
sg1338
I6
sg1335
I6
sg1336
g1337
sVX
I2
sg1332
g1383
sg1340
g1341
sg1342
g1352
sg1343
g1448
stRp2013
ag1
(g1550
g1512
(dp2014
g1327
g1469
sVY
I2
sg1329
I4
sg1330
g1470
sg1338
I1
sg1335
I1
sg1336
g1362
sVX
I8
sg1332
g1337
sg1340
g1385
sg1342
g1333
sg1343
g1439
stRp2015
ag1
(g1550
g1512
(dp2016
g1327
g1435
sVY
I2
sg1329
I4
sg1330
g1436
sg1338
I6
sg1335
I6
sg1336
g1352
sVX
I3
sg1332
g1337
sg1340
g1341
sg1342
g1354
sg1343
g1439
stRp2017
asg1563
Nsg1564
I13
sg1565
I18
sg1566
I0
sg1567
I18
sg1568
I01
sbasS'savePickle'
p2018
I00
sb.