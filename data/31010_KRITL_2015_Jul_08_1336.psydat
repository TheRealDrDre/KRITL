ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cdata/31010_KRITL_2015_Jul_08_1336
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'KRITL'
p11
sS'dataNames'
p12
(lp13
S'practice_encoding.keys'
p14
aS'practice_encoding.rt'
p15
aS'practice_execution.keys'
p16
aS'practice_execution.corr'
p17
aS'practice_execution.rt'
p18
aS'encoding.keys'
p19
aS'encoding.rt'
p20
aS'execution.keys'
p21
aS'execution.corr'
p22
aS'execution.rt'
p23
asS'autoLog'
p24
I01
sS'extraInfo'
p25
(dp26
S'date'
p27
V2015_Jul_08_1336
p28
sS'frameRate'
p29
cnumpy.core.multiarray
scalar
p30
(cnumpy
dtype
p31
(S'f8'
I0
I1
tRp32
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x08\x93\xe1\x19fXv@'
tRp33
sS'expName'
p34
g11
sVsession
p35
V001
p36
sVparticipant
p37
V31010
p38
ssS'loopsUnfinished'
p39
(lp40
sS'saveWideText'
p41
I01
sS'thisEntry'
p42
(dp43
sS'version'
p44
S''
sS'_paramNamesSoFar'
p45
(lp46
Voperationc
p47
aVoperationb
p48
aVoperationa
p49
aVcorrectresponse
p50
aVvaluey
p51
aVoperationd
p52
aVcondition
p53
aVvaluex
p54
aVRule
p55
aVOperatora
p56
aVLength
p57
aVIntermediate
p58
aVCorrectResponse
p59
aVResult
p60
aVY
aVX
aVOperatorc
p61
aVOperatorb
p62
aVOperatord
p63
aVStructure
p64
asS'entries'
p65
(lp66
(dp67
g18
F13.445558455394348
sg29
g33
sg17
I1
sg47
VADD
p68
sg48
Vtriple 
p69
sg49
Vhalf
p70
sg35
g36
sg50
I8
sS'practice_trials.thisTrialN'
p71
I0
sg52
I0
sS'practice_trials.thisRepN'
p72
I0
sg37
g38
sg53
I3
sg27
g28
sg16
S'8'
sg14
(lp73
S'space'
p74
asS'practice_trials.thisIndex'
p75
I3
sS'practice_trials.thisN'
p76
I0
sg34
g11
sg15
(lp77
F6.2885524879966397
asg51
I2
sg54
I4
sa(dp78
g18
F2.9049135753593873
sg29
g33
sg17
I1
sg47
Vincrease
p79
sg48
VDIVIDE
p80
sg49
Vtriple
p81
sg35
g36
sg50
I3
sS'practice_trials.thisTrialN'
p82
I1
sg52
I0
sS'practice_trials.thisRepN'
p83
I0
sg37
g38
sg53
I3
sg27
g28
sg16
S'3'
sg14
(lp84
S'space'
p85
asS'practice_trials.thisIndex'
p86
I4
sS'practice_trials.thisN'
p87
I1
sg34
g11
sg15
(lp88
F13.149742691981373
asg51
I3
sg54
I2
sa(dp89
g18
F1.3047283834021073
sg29
g33
sg17
I1
sg47
I0
sg48
Vdecrease
p90
sg49
VTIMES
p91
sg35
g36
sg50
I8
sS'practice_trials.thisTrialN'
p92
I2
sg52
I0
sS'practice_trials.thisRepN'
p93
I0
sg37
g38
sg53
I2
sg27
g28
sg16
S'8'
sg14
(lp94
S'space'
p95
asS'practice_trials.thisIndex'
p96
I1
sS'practice_trials.thisN'
p97
I2
sg34
g11
sg15
(lp98
F1.7389351051533595
asg51
I3
sg54
I3
sa(dp99
g18
F1.861300730612129
sg29
g33
sg17
I1
sg47
I0
sg48
g68
sg49
g90
sg35
g36
sg50
I7
sS'practice_trials.thisTrialN'
p100
I3
sg52
I0
sS'practice_trials.thisRepN'
p101
I0
sg37
g38
sg53
I2
sg27
g28
sg16
S'7'
sg14
(lp102
S'space'
p103
asS'practice_trials.thisIndex'
p104
I0
sS'practice_trials.thisN'
p105
I3
sg34
g11
sg15
(lp106
F6.6535459368024021
asg51
I5
sg54
I3
sa(dp107
g18
F11.89324189623585
sg29
g33
sg17
I1
sg47
g79
sg48
g80
sg49
Vdouble
p108
sg35
g36
sg50
I9
sS'practice_trials.thisTrialN'
p109
I4
sg52
g81
sS'practice_trials.thisRepN'
p110
I0
sg37
g38
sg53
I4
sg27
g28
sg16
S'9'
sg14
(lp111
S'space'
p112
asS'practice_trials.thisIndex'
p113
I5
sS'practice_trials.thisN'
p114
I4
sg34
g11
sg15
(lp115
F10.415236864006147
asg51
I8
sg54
I8
sa(dp116
g18
F1.6999253688554745
sg29
g33
sg17
I1
sg47
I0
sg48
g68
sg49
g70
sg35
g36
sg50
I7
sS'practice_trials.thisTrialN'
p117
I5
sg52
I0
sS'practice_trials.thisRepN'
p118
I0
sg37
g38
sg53
I2
sg27
g28
sg16
S'7'
sg14
(lp119
S'space'
p120
asS'practice_trials.thisIndex'
p121
I2
sS'practice_trials.thisN'
p122
I5
sg34
g11
sg15
(lp123
F1.8722401281411294
asg51
I5
sg54
I4
sa(dp124
S'block.thisTrialN'
p125
I0
sS'block.thisRepN'
p126
I0
sg29
g33
sS'block.thisN'
p127
I0
sg55
(S'INCREASE'
S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp128
sg27
g28
sg57
I3
sg58
(I3
I1
I2
tp129
sg22
I1
sg20
F9.216348152665887
sg23
F3.2354234041995369
sVY
I2
sVX
I9
sg61
Vthird
p130
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p131
sg34
g11
sg60
I2
sg56
VSUBTRACT
p132
sg59
I2
sS'block.thisIndex'
p133
I7
sg62
Vincrease
p134
sg63
I0
sg64
VUBUxy
p135
sa(dp136
S'block.thisTrialN'
p137
I1
sS'block.thisRepN'
p138
I0
sg29
g33
sS'block.thisN'
p139
I1
sg55
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp140
sg27
g28
sg57
I3
sg58
(I2
I6
I5
tp141
sg22
I0
sg20
F9.2849831284256652
sg23
F5.0308810682035983
sVY
I4
sVX
I8
sg61
VDIVIDE
p142
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p143
sg34
g11
sg60
I5
sg56
Vtriple
p144
sg59
I5
sS'block.thisIndex'
p145
I8
sg62
Vdecrease
p146
sg63
I0
sg64
VUUBxy
p147
sa(dp148
S'block.thisTrialN'
p149
I2
sS'block.thisRepN'
p150
I0
sg29
g33
sS'block.thisN'
p151
I2
sg55
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp152
sg27
g28
sg57
I4
sg58
(I2
I3
I6
I2
tp153
sg22
I1
sg20
F6.9498482910858002
sg23
F3.8624528764921706
sVY
I3
sVX
I6
sg61
g134
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p154
sg34
g11
sg60
I2
sg56
Vdouble
p155
sg59
I2
sS'block.thisIndex'
p156
I10
sg62
g142
sg63
g130
sg64
VBUUUxy
p157
sa(dp158
S'block.thisTrialN'
p159
I3
sS'block.thisRepN'
p160
I0
sg29
g33
sS'block.thisN'
p161
I3
sg55
(S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp162
sg27
g28
sg57
I2
sg58
(I6
I2
tp163
sg22
I1
sg20
F1.059902004286414
sg23
F3.1275993858289439
sVY
I4
sVX
I5
sg61
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p164
sg34
g11
sg60
I2
sg56
g134
sg59
I2
sS'block.thisIndex'
p165
I1
sg62
g132
sg63
I0
sg64
VBUxy
p166
sa(dp167
S'block.thisTrialN'
p168
I4
sS'block.thisRepN'
p169
I0
sg29
g33
sS'block.thisN'
p170
I4
sg55
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp171
sg27
g28
sg57
I4
sg58
(I4
I1
I2
I6
tp172
sg22
I1
sg20
F7.1575839223805815
sg23
F4.4224399144004565
sVY
I3
sVX
I5
sg61
g132
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p173
sg34
g11
sg60
I6
sg56
g155
sg59
I6
sS'block.thisIndex'
p174
I15
sg62
g144
sg63
g146
sg64
VUUBUxy
p175
sa(dp176
S'block.thisTrialN'
p177
I5
sS'block.thisRepN'
p178
I0
sg29
g33
sS'block.thisN'
p179
I5
sg55
(S'TIMES'
S'INCREASE'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp180
sg27
g28
sg57
I4
sg58
(I6
I3
I4
I8
tp181
sg22
I1
sg20
F8.869597412791336
sg23
F6.2149345754296519
sVY
I2
sVX
I2
sg61
Vhalf
p182
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p183
sg34
g11
sg60
I8
sg56
g134
sg59
I8
sS'block.thisIndex'
p184
I11
sg62
VTIMES
p185
sg63
g144
sg64
g157
sa(dp186
S'block.thisTrialN'
p187
I6
sS'block.thisRepN'
p188
I0
sg29
g33
sS'block.thisN'
p189
I6
sg55
(S'DOUBLE'
S'TIMES'
S'x'
S'y'
tp190
sg27
g28
sg57
I2
sg58
(I4
I8
tp191
sg22
I1
sg20
F0.93290007812902331
sg23
F2.7442995812161826
sVY
I2
sVX
I2
sg61
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p192
sg34
g11
sg60
I8
sg56
g185
sg59
I8
sS'block.thisIndex'
p193
I3
sg62
g155
sg63
I0
sg64
VUBxy
p194
sa(dp195
S'block.thisTrialN'
p196
I7
sS'block.thisRepN'
p197
I0
sg29
g33
sS'block.thisN'
p198
I7
sg55
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp199
sg27
g28
sg57
I4
sg58
(I6
I3
I9
I8
tp200
sg22
I1
sg20
F7.1580150788358878
sg23
F3.7501951325102709
sVY
I2
sVX
I4
sg61
g182
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p201
sg34
g11
sg60
I8
sg56
g144
sg59
I8
sS'block.thisIndex'
p202
I16
sg62
g146
sg63
VADD
p203
sg64
VUUUBxy
p204
sa(dp205
S'block.thisTrialN'
p206
I8
sS'block.thisRepN'
p207
I0
sg29
g33
sS'block.thisN'
p208
I8
sg55
(S'ADD'
S'THIRD'
S'x'
S'y'
tp209
sg27
g28
sg57
I2
sg58
(I1
I7
tp210
sg22
I1
sg20
F0.7562443260976579
sg23
F2.2132554605486803
sVY
I6
sVX
I3
sg61
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p211
sg34
g11
sg60
I7
sg56
g130
sg59
I7
sS'block.thisIndex'
p212
I0
sg62
g203
sg63
I0
sg64
g166
sa(dp213
S'block.thisTrialN'
p214
I9
sS'block.thisRepN'
p215
I0
sg29
g33
sS'block.thisN'
p216
I9
sg55
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp217
sg27
g28
sg57
I4
sg58
(I2
I6
I2
I3
tp218
sg22
I1
sg20
F9.0452899065276142
sg23
F8.0197298565180972
sVY
I3
sVX
I4
sg61
g144
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p219
sg34
g11
sg60
I3
sg56
g142
sg59
I3
sS'block.thisIndex'
p220
I12
sg62
g134
sg63
g182
sg64
VUBUUxy
p221
sa(dp222
S'block.thisTrialN'
p223
I10
sS'block.thisRepN'
p224
I0
sg29
g33
sS'block.thisN'
p225
I10
sg55
(S'TIMES'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp226
sg27
g28
sg57
I3
sg58
(I6
I2
I4
tp227
sg22
I1
sg20
F3.0603382935514674
sg23
F1.9425706437905319
sVY
I2
sVX
I3
sg61
g155
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p228
sg34
g11
sg60
I4
sg56
g130
sg59
I4
sS'block.thisIndex'
p229
I5
sg62
g185
sg63
I0
sg64
VBUUxy
p230
sa(dp231
S'block.thisTrialN'
p232
I11
sS'block.thisRepN'
p233
I0
sg29
g33
sS'block.thisN'
p234
I11
sg55
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp235
sg27
g28
sg57
I4
sg58
(I4
I2
I1
I3
tp236
sg22
I1
sg20
F9.7012516882678028
sg23
F3.5436359424202237
sVY
I5
sVX
I9
sg61
g182
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p237
sg34
g11
sg60
I3
sg56
g146
sg59
I3
sS'block.thisIndex'
p238
I17
sg62
g144
sg63
g132
sg64
g204
sa(dp239
S'block.thisTrialN'
p240
I12
sS'block.thisRepN'
p241
I0
sg29
g33
sS'block.thisN'
p242
I12
sg55
(S'INCREASE'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp243
sg27
g28
sg57
I3
sg58
(I6
I8
I9
tp244
sg22
I1
sg20
F4.9965747014502995
sg23
F7.9922597149561625
sVY
I2
sVX
I2
sg61
g144
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p245
sg34
g11
sg60
I9
sg56
g203
sg59
I9
sS'block.thisIndex'
p246
I6
sg62
g134
sg63
I0
sg64
g135
sa(dp247
S'block.thisTrialN'
p248
I13
sS'block.thisRepN'
p249
I0
sg29
g33
sS'block.thisN'
p250
I13
sg55
(S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp251
sg27
g28
sg57
I3
sg58
(I4
I12
I4
tp252
sg22
I1
sg20
F2.819447414833121
sg23
F7.766039790265495
sVY
I3
sVX
I8
sg61
g182
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p253
sg34
g11
sg60
I4
sg56
g144
sg59
I4
sS'block.thisIndex'
p254
I4
sg62
g142
sg63
I0
sg64
g230
sa(dp255
S'block.thisTrialN'
p256
I14
sS'block.thisRepN'
p257
I0
sg29
g33
sS'block.thisN'
p258
I14
sg55
(S'DOUBLE'
S'ADD'
S'x'
S'y'
tp259
sg27
g28
sg57
I2
sg58
(I4
I8
tp260
sg22
I1
sg20
F2.5506655036588199
sg23
F1.8758368627168238
sVY
I2
sVX
I2
sg61
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p261
sg34
g11
sg60
I8
sg56
g203
sg59
I8
sS'block.thisIndex'
p262
I2
sg62
g155
sg63
I0
sg64
g194
sa(dp263
S'block.thisTrialN'
p264
I15
sS'block.thisRepN'
p265
I0
sg29
g33
sS'block.thisN'
p266
I15
sg55
(S'THIRD'
S'INCREASE'
S'ADD'
S'DOUBLE'
S'x'
S'y'
tp267
sg27
g28
sg57
I4
sg58
(I16
I20
I21
I7
tp268
sg22
I1
sg20
F8.1486760930274613
sg23
F8.9828652947326191
sVY
I4
sVX
I8
sg61
g203
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p269
sg34
g11
sg60
I7
sg56
g134
sg59
I7
sS'block.thisIndex'
p270
I14
sg62
g130
sg63
g155
sg64
g175
sa(dp271
S'block.thisTrialN'
p272
I16
sS'block.thisRepN'
p273
I0
sg29
g33
sS'block.thisN'
p274
I16
sg55
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp275
sg27
g28
sg57
I3
sg58
(I2
I3
I1
tp276
sg22
I1
sg20
F3.6992084857192822
sg23
F2.7914920511539094
sVY
I6
sVX
I8
sg61
g132
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p277
sg34
g11
sg60
I1
sg56
g134
sg59
I1
sS'block.thisIndex'
p278
I9
sg62
g130
sg63
I0
sg64
g147
sa(dp279
S'block.thisTrialN'
p280
I17
sS'block.thisRepN'
p281
I0
sg29
g33
sS'block.thisN'
p282
I17
sg55
(S'THIRD'
S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp283
sg27
g28
sg57
I4
sg58
(I8
I4
I12
I4
tp284
sg22
I1
sg20
F8.0217025684250984
sg23
F5.0289743985631503
sVY
I3
sVX
I7
sg61
g182
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p285
sg34
g11
sg60
I4
sg56
g185
sg59
I4
sS'block.thisIndex'
p286
I13
sg62
g130
sg63
g134
sg64
g221
sa(dp287
S'block.thisTrialN'
p288
I0
sS'block.thisRepN'
p289
I0
sg29
g33
sS'block.thisN'
p290
I0
sVRule
p291
(S'DOUBLE'
S'ADD'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp292
sg27
g28
sVLength
p293
I4
sVIntermediate
p294
(I1
I2
I4
I8
tp295
sg22
I1
sg20
F9.8865025101404171
sg23
F3.4466493497020565
sVY
I2
sVX
I3
sVOperatorc
p296
Vincrease
p297
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p298
sg34
g11
sVResult
p299
I8
sVOperatora
p300
VADD
p301
sVCorrectResponse
p302
I8
sS'block.thisIndex'
p303
I12
sVOperatorb
p304
Vdouble
p305
sVOperatord
p306
Vthird
p307
sVStructure
p308
VUBUUxy
p309
sa(dp310
S'block.thisTrialN'
p311
I1
sS'block.thisRepN'
p312
I0
sg29
g33
sS'block.thisN'
p313
I1
sg291
(S'DIVIDE'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp314
sg27
g28
sg293
I3
sg294
(I9
I8
I4
tp315
sg22
I1
sg20
F10.49994131483254
sg23
F3.7836997536069248
sVY
I2
sVX
I3
sg296
Vtriple
p316
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p317
sg34
g11
sg299
I4
sg300
Vdecrease
p318
sg302
I4
sS'block.thisIndex'
p319
I5
sg304
VDIVIDE
p320
sg306
I0
sg308
VBUUxy
p321
sa(dp322
S'block.thisTrialN'
p323
I2
sS'block.thisRepN'
p324
I0
sg29
g33
sS'block.thisN'
p325
I2
sg291
(S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp326
sg27
g28
sg293
I4
sg294
(I6
I18
I17
I8
tp327
sg22
I1
sg20
F7.8119624017854221
sg23
F6.7746495741594117
sVY
I9
sVX
I3
sg296
g316
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p328
sg34
g11
sg299
I8
sg300
g318
sg302
I8
sS'block.thisIndex'
p329
I11
sg304
VSUBTRACT
p330
sg306
g305
sg308
VBUUUxy
p331
sa(dp332
S'block.thisTrialN'
p333
I3
sS'block.thisRepN'
p334
I0
sg29
g33
sS'block.thisN'
p335
I3
sg291
(S'THIRD'
S'HALF'
S'ADD'
S'x'
S'y'
tp336
sg27
g28
sg293
I3
sg294
(I6
I3
I1
tp337
sg22
I1
sg20
F4.1652677464589942
sg23
F0.98277495719958097
sVY
I3
sVX
I3
sg296
g301
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p338
sg34
g11
sg299
I1
sg300
Vhalf
p339
sg302
I1
sS'block.thisIndex'
p340
I9
sg304
g307
sg306
I0
sg308
VUUBxy
p341
sa(dp342
S'block.thisTrialN'
p343
I4
sS'block.thisRepN'
p344
I0
sg29
g33
sS'block.thisN'
p345
I4
sg291
(S'ADD'
S'HALF'
S'THIRD'
S'x'
S'y'
tp346
sg27
g28
sg293
I3
sg294
(I2
I1
I9
tp347
sg22
I1
sg20
F1.9582671342941467
sg23
F1.3953879261971451
sVY
I8
sVX
I6
sg296
g307
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p348
sg34
g11
sg299
I9
sg300
g339
sg302
I9
sS'block.thisIndex'
p349
I4
sg304
g301
sg306
I0
sg308
g321
sa(dp350
S'block.thisTrialN'
p351
I5
sS'block.thisRepN'
p352
I0
sg29
g33
sS'block.thisN'
p353
I5
sg291
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'THIRD'
S'x'
S'y'
tp354
sg27
g28
sg293
I4
sg294
(I2
I1
I2
I8
tp355
sg22
I1
sg20
F6.5655753047321923
sg23
F5.5743941652763169
sVY
I6
sVX
I6
sg296
g318
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p356
sg34
g11
sg299
I8
sg300
g305
sg302
I8
sS'block.thisIndex'
p357
I10
sg304
g301
sg306
g307
sg308
g331
sa(dp358
S'block.thisTrialN'
p359
I6
sS'block.thisRepN'
p360
I0
sg29
g33
sS'block.thisN'
p361
I6
sg291
(S'DIVIDE'
S'INCREASE'
S'x'
S'y'
tp362
sg27
g28
sg293
I2
sg294
(I4
I2
tp363
sg22
I1
sg20
F3.9571143040375318
sg23
F2.0716564928588923
sVY
I2
sVX
I3
sg296
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p364
sg34
g11
sg299
I2
sg300
g297
sg302
I2
sS'block.thisIndex'
p365
I0
sg304
g320
sg306
I0
sg308
VBUxy
p366
sa(dp367
S'block.thisTrialN'
p368
I7
sS'block.thisRepN'
p369
I0
sg29
g33
sS'block.thisN'
p370
I7
sg291
(S'THIRD'
S'TIMES'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp371
sg27
g28
sg293
I4
sg294
(I1
I2
I6
I2
tp372
sg22
I1
sg20
F7.8943013092502952
sg23
F3.1250767783494666
sVY
I3
sVX
I2
sg296
g305
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p373
sg34
g11
sg299
I2
sg300
VTIMES
p374
sg302
I2
sS'block.thisIndex'
p375
I13
sg304
g307
sg306
g318
sg308
g309
sa(dp376
S'block.thisTrialN'
p377
I8
sS'block.thisRepN'
p378
I0
sg29
g33
sS'block.thisN'
p379
I8
sg291
(S'HALF'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp380
sg27
g28
sg293
I3
sg294
(I9
I12
I6
tp381
sg22
I1
sg20
F2.2133598277869169
sg23
F2.7576202627096791
sVY
I3
sVX
I3
sg296
g316
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p382
sg34
g11
sg299
I6
sg300
g301
sg302
I6
sS'block.thisIndex'
p383
I6
sg304
g339
sg306
I0
sg308
VUBUxy
p384
sa(dp385
S'block.thisTrialN'
p386
I9
sS'block.thisRepN'
p387
I0
sg29
g33
sS'block.thisN'
p388
I9
sg291
(S'THIRD'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp389
sg27
g28
sg293
I4
sg294
(I18
I2
I3
I1
tp390
sg22
I1
sg20
F7.3009119643538725
sg23
F2.9666986383963376
sVY
I9
sVX
I9
sg296
g320
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p391
sg34
g11
sg299
I1
sg300
Vincrese
p392
sg302
I1
sS'block.thisIndex'
p393
I15
sg304
g307
sg306
g305
sg308
VUUBUxy
p394
sa(dp395
S'block.thisTrialN'
p396
I10
sS'block.thisRepN'
p397
I0
sg29
g33
sS'block.thisN'
p398
I10
sg291
(S'THIRD'
S'DOUBLE'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp399
sg27
g28
sg293
I4
sg294
(I5
I12
I24
I8
tp400
sg22
I1
sg20
F8.2934601435263176
sg23
F7.5574668257613666
sVY
I7
sVX
I6
sg296
g301
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p401
sg34
g11
sg299
I8
sg300
g305
sg302
I8
sS'block.thisIndex'
p402
I14
sg304
g307
sg306
g318
sg308
g394
sa(dp403
S'block.thisTrialN'
p404
I11
sS'block.thisRepN'
p405
I0
sg29
g33
sS'block.thisN'
p406
I11
sg291
(S'INCREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp407
sg27
g28
sg293
I3
sg294
(I2
I6
I7
tp408
sg22
I1
sg20
F2.2309674363932572
sg23
F3.5728064145077951
sVY
I3
sVX
I6
sg296
g320
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p409
sg34
g11
sg299
I7
sg300
g316
sg302
I7
sS'block.thisIndex'
p410
I8
sg304
g297
sg306
I0
sg308
g341
sa(dp411
S'block.thisTrialN'
p412
I12
sS'block.thisRepN'
p413
I0
sg29
g33
sS'block.thisN'
p414
I12
sg291
(S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp415
sg27
g28
sg293
I2
sg294
(I5
I3
tp416
sg22
I1
sg20
F0.94955640501575544
sg23
F2.7570734468172304
sVY
I2
sVX
I6
sg296
I0
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p417
sg34
g11
sg299
I3
sg300
g318
sg302
I3
sS'block.thisIndex'
p418
I1
sg304
g330
sg306
I0
sg308
g366
sa(dp419
S'block.thisTrialN'
p420
I13
sS'block.thisRepN'
p421
I0
sg29
g33
sS'block.thisN'
p422
I13
sg291
(S'INCREASE'
S'ADD'
S'x'
S'y'
tp423
sg27
g28
sg293
I2
sg294
(I5
I6
tp424
sg22
I1
sg20
F1.5434538986010011
sg23
F1.2871402794844471
sVY
I2
sVX
I3
sg296
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p425
sg34
g11
sg299
I6
sg300
g301
sg302
I6
sS'block.thisIndex'
p426
I3
sg304
g297
sg306
I0
sg308
VUBxy
p427
sa(dp428
S'block.thisTrialN'
p429
I14
sS'block.thisRepN'
p430
I0
sg29
g33
sS'block.thisN'
p431
I14
sg291
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp432
sg27
g28
sg293
I4
sg294
(I3
I4
I12
I6
tp433
sg22
I1
sg20
F4.8033902585448232
sg23
F4.5346305895945989
sVY
I3
sVX
I9
sg296
g297
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p434
sg34
g11
sg299
I6
sg300
g316
sg302
I6
sS'block.thisIndex'
p435
I16
sg304
g339
sg306
g320
sg308
VUUUBxy
p436
sa(dp437
S'block.thisTrialN'
p438
I15
sS'block.thisRepN'
p439
I0
sg29
g33
sS'block.thisN'
p440
I15
sg291
(S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp441
sg27
g28
sg293
I3
sg294
(I4
I2
I3
tp442
sg22
I1
sg20
F6.3111160006083082
sg23
F4.2312795115285553
sVY
I2
sVX
I8
sg296
g339
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p443
sg34
g11
sg299
I3
sg300
g330
sg302
I3
sS'block.thisIndex'
p444
I7
sg304
g297
sg306
I0
sg308
g384
sa(dp445
S'block.thisTrialN'
p446
I16
sS'block.thisRepN'
p447
I0
sg29
g33
sS'block.thisN'
p448
I16
sg291
(S'THIRD'
S'DOUBLE'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp449
sg27
g28
sg293
I4
sg294
(I8
I9
I18
I6
tp450
sg22
I1
sg20
F5.6686654989025556
sg23
F8.6143760567065328
sVY
I4
sVX
I2
sg296
g297
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p451
sg34
g11
sg299
I6
sg300
g305
sg302
I6
sS'block.thisIndex'
p452
I17
sg304
g307
sg306
g374
sg308
g436
sa(dp453
S'block.thisTrialN'
p454
I17
sS'block.thisRepN'
p455
I0
sg29
g33
sS'block.thisN'
p456
I17
sg291
(S'DECREASE'
S'DIVIDE'
S'x'
S'y'
tp457
sg27
g28
sg293
I2
sg294
(I2
I1
tp458
sg22
I1
sg20
F0.69304260614444502
sg23
F2.4716040696948767
sVY
I4
sVX
I8
sg296
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p459
sg34
g11
sg299
I1
sg300
g320
sg302
I1
sS'block.thisIndex'
p460
I2
sg304
g318
sg306
I0
sg308
g427
sa(dp461
S'block.thisTrialN'
p462
I0
sS'block.thisRepN'
p463
I0
sg29
g33
sS'block.thisN'
p464
I0
sVRule
p465
(S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp466
sg27
g28
sVLength
p467
I2
sVIntermediate
p468
(I12
I2
tp469
sg22
I1
sg20
F2.5581501745327841
sg23
F2.8377503487863578
sVY
I6
sVX
I6
sVOperatorc
p470
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p471
sg34
g11
sVResult
p472
I2
sVOperatora
p473
Vdouble
p474
sVCorrectResponse
p475
I2
sS'block.thisIndex'
p476
I1
sVOperatorb
p477
VDIVIDE
p478
sVOperatord
p479
I0
sVStructure
p480
VBUxy
p481
sa(dp482
S'block.thisTrialN'
p483
I1
sS'block.thisRepN'
p484
I0
sg29
g33
sS'block.thisN'
p485
I1
sg465
(S'ADD'
S'THIRD'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp486
sg27
g28
sg467
I4
sg468
(I2
I3
I1
I7
tp487
sg22
I1
sg20
F4.7427453648124356
sg23
F3.0758366574009415
sVY
I6
sVX
I4
sg470
Vincrease
p488
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p489
sg34
g11
sg472
I7
sg473
Vthird
p490
sg475
I7
sS'block.thisIndex'
p491
I10
sg477
VADD
p492
sg479
Vhalf
p493
sg480
VBUUUxy
p494
sa(dp495
S'block.thisTrialN'
p496
I2
sS'block.thisRepN'
p497
I0
sg29
g33
sS'block.thisN'
p498
I2
sg465
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp499
sg27
g28
sg467
I4
sg468
(I4
I12
I6
I5
tp500
sg22
I1
sg20
F3.2411509413796011
sg23
F4.8207802357792389
sVY
I2
sVX
I8
sg470
Vtriple
p501
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p502
sg34
g11
sg472
I5
sg473
g493
sg475
I5
sS'block.thisIndex'
p503
I16
sg477
Vdecrease
p504
sg479
g478
sg480
VUUUBxy
p505
sa(dp506
S'block.thisTrialN'
p507
I3
sS'block.thisRepN'
p508
I0
sg29
g33
sS'block.thisN'
p509
I3
sg465
(S'SUBTRACT'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp510
sg27
g28
sg467
I3
sg468
(I12
I6
I2
tp511
sg22
I1
sg20
F1.8149175344733521
sg23
F8.6786980991018936
sVY
I4
sVX
I4
sg470
g501
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p512
sg34
g11
sg472
I2
sg473
g493
sg475
I2
sS'block.thisIndex'
p513
I5
sg477
VSUBTRACT
p514
sg479
I0
sg480
VBUUxy
p515
sa(dp516
S'block.thisTrialN'
p517
I4
sS'block.thisRepN'
p518
I0
sg29
g33
sS'block.thisN'
p519
I4
sg465
(S'DOUBLE'
S'DECREASE'
S'SUBTRACT'
S'x'
S'y'
tp520
sg27
g28
sg467
I3
sg468
(I5
I4
I8
tp521
sg22
I1
sg20
F3.1091664205887355
sg23
F2.7265862365893554
sVY
I2
sVX
I7
sg470
g514
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p522
sg34
g11
sg472
I8
sg473
g504
sg475
I8
sS'block.thisIndex'
p523
I8
sg477
g474
sg479
I0
sg480
VUUBxy
p524
sa(dp525
S'block.thisTrialN'
p526
I5
sS'block.thisRepN'
p527
I0
sg29
g33
sS'block.thisN'
p528
I5
sg465
(S'INCREASE'
S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp529
sg27
g28
sg467
I3
sg468
(I3
I1
I2
tp530
sg22
I1
sg20
F3.5889761505532078
sg23
F2.1977249310584739
sVY
I3
sVX
I9
sg470
g490
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p531
sg34
g11
sg472
I2
sg473
g478
sg475
I2
sS'block.thisIndex'
p532
I7
sg477
g488
sg479
I0
sg480
VUBUxy
p533
sa(dp534
S'block.thisTrialN'
p535
I6
sS'block.thisRepN'
p536
I0
sg29
g33
sS'block.thisN'
p537
I6
sg465
(S'HALF'
S'TIMES'
S'x'
S'y'
tp538
sg27
g28
sg467
I2
sg468
(I16
I8
tp539
sg22
I1
sg20
F0.90216923027765006
sg23
F4.3102232329838444
sVY
I4
sVX
I4
sg470
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p540
sg34
g11
sg472
I8
sg473
VTIMES
p541
sg475
I8
sS'block.thisIndex'
p542
I3
sg477
g493
sg479
I0
sg480
VUBxy
p543
sa(dp544
S'block.thisTrialN'
p545
I7
sS'block.thisRepN'
p546
I0
sg29
g33
sS'block.thisN'
p547
I7
sg465
(S'DECREASE'
S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp548
sg27
g28
sg467
I4
sg468
(I2
I12
I4
I3
tp549
sg22
I1
sg20
F4.1174696043308359
sg23
F7.238009316381067
sVY
I6
sVX
I4
sg470
g541
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p550
sg34
g11
sg472
I3
sg473
g490
sg475
I3
sS'block.thisIndex'
p551
I14
sg477
g504
sg479
g493
sg480
VUUBUxy
p552
sa(dp553
S'block.thisTrialN'
p554
I8
sS'block.thisRepN'
p555
I0
sg29
g33
sS'block.thisN'
p556
I8
sg465
(S'DOUBLE'
S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp557
sg27
g28
sg467
I4
sg468
(I1
I3
I2
I4
tp558
sg22
I1
sg20
F5.6859350260929205
sg23
F5.6865892889036331
sVY
I4
sVX
I4
sg470
g501
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p559
sg34
g11
sg472
I4
sg473
g504
sg475
I4
sS'block.thisIndex'
p560
I17
sg477
g474
sg479
g478
sg480
g505
sa(dp561
S'block.thisTrialN'
p562
I9
sS'block.thisRepN'
p563
I0
sg29
g33
sS'block.thisN'
p564
I9
sg465
(S'ADD'
S'DOUBLE'
S'x'
S'y'
tp565
sg27
g28
sg467
I2
sg468
(I4
I8
tp566
sg22
I1
sg20
F0.85076545670744963
sg23
F1.6554023048956878
sVY
I4
sVX
I2
sg470
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p567
sg34
g11
sg472
I8
sg473
g474
sg475
I8
sS'block.thisIndex'
p568
I0
sg477
g492
sg479
I0
sg480
g481
sa(dp569
S'block.thisTrialN'
p570
I10
sS'block.thisRepN'
p571
I0
sg29
g33
sS'block.thisN'
p572
I10
sg465
(S'DIVIDE'
S'INCREASE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp573
sg27
g28
sg467
I4
sg468
(I2
I4
I5
I1
tp574
sg22
I1
sg20
F4.3080565006530378
sg23
F10.8221678067639
sVY
I5
sVX
I6
sg470
g474
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p575
sg34
g11
sg472
I1
sg473
g488
sg475
I1
sS'block.thisIndex'
p576
I11
sg477
g478
sg479
g490
sg480
g494
sa(dp577
S'block.thisTrialN'
p578
I11
sS'block.thisRepN'
p579
I0
sg29
g33
sS'block.thisN'
p580
I11
sg465
(S'DOUBLE'
S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp581
sg27
g28
sg467
I3
sg468
(I1
I3
I6
tp582
sg22
I1
sg20
F4.0050109962176066
sg23
F2.3409900105325505
sVY
I3
sVX
I4
sg470
g514
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p583
sg34
g11
sg472
I6
sg473
g501
sg475
I6
sS'block.thisIndex'
p584
I9
sg477
g474
sg479
I0
sg480
g524
sa(dp585
S'block.thisTrialN'
p586
I12
sS'block.thisRepN'
p587
I0
sg29
g33
sS'block.thisN'
p588
I12
sg465
(S'DOUBLE'
S'TRIPLE'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp589
sg27
g28
sg467
I4
sg468
(I8
I1
I3
I6
tp590
sg22
I1
sg20
F7.6550693562894594
sg23
F4.1998701055708807
sVY
I8
sVX
I9
sg470
g478
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p591
sg34
g11
sg472
I6
sg473
g501
sg475
I6
sS'block.thisIndex'
p592
I15
sg477
g474
sg479
g504
sg480
g552
sa(dp593
S'block.thisTrialN'
p594
I13
sS'block.thisRepN'
p595
I0
sg29
g33
sS'block.thisN'
p596
I13
sg465
(S'HALF'
S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp597
sg27
g28
sg467
I3
sg468
(I9
I2
I1
tp598
sg22
I1
sg20
F3.172172409191262
sg23
F2.8075577621057164
sVY
I7
sVX
I3
sg470
g501
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p599
sg34
g11
sg472
I1
sg473
g514
sg475
I1
sS'block.thisIndex'
p600
I6
sg477
g493
sg479
I0
sg480
g533
sa(dp601
S'block.thisTrialN'
p602
I14
sS'block.thisRepN'
p603
I0
sg29
g33
sS'block.thisN'
p604
I14
sg465
(S'DECREASE'
S'ADD'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp605
sg27
g28
sg467
I4
sg468
(I3
I6
I10
I9
tp606
sg22
I1
sg20
F7.0451054673467297
sg23
F3.8143830373592209
sVY
I4
sVX
I9
sg470
g474
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p607
sg34
g11
sg472
I9
sg473
g492
sg475
I9
sS'block.thisIndex'
p608
I12
sg477
Vdecrease 
p609
sg479
g490
sg480
VUBUUxy
p610
sa(dp611
S'block.thisTrialN'
p612
I15
sS'block.thisRepN'
p613
I0
sg29
g33
sS'block.thisN'
p614
I15
sg465
(S'DIVIDE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp615
sg27
g28
sg467
I3
sg468
(I2
I4
I1
tp616
sg22
I1
sg20
F2.1814662262622733
sg23
F3.0936831129947677
sVY
I4
sVX
I6
sg470
g490
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p617
sg34
g11
sg472
I1
sg473
g474
sg475
I1
sS'block.thisIndex'
p618
I4
sg477
g478
sg479
I0
sg480
g515
sa(dp619
S'block.thisTrialN'
p620
I16
sS'block.thisRepN'
p621
I0
sg29
g33
sS'block.thisN'
p622
I16
sg465
(S'DOUBLE'
S'SUBTRACT'
S'x'
S'y'
tp623
sg27
g28
sg467
I2
sg468
(I1
I2
tp624
sg22
I1
sg20
F1.189619189593941
sg23
F1.7486238067504019
sVY
I7
sVX
I8
sg470
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p625
sg34
g11
sg472
I2
sg473
g514
sg475
I2
sS'block.thisIndex'
p626
I2
sg477
g474
sg479
I0
sg480
g543
sa(dp627
S'block.thisTrialN'
p628
I17
sS'block.thisRepN'
p629
I0
sg29
g33
sS'block.thisN'
p630
I17
sg465
(S'DECREASE'
S'TIMES'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp631
sg27
g28
sg467
I4
sg468
(I1
I2
I8
I7
tp632
sg22
I1
sg20
F5.9127438557625283
sg23
F2.7417567846423481
sVY
I4
sVX
I3
sg470
g474
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p633
sg34
g11
sg472
I7
sg473
g541
sg475
I7
sS'block.thisIndex'
p634
I13
sg477
g504
sg479
g490
sg480
g610
sa(dp635
S'block.thisTrialN'
p636
I0
sS'block.thisRepN'
p637
I0
sg29
g33
sS'block.thisN'
p638
I0
sVRule
p639
(S'ADD'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp640
sg27
g28
sVLength
p641
I3
sVIntermediate
p642
(I3
I2
I6
tp643
sg22
I1
sg20
F2.4305004870984703
sg23
F4.4072878444858361
sVY
I4
sVX
I6
sVOperatorc
p644
Vhalf
p645
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p646
sg34
g11
sVResult
p647
I6
sVOperatora
p648
Vdecrease
p649
sVCorrectResponse
p650
I6
sS'block.thisIndex'
p651
I4
sVOperatorb
p652
VADD
p653
sVOperatord
p654
I0
sVStructure
p655
VBUUxy
p656
sa(dp657
S'block.thisTrialN'
p658
I1
sS'block.thisRepN'
p659
I0
sg29
g33
sS'block.thisN'
p660
I1
sg639
(S'INCREASE'
S'TIMES'
S'x'
S'y'
tp661
sg27
g28
sg641
I2
sg642
(I8
I9
tp662
sg22
I1
sg20
F0.74081508416566066
sg23
F1.1559051496733446
sVY
I4
sVX
I2
sg644
I0
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p663
sg34
g11
sg647
I9
sg648
VTIMES
p664
sg650
I9
sS'block.thisIndex'
p665
I2
sg652
Vincrease
p666
sg654
I0
sg655
VUBxy
p667
sa(dp668
S'block.thisTrialN'
p669
I2
sS'block.thisRepN'
p670
I0
sg29
g33
sS'block.thisN'
p671
I2
sg639
(S'DIVIDE'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp672
sg27
g28
sg641
I4
sg642
(I12
I4
I3
I1
tp673
sg22
I1
sg20
F4.229991517146118
sg23
F5.0300016459077597
sVY
I3
sVX
I6
sg644
Vthird
p674
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p675
sg34
g11
sg647
I1
sg648
g649
sg650
I1
sS'block.thisIndex'
p676
I10
sg652
VDIVIDE
p677
sg654
Vdouble
p678
sg655
VBUUUxy
p679
sa(dp680
S'block.thisTrialN'
p681
I3
sS'block.thisRepN'
p682
I0
sg29
g33
sS'block.thisN'
p683
I3
sg639
(S'DECREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp684
sg27
g28
sg641
I3
sg642
(I4
I2
I1
tp685
sg22
I1
sg20
F2.7429783946136013
sg23
F3.8619693653017748
sVY
I2
sVX
I8
sg644
g677
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p686
sg34
g11
sg647
I1
sg648
g645
sg650
I1
sS'block.thisIndex'
p687
I8
sg652
g649
sg654
I0
sg655
VUUBxy
p688
sa(dp689
S'block.thisTrialN'
p690
I4
sS'block.thisRepN'
p691
I0
sg29
g33
sS'block.thisN'
p692
I4
sg639
(S'TRIPLE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp693
sg27
g28
sg641
I3
sg642
(I6
I3
I9
tp694
sg22
I1
sg20
F6.1327821602462791
sg23
F6.055868296069093
sVY
I3
sVX
I2
sg644
g664
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p695
sg34
g11
sg647
I9
sg648
g645
sg650
I9
sS'block.thisIndex'
p696
I9
sg652
Vtriple
p697
sg654
I0
sg655
g688
sa(dp698
S'block.thisTrialN'
p699
I5
sS'block.thisRepN'
p700
I0
sg29
g33
sS'block.thisN'
p701
I5
sg639
(S'DECREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp702
sg27
g28
sg641
I4
sg642
(I6
I18
I2
I1
tp703
sg22
I1
sg20
F5.0637960999447387
sg23
F3.5894333132600877
sVY
I9
sVX
I3
sg644
g697
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p704
sg34
g11
sg647
I1
sg648
g677
sg650
I1
sS'block.thisIndex'
p705
I12
sg652
g649
sg654
g678
sg655
VUBUUxy
p706
sa(dp707
S'block.thisTrialN'
p708
I6
sS'block.thisRepN'
p709
I0
sg29
g33
sS'block.thisN'
p710
I6
sg639
(S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp711
sg27
g28
sg641
I3
sg642
(I8
I16
I7
tp712
sg22
I1
sg20
F2.8376603533979505
sg23
F10.837381470482796
sVY
I9
sVX
I9
sg644
g649
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p713
sg34
g11
sg647
I7
sg648
g678
sg650
I7
sS'block.thisIndex'
p714
I5
sg652
VSUBTRACT
p715
sg654
I0
sg655
g656
sa(dp716
S'block.thisTrialN'
p717
I7
sS'block.thisRepN'
p718
I0
sg29
g33
sS'block.thisN'
p719
I7
sg639
(S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp720
sg27
g28
sg641
I3
sg642
(I1
I4
I8
tp721
sg22
I1
sg20
F2.837839659769088
sg23
F2.0858432513778098
sVY
I4
sVX
I3
sg644
g674
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p722
sg34
g11
sg647
I8
sg648
g664
sg650
I8
sS'block.thisIndex'
p723
I6
sg652
g678
sg654
I0
sg655
VUBUxy
p724
sa(dp725
S'block.thisTrialN'
p726
I8
sS'block.thisRepN'
p727
I0
sg29
g33
sS'block.thisN'
p728
I8
sg639
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'ADD'
S'x'
S'y'
tp729
sg27
g28
sg641
I4
sg642
(I4
I12
I6
I5
tp730
sg22
I0
sg20
F4.6453221405972727
sVY
I2
sVX
I2
sg644
g697
sg35
g36
sg37
g38
sg21
Nsg19
S'space'
p731
sg34
g11
sg647
I5
sg648
g645
sg650
I5
sS'block.thisIndex'
p732
I16
sg652
g649
sg654
g653
sg655
VUUUBxy
p733
sa(dp734
S'block.thisTrialN'
p735
I9
sS'block.thisRepN'
p736
I0
sg29
g33
sS'block.thisN'
p737
I9
sg639
(S'INCREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp738
sg27
g28
sg641
I4
sg642
(I4
I2
I6
I7
tp739
sg22
I0
sg20
F8.1370003076444846
sg23
F4.8226030695077498
sVY
I2
sVX
I2
sg644
g645
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p740
sg34
g11
sg647
I7
sg648
g697
sg650
I7
sS'block.thisIndex'
p741
I17
sg652
g666
sg654
g653
sg655
g733
sa(dp742
S'block.thisTrialN'
p743
I10
sS'block.thisRepN'
p744
I0
sg29
g33
sS'block.thisN'
p745
I10
sg639
(S'INCREASE'
S'DIVIDE'
S'HALF'
S'x'
S'y'
tp746
sg27
g28
sg641
I3
sg642
(I2
I1
I2
tp747
sg22
I1
sg20
F1.8135015619045589
sg23
F2.3429900974442717
sVY
I2
sVX
I4
sg644
g645
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p748
sg34
g11
sg647
I2
sg648
g677
sg650
I2
sS'block.thisIndex'
p749
I7
sg652
g666
sg654
I0
sg655
g724
sa(dp750
S'block.thisTrialN'
p751
I11
sS'block.thisRepN'
p752
I0
sg29
g33
sS'block.thisN'
p753
I11
sg639
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp754
sg27
g28
sg641
I4
sg642
(I4
I2
I3
I1
tp755
sg22
I1
sg20
F4.7280747529584914
sg23
F9.7167907724506222
sVY
I2
sVX
I8
sg644
g715
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p756
sg34
g11
sg647
I1
sg648
g666
sg650
I1
sS'block.thisIndex'
p757
I15
sg652
g674
sg654
g645
sg655
VUUBUxy
p758
sa(dp759
S'block.thisTrialN'
p760
I12
sS'block.thisRepN'
p761
I0
sg29
g33
sS'block.thisN'
p762
I12
sg639
(S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp763
sg27
g28
sg641
I2
sg642
(I3
I1
tp764
sg22
I1
sg20
F0.82106082967948169
sg23
F2.7098101440351456
sVY
I2
sVX
I9
sg644
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p765
sg34
g11
sg647
I1
sg648
g674
sg650
I1
sS'block.thisIndex'
p766
I0
sg652
g715
sg654
I0
sg655
VBUxy
p767
sa(dp768
S'block.thisTrialN'
p769
I13
sS'block.thisRepN'
p770
I0
sg29
g33
sS'block.thisN'
p771
I13
sg639
(S'TIMES'
S'THIRD'
S'x'
S'y'
tp772
sg27
g28
sg641
I2
sg642
(I1
I4
tp773
sg22
I1
sg20
F1.4113194996025413
sg23
F2.3897873406240251
sVY
I4
sVX
I3
sg644
I0
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p774
sg34
g11
sg647
I4
sg648
g674
sg650
I4
sS'block.thisIndex'
p775
I1
sg652
g664
sg654
I0
sg655
g767
sa(dp776
S'block.thisTrialN'
p777
I14
sS'block.thisRepN'
p778
I0
sg29
g33
sS'block.thisN'
p779
I14
sg639
(S'INCREASE'
S'HALF'
S'TIMES'
S'TRIPLE'
S'x'
S'y'
tp780
sg27
g28
sg641
I4
sg642
(I6
I12
I6
I7
tp781
sg22
I1
sg20
F3.8782383357756771
sg23
F6.1832106989750173
sVY
I2
sVX
I2
sg644
g664
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p782
sg34
g11
sg647
I7
sg648
g645
sg650
I7
sS'block.thisIndex'
p783
I14
sg652
g666
sg654
g697
sg655
g758
sa(dp784
S'block.thisTrialN'
p785
I15
sS'block.thisRepN'
p786
I0
sg29
g33
sS'block.thisN'
p787
I15
sg639
(S'TIMES'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp788
sg27
g28
sg641
I4
sg642
(I6
I2
I1
I2
tp789
sg22
I1
sg20
F6.278085651632864
sg23
F3.0760293090424966
sVY
I2
sVX
I3
sg644
g674
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p790
sg34
g11
sg647
I2
sg648
g649
sg650
I2
sS'block.thisIndex'
p791
I11
sg652
g664
sg654
g678
sg655
g679
sa(dp792
S'block.thisTrialN'
p793
I16
sS'block.thisRepN'
p794
I0
sg29
g33
sS'block.thisN'
p795
I16
sg639
(S'TRIPLE'
S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp796
sg27
g28
sg641
I4
sg642
(I3
I4
I1
I3
tp797
sg22
I0
sg20
F4.3726064400398172
sg23
F11.84606687782798
sVY
I3
sVX
I6
sg644
g666
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p798
sg34
g11
sg647
I3
sg648
g715
sg650
I3
sS'block.thisIndex'
p799
I13
sg652
g697
sg654
g645
sg655
g706
sa(dp800
S'block.thisTrialN'
p801
I17
sS'block.thisRepN'
p802
I0
sg29
g33
sS'block.thisN'
p803
I17
sg639
(S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp804
sg27
g28
sg641
I2
sg642
(I2
I6
tp805
sg22
I1
sg20
F2.2939973781758454
sg23
F2.0538641028979328
sVY
I6
sVX
I8
sg644
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p806
sg34
g11
sg647
I6
sg648
g715
sg650
I6
sS'block.thisIndex'
p807
I3
sg652
g697
sg654
I0
sg655
g667
sa(dp808
S'block.thisTrialN'
p809
I0
sS'block.thisRepN'
p810
I0
sg29
g33
sS'block.thisN'
p811
I0
sVRule
p812
(S'INCREASE'
S'TIMES'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp813
sg27
g28
sVLength
p814
I4
sVIntermediate
p815
(I1
I3
I6
I7
tp816
sg22
I0
sg20
F7.7908323133306112
sg23
F3.7325026613543741
sVY
I2
sVX
I2
sVOperatorc
p817
Vtriple
p818
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p819
sg34
g11
sVResult
p820
I7
sVOperatora
p821
VTIMES
p822
sVCorrectResponse
p823
I7
sS'block.thisIndex'
p824
I13
sVOperatorb
p825
Vincrease
p826
sVOperatord
p827
Vhalf
p828
sVStructure
p829
VUBUUxy
p830
sa(dp831
S'block.thisTrialN'
p832
I1
sS'block.thisRepN'
p833
I0
sg29
g33
sS'block.thisN'
p834
I1
sg812
(S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp835
sg27
g28
sg814
I3
sg815
(I4
I5
I3
tp836
sg22
I1
sg20
F4.1164064272306859
sg23
F4.3574311013508122
sVY
I2
sVX
I8
sg817
g828
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p837
sg34
g11
sg820
I3
sg821
g826
sg823
I3
sS'block.thisIndex'
p838
I5
sg825
VSUBTRACT
p839
sg827
I0
sg829
VBUUxy
p840
sa(dp841
S'block.thisTrialN'
p842
I2
sS'block.thisRepN'
p843
I0
sg29
g33
sS'block.thisN'
p844
I2
sg812
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp845
sg27
g28
sg814
I4
sg815
(I9
I10
I20
I5
tp846
sg22
I1
sg20
F6.3081803726090584
sg23
F3.349794499197742
sVY
I4
sVX
I3
sg817
g826
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p847
sg34
g11
sg820
I5
sg821
Vdouble
p848
sg823
I5
sS'block.thisIndex'
p849
I10
sg825
VDIVIDE
p850
sg827
g818
sg829
VBUUUxy
p851
sa(dp852
S'block.thisTrialN'
p853
I3
sS'block.thisRepN'
p854
I0
sg29
g33
sS'block.thisN'
p855
I3
sg812
(S'DOUBLE'
S'DIVIDE'
S'x'
S'y'
tp856
sg27
g28
sg814
I2
sg815
(I1
I2
tp857
sg22
I1
sg20
F0.86971649411134422
sg23
F4.1170257869234774
sVY
I8
sVX
I8
sg817
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p858
sg34
g11
sg820
I2
sg821
g850
sg823
I2
sS'block.thisIndex'
p859
I2
sg825
Vdpuble
p860
sg827
I0
sg829
VUBxy
p861
sa(dp862
S'block.thisTrialN'
p863
I4
sS'block.thisRepN'
p864
I0
sg29
g33
sS'block.thisN'
p865
I4
sg812
(S'ADD'
S'HALF'
S'x'
S'y'
tp866
sg27
g28
sg814
I2
sg815
(I2
I7
tp867
sg22
I1
sg20
F4.1654107809008565
sg23
F2.7747097991814371
sVY
I5
sVX
I4
sg817
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p868
sg34
g11
sg820
I7
sg821
g828
sg823
I7
sS'block.thisIndex'
p869
I0
sg825
VADD
p870
sg827
I0
sg829
VBUxy
p871
sa(dp872
S'block.thisTrialN'
p873
I5
sS'block.thisRepN'
p874
I0
sg29
g33
sS'block.thisN'
p875
I5
sg812
(S'DECREASE'
S'THIRD'
S'DOUBLE'
S'ADD'
S'x'
S'y'
tp876
sg27
g28
sg814
I4
sg815
(I9
I18
I6
I5
tp877
sg22
I1
sg20
F3.557079469319433
sg23
F2.8699437066970859
sVY
I4
sVX
I5
sg817
g848
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p878
sg34
g11
sg820
I5
sg821
Vthird
p879
sg823
I5
sS'block.thisIndex'
p880
I16
sg825
Vdecrease
p881
sg827
g870
sg829
VUUUBxy
p882
sa(dp883
S'block.thisTrialN'
p884
I6
sS'block.thisRepN'
p885
I0
sg29
g33
sS'block.thisN'
p886
I6
sg812
(S'DIVIDE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp887
sg27
g28
sg814
I3
sg815
(I6
I18
I9
tp888
sg22
I1
sg20
F2.037949296674924
sg23
F6.342186640802538
sVY
I2
sVX
I7
sg817
g881
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p889
sg34
g11
sg820
I9
sg821
g818
sg823
I9
sS'block.thisIndex'
p890
I4
sg825
g850
sg827
I0
sg829
g840
sa(dp891
S'block.thisTrialN'
p892
I7
sS'block.thisRepN'
p893
I0
sg29
g33
sS'block.thisN'
p894
I7
sg812
(S'HALF'
S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp895
sg27
g28
sg814
I4
sg815
(I15
I14
I10
I5
tp896
sg22
I1
sg20
F2.5180669955443591
sg23
F11.685014541260898
sVY
I4
sVX
I5
sg817
g881
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p897
sg34
g11
sg820
I5
sg821
g839
sg823
I5
sS'block.thisIndex'
p898
I12
sg825
g828
sg827
g818
sg829
g830
sa(dp899
S'block.thisTrialN'
p900
I8
sS'block.thisRepN'
p901
I0
sg29
g33
sS'block.thisN'
p902
I8
sg812
(S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp903
sg27
g28
sg814
I3
sg815
(I1
I2
I6
tp904
sg22
I1
sg20
F3.6236866409599315
sg23
F2.8693900470680092
sVY
I2
sVX
I3
sg817
g839
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p905
sg34
g11
sg820
I6
sg821
g826
sg823
I6
sS'block.thisIndex'
p906
I9
sg825
g818
sg827
I0
sg829
VUUBxy
p907
sa(dp908
S'block.thisTrialN'
p909
I9
sS'block.thisRepN'
p910
I0
sg29
g33
sS'block.thisN'
p911
I9
sg812
(S'THIRD'
S'INCREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp912
sg27
g28
sg814
I4
sg815
(I28
I14
I15
I5
tp913
sg22
I1
sg20
F5.1724567671772093
sg23
F5.5412351537670474
sVY
I4
sVX
I7
sg817
g828
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p914
sg34
g11
sg820
I5
sg821
g826
sg823
I5
sS'block.thisIndex'
p915
I17
sg825
g879
sg827
g822
sg829
g882
sa(dp916
S'block.thisTrialN'
p917
I10
sS'block.thisRepN'
p918
I0
sg29
g33
sS'block.thisN'
p919
I10
sg812
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp920
sg27
g28
sg814
I4
sg815
(I5
I1
I2
I6
tp921
sg22
I1
sg20
F4.8703252459526993
sg23
F1.8768856679089367
sVY
I4
sVX
I4
sg817
g839
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p922
sg34
g11
sg820
I6
sg821
g848
sg823
I6
sS'block.thisIndex'
p923
I14
sg825
g818
sg827
g826
sg829
VUUBUxy
p924
sa(dp925
S'block.thisTrialN'
p926
I11
sS'block.thisRepN'
p927
I0
sg29
g33
sS'block.thisN'
p928
I11
sg812
(S'HALF'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp929
sg27
g28
sg814
I3
sg815
(I8
I16
I8
tp930
sg22
I1
sg20
F3.2219268382177688
sg23
F4.0554959959117696
sVY
I2
sVX
I9
sg817
g881
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p931
sg34
g11
sg820
I8
sg821
g822
sg823
I8
sS'block.thisIndex'
p932
I6
sg825
g828
sg827
I0
sg829
VUBUxy
p933
sa(dp934
S'block.thisTrialN'
p935
I12
sS'block.thisRepN'
p936
I0
sg29
g33
sS'block.thisN'
p937
I12
sg812
(S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp938
sg27
g28
sg814
I2
sg815
(I4
I5
tp939
sg22
I1
sg20
F3.141576725494815
sg23
F1.8954462691617664
sVY
I2
sVX
I8
sg817
I0
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p940
sg34
g11
sg820
I5
sg821
g850
sg823
I5
sS'block.thisIndex'
p941
I3
sg825
g826
sg827
I0
sg829
g861
sa(dp942
S'block.thisTrialN'
p943
I13
sS'block.thisRepN'
p944
I0
sg29
g33
sS'block.thisN'
p945
I13
sg812
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'x'
S'y'
tp946
sg27
g28
sg814
I3
sg815
(I6
I2
I3
tp947
sg22
I0
sg20
F3.8775833885883912
sg23
F1.8301681544398889
sVY
I3
sVX
I2
sg817
g818
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p948
sg34
g11
sg820
I3
sg821
g850
sg823
I3
sS'block.thisIndex'
p949
I7
sg825
g826
sg827
I0
sg829
g933
sa(dp950
S'block.thisTrialN'
p951
I14
sS'block.thisRepN'
p952
I0
sg29
g33
sS'block.thisN'
p953
I14
sg812
(S'TIMES'
S'HALF'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp954
sg27
g28
sg814
I4
sg815
(I1
I2
I1
I9
tp955
sg22
I1
sg20
F4.1167366383597255
sg23
F3.1906019525777083
sVY
I9
sVX
I3
sg817
g826
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p956
sg34
g11
sg820
I9
sg821
g828
sg823
I9
sS'block.thisIndex'
p957
I11
sg825
g822
sg827
g879
sg829
g851
sa(dp958
S'block.thisTrialN'
p959
I15
sS'block.thisRepN'
p960
I0
sg29
g33
sS'block.thisN'
p961
I15
sg812
(S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp962
sg27
g28
sg814
I4
sg815
(I16
I2
I3
I9
tp963
sg22
I1
sg20
F6.100597357028164
sg23
F7.6055558274092618
sVY
I8
sVX
I8
sg817
g850
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p964
sg34
g11
sg820
I9
sg821
g826
sg823
I9
sS'block.thisIndex'
p965
I15
sg825
g818
sg827
g848
sg829
g924
sa(dp966
S'block.thisTrialN'
p967
I16
sS'block.thisRepN'
p968
I0
sg29
g33
sS'block.thisN'
p969
I16
sg812
(S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp970
sg27
g28
sg814
I2
sg815
(I12
I9
tp971
sg22
I1
sg20
F0.75637093555997126
sg23
F4.7102214535989333
sVY
I3
sVX
I4
sg817
I0
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p972
sg34
g11
sg820
I9
sg821
g818
sg823
I9
sS'block.thisIndex'
p973
I1
sg825
g839
sg827
I0
sg829
g871
sa(dp974
S'block.thisTrialN'
p975
I17
sS'block.thisRepN'
p976
I0
sg29
g33
sS'block.thisN'
p977
I17
sg812
(S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp978
sg27
g28
sg814
I3
sg815
(I6
I3
I9
tp979
sg22
I1
sg20
F4.0362537567852996
sg23
F4.5845256577595137
sVY
I3
sVX
I3
sg817
g870
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p980
sg34
g11
sg820
I9
sg821
g828
sg823
I9
sS'block.thisIndex'
p981
I8
sg825
g818
sg827
I0
sg829
g907
sa(dp982
S'block.thisTrialN'
p983
I0
sS'block.thisRepN'
p984
I0
sg29
g33
sS'block.thisN'
p985
I0
sVRule
p986
(S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp987
sg27
g28
sVLength
p988
I3
sVIntermediate
p989
(I3
I18
I6
tp990
sg22
I1
sg20
F7.7104339521320071
sg23
F3.4934068991278764
sVY
I6
sVX
I6
sVOperatorc
p991
Vhalf
p992
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p993
sg34
g11
sVResult
p994
I6
sVOperatora
p995
VTIMES
p996
sVCorrectResponse
p997
I6
sS'block.thisIndex'
p998
I7
sVOperatorb
p999
Vthird
p1000
sVOperatord
p1001
I0
sVStructure
p1002
VUBUxy
p1003
sa(dp1004
S'block.thisTrialN'
p1005
I1
sS'block.thisRepN'
p1006
I0
sg29
g33
sS'block.thisN'
p1007
I1
sg986
(S'TIMES'
S'DOUBLE'
S'x'
S'y'
tp1008
sg27
g28
sg988
I2
sg989
(I4
I8
tp1009
sg22
I1
sg20
F3.3181243462022394
sg23
F1.6229067952372134
sVY
I2
sVX
I2
sg991
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1010
sg34
g11
sg994
I8
sg995
Vdouble
p1011
sg997
I8
sS'block.thisIndex'
p1012
I1
sg999
g996
sg1001
I0
sg1002
VBUxy
p1013
sa(dp1014
S'block.thisTrialN'
p1015
I2
sS'block.thisRepN'
p1016
I0
sg29
g33
sS'block.thisN'
p1017
I2
sg986
(S'INCREASE'
S'ADD'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp1018
sg27
g28
sg988
I4
sg989
(I6
I3
I6
I7
tp1019
sg22
I0
sg20
F3.5909012983611319
sg23
F12.643772030482069
sVY
I3
sVX
I2
sg991
g992
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1020
sg34
g11
sg994
I7
sg995
VADD
p1021
sg997
I7
sS'block.thisIndex'
p1022
I13
sg999
Vincrease
p1023
sg1001
Vtriple
p1024
sg1002
VUBUUxy
p1025
sa(dp1026
S'block.thisTrialN'
p1027
I3
sS'block.thisRepN'
p1028
I0
sg29
g33
sS'block.thisN'
p1029
I3
sg986
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp1030
sg27
g28
sg988
I4
sg989
(I4
I2
I6
I5
tp1031
sg22
I1
sg20
F4.837577886210056
sg23
F8.9186808117956389
sVY
I2
sVX
I6
sg991
g992
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1032
sg34
g11
sg994
I5
sg995
g1024
sg997
I5
sS'block.thisIndex'
p1033
I16
sg999
Vdecrease
p1034
sg1001
VSUBTRACT
p1035
sg1002
VUUUBxy
p1036
sa(dp1037
S'block.thisTrialN'
p1038
I4
sS'block.thisRepN'
p1039
I0
sg29
g33
sS'block.thisN'
p1040
I4
sg986
(S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp1041
sg27
g28
sg988
I2
sg989
(I3
I1
tp1042
sg22
I1
sg20
F1.0301641850383021
sg23
F1.2857277287985198
sVY
I3
sVX
I9
sg991
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1043
sg34
g11
sg994
I1
sg995
g1000
sg997
I1
sS'block.thisIndex'
p1044
I0
sg999
VDIVIDE
p1045
sg1001
I0
sg1002
g1013
sa(dp1046
S'block.thisTrialN'
p1047
I5
sS'block.thisRepN'
p1048
I0
sg29
g33
sS'block.thisN'
p1049
I5
sg986
(S'DOUBLE'
S'DIVIDE'
S'TRIPLE'
S'INCREASE'
S'x'
S'y'
tp1050
sg27
g28
sg988
I4
sg989
(I5
I15
I3
I6
tp1051
sg22
I1
sg20
F6.5022524503001478
sg23
F8.3284344606508967
sVY
I5
sVX
I4
sg991
g1024
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1052
sg34
g11
sg994
I6
sg995
g1045
sg997
I6
sS'block.thisIndex'
p1053
I12
sg999
g1011
sg1001
g1023
sg1002
g1025
sa(dp1054
S'block.thisTrialN'
p1055
I6
sS'block.thisRepN'
p1056
I0
sg29
g33
sS'block.thisN'
p1057
I6
sg986
(S'THIRD'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp1058
sg27
g28
sg988
I3
sg989
(I6
I3
I1
tp1059
sg22
I1
sg20
F4.4035196739132516
sg23
F2.9036064184620045
sVY
I2
sVX
I7
sg991
g1034
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1060
sg34
g11
sg994
I1
sg995
g1045
sg997
I1
sS'block.thisIndex'
p1061
I6
sg999
g1000
sg1001
I0
sg1002
g1003
sa(dp1062
S'block.thisTrialN'
p1063
I7
sS'block.thisRepN'
p1064
I0
sg29
g33
sS'block.thisN'
p1065
I7
sg986
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp1066
sg27
g28
sg988
I4
sg989
(I6
I2
I6
I5
tp1067
sg22
I1
sg20
F5.0794450263492763
sg23
F5.6197887812450062
sVY
I3
sVX
I3
sg991
g1045
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1068
sg34
g11
sg994
I5
sg995
g1024
sg997
I5
sS'block.thisIndex'
p1069
I14
sg999
g1034
sg1001
g1011
sg1002
VUUBUxy
p1070
sa(dp1071
S'block.thisTrialN'
p1072
I8
sS'block.thisRepN'
p1073
I0
sg29
g33
sS'block.thisN'
p1074
I8
sg986
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'DOUBLE'
S'x'
S'y'
tp1075
sg27
g28
sg988
I4
sg989
(I4
I3
I9
I1
tp1076
sg22
I1
sg20
F3.8936757901974488
sg23
F6.9667619431274943
sVY
I8
sVX
I2
sg991
g1034
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1077
sg34
g11
sg994
I1
sg995
g1024
sg997
I1
sS'block.thisIndex'
p1078
I11
sg999
g1035
sg1001
g1011
sg1002
VBUUUxy
p1079
sa(dp1080
S'block.thisTrialN'
p1081
I9
sS'block.thisRepN'
p1082
I0
sg29
g33
sS'block.thisN'
p1083
I9
sg986
(S'DOUBLE'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp1084
sg27
g28
sg988
I3
sg989
(I12
I4
I8
tp1085
sg22
I1
sg20
F2.7405690512387082
sg23
F4.1356449022714514
sVY
I6
sVX
I2
sg991
g996
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1086
sg34
g11
sg994
I8
sg995
g1000
sg997
I8
sS'block.thisIndex'
p1087
I9
sg999
g1011
sg1001
I0
sg1002
VUUBxy
p1088
sa(dp1089
S'block.thisTrialN'
p1090
I10
sS'block.thisRepN'
p1091
I0
sg29
g33
sS'block.thisN'
p1092
I10
sg986
(S'DOUBLE'
S'DECREASE'
S'ADD'
S'x'
S'y'
tp1093
sg27
g28
sg988
I3
sg989
(I4
I3
I6
tp1094
sg22
I1
sg20
F1.6384931013162713
sg23
F4.0373083791928366
sVY
I2
sVX
I2
sg991
g1021
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1095
sg34
g11
sg994
I6
sg995
g1034
sg997
I6
sS'block.thisIndex'
p1096
I8
sg999
g1011
sg1001
I0
sg1002
g1088
sa(dp1097
S'block.thisTrialN'
p1098
I11
sS'block.thisRepN'
p1099
I0
sg29
g33
sS'block.thisN'
p1100
I11
sg986
(S'THIRD'
S'DIVIDE'
S'x'
S'y'
tp1101
sg27
g28
sg988
I2
sg989
(I3
I1
tp1102
sg22
I1
sg20
F2.9318300572922453
sg23
F4.6312770477961749
sVY
I2
sVX
I6
sg991
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1103
sg34
g11
sg994
I1
sg995
g1045
sg997
I1
sS'block.thisIndex'
p1104
I3
sg999
g1000
sg1001
I0
sg1002
VUBxy
p1105
sa(dp1106
S'block.thisTrialN'
p1107
I12
sS'block.thisRepN'
p1108
I0
sg29
g33
sS'block.thisN'
p1109
I12
sg986
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1110
sg27
g28
sg988
I4
sg989
(I1
I2
I6
I3
tp1111
sg22
I1
sg20
F3.1735363692569081
sg23
F5.1917585469200276
sVY
I2
sVX
I3
sg991
g1023
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1112
sg34
g11
sg994
I3
sg995
g1024
sg997
I3
sS'block.thisIndex'
p1113
I17
sg999
g992
sg1001
g1035
sg1002
g1036
sa(dp1114
S'block.thisTrialN'
p1115
I13
sS'block.thisRepN'
p1116
I0
sg29
g33
sS'block.thisN'
p1117
I13
sg986
(S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp1118
sg27
g28
sg988
I3
sg989
(I6
I3
I9
tp1119
sg22
I1
sg20
F2.4530800825159531
sg23
F9.3492244145600125
sVY
I3
sVX
I5
sg991
g1023
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1120
sg34
g11
sg994
I9
sg995
g992
sg997
I9
sS'block.thisIndex'
p1121
I5
sg999
g996
sg1001
I0
sg1002
VBUUxy
p1122
sa(dp1123
S'block.thisTrialN'
p1124
I14
sS'block.thisRepN'
p1125
I0
sg29
g33
sS'block.thisN'
p1126
I14
sg986
(S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1127
sg27
g28
sg988
I2
sg989
(I3
I4
tp1128
sg22
I1
sg20
F1.5922149568214081
sg23
F1.9578695122036152
sVY
I3
sVX
I6
sg991
I0
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p1129
sg34
g11
sg994
I4
sg995
g1035
sg997
I4
sS'block.thisIndex'
p1130
I2
sg999
g1023
sg1001
I0
sg1002
g1105
sa(dp1131
S'block.thisTrialN'
p1132
I15
sS'block.thisRepN'
p1133
I0
sg29
g33
sS'block.thisN'
p1134
I15
sg986
(S'SUBTRACT'
S'DOUBLE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp1135
sg27
g28
sg988
I4
sg989
(I2
I6
I12
I8
tp1136
sg22
I1
sg20
F3.8141257122333627
sg23
F3.6077471972093917
sVY
I4
sVX
I3
sg991
g1024
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1137
sg34
g11
sg994
I8
sg995
g1011
sg997
I8
sS'block.thisIndex'
p1138
I10
sg999
g1035
sg1001
g1034
sg1002
g1079
sa(dp1139
S'block.thisTrialN'
p1140
I16
sS'block.thisRepN'
p1141
I0
sg29
g33
sS'block.thisN'
p1142
I16
sg986
(S'THIRD'
S'DECREASE'
S'TIMES'
S'HALF'
S'x'
S'y'
tp1143
sg27
g28
sg988
I4
sg989
(I4
I16
I15
I5
tp1144
sg22
I1
sg20
F6.8986289566673804
sg23
F4.5189799522340763
sVY
I4
sVX
I8
sg991
g996
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1145
sg34
g11
sg994
I5
sg995
g1034
sg997
I5
sS'block.thisIndex'
p1146
I15
sg999
g1000
sg1001
g992
sg1002
g1070
sa(dp1147
S'block.thisTrialN'
p1148
I17
sS'block.thisRepN'
p1149
I0
sg29
g33
sS'block.thisN'
p1150
I17
sg986
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp1151
sg27
g28
sg988
I3
sg989
(I4
I12
I3
tp1152
sg22
I1
sg20
F2.4058893235051073
sg23
F6.5993673634657171
sVY
I9
sVX
I5
sg991
g1034
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1153
sg34
g11
sg994
I3
sg995
g1024
sg997
I3
sS'block.thisIndex'
p1154
I4
sg999
g1035
sg1001
I0
sg1002
g1122
sa(dp1155
S'block.thisTrialN'
p1156
I0
sS'block.thisRepN'
p1157
I0
sg29
g33
sS'block.thisN'
p1158
I0
sVRule
p1159
(S'THIRD'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp1160
sg27
g28
sVLength
p1161
I3
sVIntermediate
p1162
(I3
I15
I5
tp1163
sg22
I1
sg20
F1.901638155017281
sg23
F2.4060104579257313
sVY
I5
sVX
I4
sVOperatorc
p1164
Vdecrease
p1165
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1166
sg34
g11
sVResult
p1167
I5
sVOperatora
p1168
VTIMES
p1169
sVCorrectResponse
p1170
I5
sS'block.thisIndex'
p1171
I7
sVOperatorb
p1172
Vthird
p1173
sVOperatord
p1174
I0
sVStructure
p1175
VUBUxy
p1176
sa(dp1177
S'block.thisTrialN'
p1178
I1
sS'block.thisRepN'
p1179
I0
sg29
g33
sS'block.thisN'
p1180
I1
sg1159
(S'TRIPLE'
S'HALF'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp1181
sg27
g28
sg1161
I4
sg1162
(I1
I4
I2
I6
tp1182
sg22
I1
sg20
F2.6150799367460422
sg23
F6.8398003951006103
sVY
I3
sVX
I2
sg1164
VADD
p1183
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1184
sg34
g11
sg1167
I6
sg1168
Vhalf
p1185
sg1170
I6
sS'block.thisIndex'
p1186
I15
sg1172
Vtriple
p1187
sg1174
g1165
sg1175
VUUBUxy
p1188
sa(dp1189
S'block.thisTrialN'
p1190
I2
sS'block.thisRepN'
p1191
I0
sg29
g33
sS'block.thisN'
p1192
I2
sg1159
(S'THIRD'
S'SUBTRACT'
S'x'
S'y'
tp1193
sg27
g28
sg1161
I2
sg1162
(I3
I1
tp1194
sg22
I1
sg20
F0.74068779035587795
sg23
F2.2007289965986274
sVY
I2
sVX
I5
sg1164
I0
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1195
sg34
g11
sg1167
I1
sg1168
VSUBTRACT
p1196
sg1170
I1
sS'block.thisIndex'
p1197
I3
sg1172
g1173
sg1174
I0
sg1175
VUBxy
p1198
sa(dp1199
S'block.thisTrialN'
p1200
I3
sS'block.thisRepN'
p1201
I0
sg29
g33
sS'block.thisN'
p1202
I3
sg1159
(S'TIMES'
S'DECREASE'
S'x'
S'y'
tp1203
sg27
g28
sg1161
I2
sg1162
(I2
I4
tp1204
sg22
I1
sg20
F2.8846351920219604
sg23
F2.4537261328368913
sVY
I2
sVX
I3
sg1164
I0
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p1205
sg34
g11
sg1167
I4
sg1168
g1165
sg1170
I4
sS'block.thisIndex'
p1206
I0
sg1172
g1169
sg1174
I0
sg1175
VBUxy
p1207
sa(dp1208
S'block.thisTrialN'
p1209
I4
sS'block.thisRepN'
p1210
I0
sg29
g33
sS'block.thisN'
p1211
I4
sg1159
(S'THIRD'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp1212
sg27
g28
sg1161
I3
sg1162
(I8
I15
I5
tp1213
sg22
I1
sg20
F5.5247468410234433
sg23
F4.6631696227705106
sVY
I7
sVX
I7
sg1164
Vincrease
p1214
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1215
sg34
g11
sg1167
I5
sg1168
g1183
sg1170
I5
sS'block.thisIndex'
p1216
I6
sg1172
g1173
sg1174
I0
sg1175
g1176
sa(dp1217
S'block.thisTrialN'
p1218
I5
sS'block.thisRepN'
p1219
I0
sg29
g33
sS'block.thisN'
p1220
I5
sg1159
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp1221
sg27
g28
sg1161
I4
sg1162
(I6
I3
I2
I6
tp1222
sg22
I1
sg20
F3.6854463820927776
sg23
F6.1662470875598956
sVY
I2
sVX
I3
sg1164
g1185
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1223
sg34
g11
sg1167
I6
sg1168
g1165
sg1170
I6
sS'block.thisIndex'
p1224
I17
sg1172
g1187
sg1174
g1169
sg1175
VUUUBxy
p1225
sa(dp1226
S'block.thisTrialN'
p1227
I6
sS'block.thisRepN'
p1228
I0
sg29
g33
sS'block.thisN'
p1229
I6
sg1159
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp1230
sg27
g28
sg1161
I4
sg1162
(I6
I18
I3
I4
tp1231
sg22
I1
sg20
F2.3231059142563026
sg23
F4.1821612094063312
sVY
I6
sVX
I3
sg1164
g1187
sg35
g36
sg37
g38
sg21
S'4'
sg19
S'space'
p1232
sg34
g11
sg1167
I4
sg1168
VDIVIDE
p1233
sg1170
I4
sS'block.thisIndex'
p1234
I12
sg1172
g1214
sg1174
Vdouble
p1235
sg1175
VUBUUxy
p1236
sa(dp1237
S'block.thisTrialN'
p1238
I7
sS'block.thisRepN'
p1239
I0
sg29
g33
sS'block.thisN'
p1240
I7
sg1159
(S'TIMES'
S'INCREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1241
sg27
g28
sg1161
I4
sg1162
(I6
I2
I3
I9
tp1242
sg22
I1
sg20
F7.1272212684561964
sg23
F2.6934405703796074
sVY
I3
sVX
I3
sg1164
g1173
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1243
sg34
g11
sg1167
I9
sg1168
g1214
sg1170
I9
sS'block.thisIndex'
p1244
I11
sg1172
g1169
sg1174
g1235
sg1175
VBUUUxy
p1245
sa(dp1246
S'block.thisTrialN'
p1247
I8
sS'block.thisRepN'
p1248
I0
sg29
g33
sS'block.thisN'
p1249
I8
sg1159
(S'THIRD'
S'INCREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp1250
sg27
g28
sg1161
I4
sg1162
(I4
I2
I3
I1
tp1251
sg22
I1
sg20
F5.109424430062063
sg23
F4.6940647207084112
sVY
I2
sVX
I8
sg1164
g1185
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1252
sg34
g11
sg1167
I1
sg1168
g1214
sg1170
I1
sS'block.thisIndex'
p1253
I16
sg1172
g1173
sg1174
g1233
sg1175
g1225
sa(dp1254
S'block.thisTrialN'
p1255
I9
sS'block.thisRepN'
p1256
I0
sg29
g33
sS'block.thisN'
p1257
I9
sg1159
(S'THIRD'
S'DOUBLE'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp1258
sg27
g28
sg1161
I4
sg1162
(I10
I12
I24
I8
tp1259
sg22
I1
sg20
F3.6240835786738899
sg23
F9.9561404379201122
sVY
I2
sVX
I9
sg1164
g1183
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1260
sg34
g11
sg1167
I8
sg1168
g1235
sg1170
I8
sS'block.thisIndex'
p1261
I14
sg1172
g1173
sg1174
g1214
sg1175
g1188
sa(dp1262
S'block.thisTrialN'
p1263
I10
sS'block.thisRepN'
p1264
I0
sg29
g33
sS'block.thisN'
p1265
I10
sg1159
(S'TIMES'
S'INCREASE'
S'x'
S'y'
tp1266
sg27
g28
sg1161
I2
sg1162
(I3
I6
tp1267
sg22
I1
sg20
F0.83731405952130444
sg23
F2.0710148910002317
sVY
I2
sVX
I2
sg1164
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1268
sg34
g11
sg1167
I6
sg1168
g1214
sg1170
I6
sS'block.thisIndex'
p1269
I1
sg1172
g1169
sg1174
I0
sg1175
g1207
sa(dp1270
S'block.thisTrialN'
p1271
I11
sS'block.thisRepN'
p1272
I0
sg29
g33
sS'block.thisN'
p1273
I11
sg1159
(S'TIMES'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp1274
sg27
g28
sg1161
I3
sg1162
(I4
I3
I9
tp1275
sg22
I1
sg20
F4.0998647332016844
sg23
F3.1415924661268946
sVY
I3
sVX
I8
sg1164
g1185
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1276
sg34
g11
sg1167
I9
sg1168
g1165
sg1170
I9
sS'block.thisIndex'
p1277
I4
sg1172
g1169
sg1174
I0
sg1175
VBUUxy
p1278
sa(dp1279
S'block.thisTrialN'
p1280
I12
sS'block.thisRepN'
p1281
I0
sg29
g33
sS'block.thisN'
p1282
I12
sg1159
(S'THIRD'
S'DECREASE'
S'TIMES'
S'x'
S'y'
tp1283
sg27
g28
sg1161
I3
sg1162
(I25
I24
I8
tp1284
sg22
I1
sg20
F2.5811167841893621
sg23
F4.6933290172019042
sVY
I5
sVX
I5
sg1164
g1169
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1285
sg34
g11
sg1167
I8
sg1168
g1165
sg1170
I8
sS'block.thisIndex'
p1286
I8
sg1172
Vthid
p1287
sg1174
I0
sg1175
VUUBxy
p1288
sa(dp1289
S'block.thisTrialN'
p1290
I13
sS'block.thisRepN'
p1291
I0
sg29
g33
sS'block.thisN'
p1292
I13
sg1159
(S'TIMES'
S'THIRD'
S'HALF'
S'x'
S'y'
tp1293
sg27
g28
sg1161
I3
sg1162
(I3
I1
I5
tp1294
sg22
I1
sg20
F3.5576358664839063
sg23
F1.3989702888939064
sVY
I5
sVX
I6
sg1164
g1185
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1295
sg34
g11
sg1167
I5
sg1168
g1173
sg1170
I5
sS'block.thisIndex'
p1296
I5
sg1172
g1169
sg1174
I0
sg1175
g1278
sa(dp1297
S'block.thisTrialN'
p1298
I14
sS'block.thisRepN'
p1299
I0
sg29
g33
sS'block.thisN'
p1300
I14
sg1159
(S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1301
sg27
g28
sg1161
I4
sg1162
(I2
I4
I1
I3
tp1302
sg22
I1
sg20
F6.2130730745266192
sg23
F4.2467251784692053
sVY
I3
sVX
I3
sg1164
g1235
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1303
sg34
g11
sg1167
I3
sg1168
g1196
sg1170
I3
sS'block.thisIndex'
p1304
I13
sg1172
g1187
sg1174
g1165
sg1175
g1236
sa(dp1305
S'block.thisTrialN'
p1306
I15
sS'block.thisRepN'
p1307
I0
sg29
g33
sS'block.thisN'
p1308
I15
sg1159
(S'SUBTRACT'
S'HALF'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp1309
sg27
g28
sg1161
I4
sg1162
(I15
I16
I8
I3
tp1310
sg22
I1
sg20
F4.7558138540189248
sg23
F4.502220626862254
sVY
I5
sVX
I5
sg1164
g1214
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1311
sg34
g11
sg1167
I3
sg1168
g1185
sg1170
I3
sS'block.thisIndex'
p1312
I10
sg1172
g1196
sg1174
g1187
sg1175
g1245
sa(dp1313
S'block.thisTrialN'
p1314
I16
sS'block.thisRepN'
p1315
I0
sg29
g33
sS'block.thisN'
p1316
I16
sg1159
(S'TRIPLE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp1317
sg27
g28
sg1161
I3
sg1162
(I2
I1
I3
tp1318
sg22
I1
sg20
F2.2781900188419968
sg23
F6.6795631495479029
sVY
I2
sVX
I4
sg1164
g1233
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1319
sg34
g11
sg1167
I3
sg1168
g1185
sg1170
I3
sS'block.thisIndex'
p1320
I9
sg1172
g1187
sg1174
I0
sg1175
g1288
sa(dp1321
S'block.thisTrialN'
p1322
I17
sS'block.thisRepN'
p1323
I0
sg29
g33
sS'block.thisN'
p1324
I17
sg1159
(S'THIRD'
S'ADD'
S'x'
S'y'
tp1325
sg27
g28
sg1161
I2
sg1162
(I9
I3
tp1326
sg22
I1
sg20
F0.80439868560642935
sg23
F1.2858153288252652
sVY
I5
sVX
I4
sg1164
I0
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1327
sg34
g11
sg1167
I3
sg1168
g1183
sg1170
I3
sS'block.thisIndex'
p1328
I2
sg1172
g1173
sg1174
I0
sg1175
g1198
sa(dp1329
S'block.thisTrialN'
p1330
I0
sS'block.thisRepN'
p1331
I0
sg29
g33
sS'block.thisN'
p1332
I0
sVRule
p1333
(S'THIRD'
S'HALF'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1334
sg27
g28
sVLength
p1335
I4
sVIntermediate
p1336
(I5
I6
I3
I1
tp1337
sg22
I1
sg20
F4.0003935158310924
sg23
F8.9345963023952208
sVY
I2
sVX
I7
sVOperatorc
p1338
Vincrease
p1339
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1340
sg34
g11
sVResult
p1341
I1
sVOperatora
p1342
Vhalf
p1343
sVCorrectResponse
p1344
I1
sS'block.thisIndex'
p1345
I17
sVOperatorb
p1346
Vthird
p1347
sVOperatord
p1348
VSUBTRACT
p1349
sVStructure
p1350
VUUUBxy
p1351
sa(dp1352
S'block.thisTrialN'
p1353
I1
sS'block.thisRepN'
p1354
I0
sg29
g33
sS'block.thisN'
p1355
I1
sg1333
(S'ADD'
S'TRIPLE'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1356
sg27
g28
sg1335
I4
sg1336
(I1
I2
I6
I8
tp1357
sg22
I1
sg20
F2.3913709851622116
sg23
F4.9336939534987323
sVY
I2
sVX
I2
sg1338
Vdouble
p1358
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1359
sg34
g11
sg1341
I8
sg1342
Vtriple
p1360
sg1344
I8
sS'block.thisIndex'
p1361
I11
sg1346
VADD
p1362
sg1348
Vdecrease
p1363
sg1350
VBUUUxy
p1364
sa(dp1365
S'block.thisTrialN'
p1366
I2
sS'block.thisRepN'
p1367
I0
sg29
g33
sS'block.thisN'
p1368
I2
sg1333
(S'DECREASE'
S'TIMES'
S'x'
S'y'
tp1369
sg27
g28
sg1335
I2
sg1336
(I9
I8
tp1370
sg22
I1
sg20
F1.2854632177331951
sg23
F1.3836837392009329
sVY
I3
sVX
I3
sg1338
I0
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1371
sg34
g11
sg1341
I8
sg1342
VTIMES
p1372
sg1344
I8
sS'block.thisIndex'
p1373
I2
sg1346
g1363
sg1348
I0
sg1350
VUBxy
p1374
sa(dp1375
S'block.thisTrialN'
p1376
I3
sS'block.thisRepN'
p1377
I0
sg29
g33
sS'block.thisN'
p1378
I3
sg1333
(S'HALF'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp1379
sg27
g28
sg1335
I3
sg1336
(I9
I10
I5
tp1380
sg22
I1
sg20
F2.2291914824163541
sg23
F2.0214472964289598
sVY
I3
sVX
I3
sg1338
g1372
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1381
sg34
g11
sg1341
I5
sg1342
g1339
sg1344
I5
sS'block.thisIndex'
p1382
I9
sg1346
g1343
sg1348
I0
sg1350
VUUBxy
p1383
sa(dp1384
S'block.thisTrialN'
p1385
I4
sS'block.thisRepN'
p1386
I0
sg29
g33
sS'block.thisN'
p1387
I4
sg1333
(S'DECREASE'
S'SUBTRACT'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp1388
sg27
g28
sg1335
I4
sg1336
(I3
I6
I4
I3
tp1389
sg22
I1
sg20
F4.3730276730784681
sg23
F5.8457000526541378
sVY
I2
sVX
I9
sg1338
g1358
sg35
g36
sg37
g38
sg21
S'3'
sg19
S'space'
p1390
sg34
g11
sg1341
I3
sg1342
g1349
sg1344
I3
sS'block.thisIndex'
p1391
I13
sg1346
g1363
sg1348
g1347
sg1350
VUBUUxy
p1392
sa(dp1393
S'block.thisTrialN'
p1394
I5
sS'block.thisRepN'
p1395
I0
sg29
g33
sS'block.thisN'
p1396
I5
sg1333
(S'ADD'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp1397
sg27
g28
sg1335
I3
sg1336
(I2
I6
I8
tp1398
sg22
I1
sg20
F2.3427108722971752
sg23
F2.6449888498173095
sVY
I2
sVX
I4
sg1338
g1343
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1399
sg34
g11
sg1341
I8
sg1342
g1360
sg1344
I8
sS'block.thisIndex'
p1400
I5
sg1346
g1362
sg1348
I0
sg1350
VBUUxy
p1401
sa(dp1402
S'block.thisTrialN'
p1403
I6
sS'block.thisRepN'
p1404
I0
sg29
g33
sS'block.thisN'
p1405
I6
sg1333
(S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp1406
sg27
g28
sg1335
I2
sg1336
(I8
I2
tp1407
sg22
I1
sg20
F0.75657179969130084
sg23
F1.8300843184697442
sVY
I4
sVX
I9
sg1338
I0
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1408
sg34
g11
sg1341
I2
sg1342
g1363
sg1344
I2
sS'block.thisIndex'
p1409
I1
sg1346
VDIVIDE
p1410
sg1348
I0
sg1350
VBUxy
p1411
sa(dp1412
S'block.thisTrialN'
p1413
I7
sS'block.thisRepN'
p1414
I0
sg29
g33
sS'block.thisN'
p1415
I7
sg1333
(S'DECREASE'
S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'x'
S'y'
tp1416
sg27
g28
sg1335
I4
sg1336
(I6
I3
I9
I8
tp1417
sg22
I1
sg20
F5.332376804726664
sg23
F11.382227388501633
sVY
I3
sVX
I3
sg1338
g1349
sg35
g36
sg37
g38
sg21
S'8'
sg19
S'space'
p1418
sg34
g11
sg1341
I8
sg1342
g1360
sg1344
I8
sS'block.thisIndex'
p1419
I15
sg1346
g1363
sg1348
g1358
sg1350
VUUBUxy
p1420
sa(dp1421
S'block.thisTrialN'
p1422
I8
sS'block.thisRepN'
p1423
I0
sg29
g33
sS'block.thisN'
p1424
I8
sg1333
(S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp1425
sg27
g28
sg1335
I3
sg1336
(I4
I1
I2
tp1426
sg22
I1
sg20
F1.3635720012243837
sg23
F2.1358676664240193
sVY
I3
sVX
I3
sg1338
g1339
sg35
g36
sg37
g38
sg21
S'2'
sg19
S'space'
p1427
sg34
g11
sg1341
I2
sg1342
g1349
sg1344
I2
sS'block.thisIndex'
p1428
I6
sg1346
g1358
sg1348
I0
sg1350
VUBUxy
p1429
sa(dp1430
S'block.thisTrialN'
p1431
I9
sS'block.thisRepN'
p1432
I0
sg29
g33
sS'block.thisN'
p1433
I9
sg1333
(S'INCREASE'
S'HALF'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp1434
sg27
g28
sg1335
I4
sg1336
(I12
I4
I2
I3
tp1435
sg22
I0
sg20
F3.9878718425170518
sg23
F15.702447291987482
sVY
I4
sVX
I3
sg1338
g1347
sg35
g36
sg37
g38
sg21
S'1'
sg19
S'space'
p1436
sg34
g11
sg1341
I3
sg1342
g1343
sg1344
I3
sS'block.thisIndex'
p1437
I16
sg1346
g1339
sg1348
g1372
sg1350
g1351
sa(dp1438
S'block.thisTrialN'
p1439
I10
sS'block.thisRepN'
p1440
I0
sg29
g33
sS'block.thisN'
p1441
I10
sg1333
(S'INCREASE'
S'ADD'
S'HALF'
S'x'
S'y'
tp1442
sg27
g28
sg1335
I3
sg1336
(I1
I4
I5
tp1443
sg22
I1
sg20
F11.028645214013522
sg23
F2.4224423097330146
sVY
I3
sVX
I2
sg1338
g1343
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1444
sg34
g11
sg1341
I5
sg1342
g1362
sg1344
I5
sS'block.thisIndex'
p1445
I7
sg1346
g1339
sg1348
I0
sg1350
g1429
sa(dp1446
S'block.thisTrialN'
p1447
I11
sS'block.thisRepN'
p1448
I0
sg29
g33
sS'block.thisN'
p1449
I11
sg1333
(S'DECREASE'
S'ADD'
S'THIRD'
S'HALF'
S'x'
S'y'
tp1450
sg27
g28
sg1335
I4
sg1336
(I3
I1
I7
I6
tp1451
sg22
I1
sg20
F2.5314982036943547
sg23
F3.8330339761450887
sVY
I6
sVX
I6
sg1338
g1347
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1452
sg34
g11
sg1341
I6
sg1342
g1362
sg1344
I6
sS'block.thisIndex'
p1453
I12
sg1346
g1363
sg1348
g1343
sg1350
g1392
sa(dp1454
S'block.thisTrialN'
p1455
I12
sS'block.thisRepN'
p1456
I0
sg29
g33
sS'block.thisN'
p1457
I12
sg1333
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1458
sg27
g28
sg1335
I3
sg1336
(I1
I2
I7
tp1459
sg22
I1
sg20
F1.5080473984708078
sg23
F2.5508232522115577
sVY
I5
sVX
I2
sg1338
g1363
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1460
sg34
g11
sg1341
I7
sg1342
g1358
sg1344
I7
sS'block.thisIndex'
p1461
I4
sg1346
g1362
sg1348
I0
sg1350
g1401
sa(dp1462
S'block.thisTrialN'
p1463
I13
sS'block.thisRepN'
p1464
I0
sg29
g33
sS'block.thisN'
p1465
I13
sg1333
(S'ADD'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1466
sg27
g28
sg1335
I4
sg1336
(I18
I6
I5
I9
tp1467
sg22
I1
sg20
F3.2684243250114378
sg23
F3.0161995063826907
sVY
I4
sVX
I9
sg1338
g1347
sg35
g36
sg37
g38
sg21
S'9'
sg19
S'space'
p1468
sg34
g11
sg1341
I9
sg1342
g1363
sg1344
I9
sS'block.thisIndex'
p1469
I10
sg1346
g1362
sg1348
g1358
sg1350
g1364
sa(dp1470
S'block.thisTrialN'
p1471
I14
sS'block.thisRepN'
p1472
I0
sg29
g33
sS'block.thisN'
p1473
I14
sg1333
(S'DOUBLE'
S'THIRD'
S'ADD'
S'x'
S'y'
tp1474
sg27
g28
sg1335
I3
sg1336
(I9
I3
I6
tp1475
sg22
I1
sg20
F2.2780579344253056
sg23
F3.8311403096013237
sVY
I4
sVX
I5
sg1338
g1362
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1476
sg34
g11
sg1341
I6
sg1342
g1347
sg1344
I6
sS'block.thisIndex'
p1477
I8
sg1346
g1358
sg1348
I0
sg1350
g1383
sa(dp1478
S'block.thisTrialN'
p1479
I15
sS'block.thisRepN'
p1480
I0
sg29
g33
sS'block.thisN'
p1481
I15
sg1333
(S'ADD'
S'DECREASE'
S'x'
S'y'
tp1482
sg27
g28
sg1335
I2
sg1336
(I2
I7
tp1483
sg22
I1
sg20
F0.78822484333068132
sg23
F2.0851924104208592
sVY
I5
sVX
I3
sg1338
I0
sg35
g36
sg37
g38
sg21
S'7'
sg19
S'space'
p1484
sg34
g11
sg1341
I7
sg1342
g1363
sg1344
I7
sS'block.thisIndex'
p1485
I0
sg1346
g1362
sg1348
I0
sg1350
g1411
sa(dp1486
S'block.thisTrialN'
p1487
I16
sS'block.thisRepN'
p1488
I0
sg29
g33
sS'block.thisN'
p1489
I16
sg1333
(S'DECREASE'
S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp1490
sg27
g28
sg1335
I4
sg1336
(I1
I3
I6
I5
tp1491
sg22
I1
sg20
F5.0150983464554884
sg23
F4.7723353589826729
sVY
I3
sVX
I3
sg1338
g1372
sg35
g36
sg37
g38
sg21
S'5'
sg19
S'space'
p1492
sg34
g11
sg1341
I5
sg1342
g1358
sg1344
I5
sS'block.thisIndex'
p1493
I14
sg1346
g1363
sg1348
g1347
sg1350
g1420
sa(dp1494
S'block.thisTrialN'
p1495
I17
sS'block.thisRepN'
p1496
I0
sg29
g33
sS'block.thisN'
p1497
I17
sg1333
(S'HALF'
S'ADD'
S'x'
S'y'
tp1498
sg27
g28
sg1335
I2
sg1336
(I12
I6
tp1499
sg22
I1
sg20
F0.69472445853170939
sg23
F2.0558611101296265
sVY
I8
sVX
I4
sg1338
I0
sg35
g36
sg37
g38
sg21
S'6'
sg19
S'space'
p1500
sg34
g11
sg1341
I6
sg1342
g1362
sg1344
I6
sS'block.thisIndex'
p1501
I3
sg1346
g1343
sg1348
I0
sg1350
g1374
sasS'loops'
p1502
(lp1503
g1
(cpsychopy.data
TrialHandler
p1504
g3
NtRp1505
(dp1506
S'origin'
p1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1508
sS'thisTrial'
p1509
(lp1510
sS'_exp'
p1511
I87590064
sg10
S'practice_trials'
p1512
sg6
S'C:\\Users\\CCDL\\Desktop\\Experiments\\KRITL\\kritl.py'
p1513
sS'thisRepN'
p1514
I1
sg24
I01
sg25
g26
sS'data'
p1515
g1
(cpsychopy.data
DataHandler
p1516
c__builtin__
dict
p1517
(dp1518
g15
cnumpy.ma.core
_mareconstruct
p1519
(cnumpy.ma.core
MaskedArray
p1520
cnumpy
ndarray
p1521
(I0
tp1522
S'b'
tRp1523
(I1
(I6
I1
tg31
(S'O4'
I0
I1
tRp1524
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'P\xfd\xbd\x04\x90>\xbc\x04`2\xc0\x04p\xab\xd4\x04h\xae\xef\x04Ph\xbf\x04'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg16
g1519
(g1520
g1521
g1522
S'b'
tRp1525
(I1
(I6
I1
tg1524
I00
S' \x03#\x02P\xc9\xcc\x01 \x03#\x02P\xc9\xcc\x01\x08\x03#\x02x\x925\x02'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'ran'
p1526
g1519
(g1520
g1521
g1522
S'b'
tRp1527
(I1
(I6
I1
tg31
(S'f4'
I0
I1
tRp1528
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg18
g1519
(g1520
g1521
g1522
S'b'
tRp1529
(I1
(I6
I1
tg1528
I00
S'\x1a?\xee?W\x01\xa7?(\x97\xd9?\x02!WA\x1b\xea9@\xb8J>A'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg14
g1519
(g1520
g1521
g1522
S'b'
tRp1530
(I1
(I6
I1
tg1524
I00
S'8\xfc\xbd\x04\xb0\xcc\xbc\x04\xb0\xcc\xbf\x04\xe8\xab\xd4\x04\xe8\xe1\x0b\x05`g\xbf\x04'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1531
g1519
(g1520
g1521
g1522
S'b'
tRp1532
(I1
(I6
I1
tg1528
I00
S'\x00\x00@@\x00\x00\x00@\x00\x00\xa0@\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80@'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1519
(g1520
g1521
g1522
S'b'
tRp1533
(I1
(I6
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
NtbstRp1534
(dp1535
S'isNumeric'
p1536
(dp1537
g16
I00
sg1526
I01
sg18
I01
sg14
I00
sg17
I01
sg1531
I01
sg15
I00
ssS'trials'
p1538
g1505
sS'dataTypes'
p1539
(lp1540
g1526
ag1531
ag14
ag15
ag16
ag17
ag18
asS'dataShape'
p1541
(lp1542
I6
aI1
asbsS'method'
p1543
S'fullRandom'
p1544
sS'sequenceIndices'
p1545
cnumpy.core.multiarray
_reconstruct
p1546
(g1521
(I0
tS'b'
tRp1547
(I1
(I6
I1
tg1524
I00
(lp1548
I3
aI4
aI1
aI0
aI5
aI2
atbsS'finished'
p1549
I01
sS'nReps'
p1550
I1
sS'nRemaining'
p1551
I-1
sS'trialList'
p1552
(lp1553
g1
(cpsychopy.data
TrialType
p1554
g1517
(dp1555
g47
I0
sg48
g68
sg49
g90
sg50
I7
sg53
I2
sg52
I0
sg51
I5
sg54
I3
stRp1556
ag1
(g1554
g1517
(dp1557
g47
I0
sg48
g90
sg49
g91
sg50
I8
sg53
I2
sg52
I0
sg51
I3
sg54
I3
stRp1558
ag1
(g1554
g1517
(dp1559
g47
I0
sg48
g68
sg49
g70
sg50
I7
sg53
I2
sg52
I0
sg51
I5
sg54
I4
stRp1560
ag1
(g1554
g1517
(dp1561
g47
g68
sg48
g69
sg49
g70
sg50
I8
sg53
I3
sg52
I0
sg51
I2
sg54
I4
stRp1562
ag1
(g1554
g1517
(dp1563
g47
g79
sg48
g80
sg49
g81
sg50
I3
sg53
I3
sg52
I0
sg51
I3
sg54
I2
stRp1564
ag1
(g1554
g1517
(dp1565
g47
g79
sg48
g80
sg49
g108
sg50
I9
sg53
I4
sg52
g81
sg51
I8
sg54
I8
stRp1566
asS'seed'
p1567
NsS'thisIndex'
p1568
I2
sS'thisN'
p1569
I6
sS'thisTrialN'
p1570
I0
sS'nTotal'
p1571
I6
sS'_warnUseOfNext'
p1572
I01
sbag1
(g1504
g3
NtRp1573
(dp1574
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1575
sg1509
(lp1576
sg1511
I87590064
sg10
S'block'
p1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1578
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1579
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1580
(I1
(I18
I1
tg1524
I00
S' \x0f\xbe\x04\xe0\xcc\xeb\x04 Q\xa0\x04 \\\xbf\x04\xe0W\xa0\x04`\xef\x9d\x04\x00\xd9\x9f\x04\xa0\xba\xea\x04\xa0n\xec\x04\xc0\xf2\x9e\x04\xe0\xda\x9c\x04\xc0c\xe9\x04@g\xbd\x04\xe0\xe6\x9d\x04\x00\x1b\xb1\x04\x00\xe8\xe9\x04\xe0\r\xbf\x04\xa0\xfc\x9e\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1581
(I1
(I18
I1
tg1528
I00
S'\xfa\xa5\r@\x97*H@l\x1b\xf0?\x9b\xa2/@f\x83\xf8@(\xa6\xf8?\x97\xc0\xff@-\x11O@\xfa\xfc\xa0@\xce\xa72@n2w@\xbe\xe0\xc6@\xd0P\x00A\\\xed\xa0@\xd1\xb9\x0fA\xa1\x84\x8d@2\x03p@\xee\xcab@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1582
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1583
(I1
(I18
I1
tg1524
I00
S' \x03#\x02x\x02#\x02P\xc9\xcc\x01P\xc9\xcc\x01h\xcc\xcc\x01h\xcc\xcc\x01x\x925\x02x\x02#\x02 \x03#\x02\x00\xc8\xcc\x01x\x02#\x02P\xc9\xcc\x01\x08\x03#\x02h\xcc\xcc\x01 \x03#\x02\xc0\x02#\x02P\xc9\xcc\x01\x08\x03#\x02'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1584
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x00A\x00\x00@@\x00\x00`A\x00\x00\xc0@\x00\x00PA\x00\x00 A\x00\x00@A\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80A\x00\x00\x00@\x00\x00\xa0@\x00\x00\x10A\x00\x00\x88A\x00\x00pA\x00\x00\x80@\x00\x00\xe0@\x00\x000A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1585
(I1
(I18
I1
tg1528
I00
S':\x99A?\xde\xaa\x87?\x1b>#@\x8a\xd2n?\xd4q4@\x95\xdcC@\xf1\xe3\x9f@)v\x13AJ\x8f\x14A\xd5\xbfl@(e\xde@\xdf\xe9\rA\x82\xb9\x10A\xe5X\x00A\xfa`\x02A\xed\n\xe5@v\x0e\xe5@T8\x1bA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1586
(dp1587
g1536
(dp1588
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1573
sg1539
(lp1589
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1590
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1591
(I1
(I18
I1
tg1524
I00
(lp1592
I7
aI8
aI10
aI1
aI15
aI11
aI3
aI16
aI0
aI12
aI5
aI17
aI6
aI4
aI2
aI14
aI9
aI13
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1593
g1
(g1554
g1517
(dp1594
g55
g209
sVY
I6
sg57
I2
sg58
g210
sg59
I7
sg60
I7
sg56
g130
sVX
I3
sg61
I0
sg62
g203
sg63
I0
sg64
g166
stRp1595
ag1
(g1554
g1517
(dp1596
g55
g162
sVY
I4
sg57
I2
sg58
g163
sg59
I2
sg60
I2
sg56
g134
sVX
I5
sg61
I0
sg62
g132
sg63
I0
sg64
g166
stRp1597
ag1
(g1554
g1517
(dp1598
g55
g259
sVY
I2
sg57
I2
sg58
g260
sg59
I8
sg60
I8
sg56
g203
sVX
I2
sg61
I0
sg62
g155
sg63
I0
sg64
g194
stRp1599
ag1
(g1554
g1517
(dp1600
g55
g190
sVY
I2
sg57
I2
sg58
g191
sg59
I8
sg60
I8
sg56
g185
sVX
I2
sg61
I0
sg62
g155
sg63
I0
sg64
g194
stRp1601
ag1
(g1554
g1517
(dp1602
g55
g251
sVY
I3
sg57
I3
sg58
g252
sg59
I4
sg60
I4
sg56
g144
sVX
I8
sg61
g182
sg62
g142
sg63
I0
sg64
g230
stRp1603
ag1
(g1554
g1517
(dp1604
g55
g226
sVY
I2
sg57
I3
sg58
g227
sg59
I4
sg60
I4
sg56
g130
sVX
I3
sg61
g155
sg62
g185
sg63
I0
sg64
g230
stRp1605
ag1
(g1554
g1517
(dp1606
g55
g243
sVY
I2
sg57
I3
sg58
g244
sg59
I9
sg60
I9
sg56
g203
sVX
I2
sg61
g144
sg62
g134
sg63
I0
sg64
g135
stRp1607
ag1
(g1554
g1517
(dp1608
g55
g128
sVY
I2
sg57
I3
sg58
g129
sg59
I2
sg60
I2
sg56
g132
sVX
I9
sg61
g130
sg62
g134
sg63
I0
sg64
g135
stRp1609
ag1
(g1554
g1517
(dp1610
g55
g140
sVY
I4
sg57
I3
sg58
g141
sg59
I5
sg60
I5
sg56
g144
sVX
I8
sg61
g142
sg62
g146
sg63
I0
sg64
g147
stRp1611
ag1
(g1554
g1517
(dp1612
g55
g275
sVY
I6
sg57
I3
sg58
g276
sg59
I1
sg60
I1
sg56
g134
sVX
I8
sg61
g132
sg62
g130
sg63
I0
sg64
g147
stRp1613
ag1
(g1554
g1517
(dp1614
g55
g152
sVY
I3
sg57
I4
sg58
g153
sg59
I2
sg60
I2
sg56
g155
sVX
I6
sg61
g134
sg62
g142
sg63
g130
sg64
g157
stRp1615
ag1
(g1554
g1517
(dp1616
g55
g180
sVY
I2
sg57
I4
sg58
g181
sg59
I8
sg60
I8
sg56
g134
sVX
I2
sg61
g182
sg62
g185
sg63
g144
sg64
g157
stRp1617
ag1
(g1554
g1517
(dp1618
g55
g217
sVY
I3
sg57
I4
sg58
g218
sg59
I3
sg60
I3
sg56
g142
sVX
I4
sg61
g144
sg62
g134
sg63
g182
sg64
g221
stRp1619
ag1
(g1554
g1517
(dp1620
g55
g283
sVY
I3
sg57
I4
sg58
g284
sg59
I4
sg60
I4
sg56
g185
sVX
I7
sg61
g182
sg62
g130
sg63
g134
sg64
g221
stRp1621
ag1
(g1554
g1517
(dp1622
g55
g267
sVY
I4
sg57
I4
sg58
g268
sg59
I7
sg60
I7
sg56
g134
sVX
I8
sg61
g203
sg62
g130
sg63
g155
sg64
g175
stRp1623
ag1
(g1554
g1517
(dp1624
g55
g171
sVY
I3
sg57
I4
sg58
g172
sg59
I6
sg60
I6
sg56
g155
sVX
I5
sg61
g132
sg62
g144
sg63
g146
sg64
g175
stRp1625
ag1
(g1554
g1517
(dp1626
g55
g199
sVY
I2
sg57
I4
sg58
g200
sg59
I8
sg60
I8
sg56
g144
sVX
I4
sg61
g182
sg62
g146
sg63
g203
sg64
g204
stRp1627
ag1
(g1554
g1517
(dp1628
g55
g235
sVY
I5
sg57
I4
sg58
g236
sg59
I3
sg60
I3
sg56
g146
sVX
I9
sg61
g182
sg62
g144
sg63
g132
sg64
g204
stRp1629
asg1567
Nsg1568
I13
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1630
(dp1631
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1632
sg1509
(lp1633
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1634
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1635
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1636
(I1
(I18
I1
tg1524
I00
S'\x80k\xec\x04\x80w\x9e\x04\x80\xdaf\x0e {\x9f\x04 \x19\xb3\x04 n\xe9\x04`j\xe9\x04 Bf\x0e@\xe5\xef\x04\x80\x9e\xb1\x04\xe0\x16\xb3\x04\xc0U\xeb\x04\x80T\xbf\x04\x80\xe8\xe9\x04\x80Z\xbf\x04 \n\xbe\x04\xa0\x1b\xb4\x04\xc0\xeee\x0e'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1637
(I1
(I18
I1
tg1528
I00
S'\x05\x96\x04@\xe4s0@\xc3.\x1e@\x03\xc1\xa4?\x12\x9c\xb2?#(r@\xda|0@\xa4f\x87@\xdc\xa8d@$\x97{?pa\xb2@\xee\xc9\xd8@\xe7\x95\\@B\x01H@\xc5\xd6\xf1@d\xde=@\xb2\x1b\x91@|\xd4\tA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1638
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1639
(I1
(I18
I1
tg1524
I00
S'x\x02#\x02\x08\x03#\x02\x00\xc8\xcc\x01\xc0\x02#\x02x\x925\x02h\xcc\xcc\x01\xc0\x02#\x02\x08\x03#\x02 \x03#\x02\x00\xc8\xcc\x01P\xc9\xcc\x01P\xc9\xcc\x01P\xc9\xcc\x01x\x02#\x02P\xc9\xcc\x01\x00\xc8\xcc\x01\xc0\x02#\x02\xc0\x02#\x02'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1640
(I1
(I18
I1
tg1528
I00
S'\x00\x00\xc0@\x00\x00@A\x00\x00\x88A\x00\x00PA\x00\x00\x80@\x00\x00\x80?\x00\x00\x00A\x00\x00pA\x00\x000A\x00\x00@@\x00\x00\xa0@\x00\x00\x00@\x00\x00\x00\x00\x00\x00\xe0@\x00\x00 A\x00\x00\x10A\x00\x00`A\x00\x00\x80A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1641
(I1
(I18
I1
tg1528
I00
S"\\A}@!\x16s?>k1?\xe6\x8f\xc5?\x7f\xa8\xfa?\xc2\xff'A\xb0\xa7\r@\xaa\xf4\xc9@,\xc8\x0e@\xe0I\x85@1\x19\xd2@\x99\xfb\xf9@\x1d/\x1eA\x1e\x9e\xfc@\x03\xb2\x04A\x12\xa1\xe9@_\xb5\x99@\xb5e\xb5@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1642
(dp1643
g1536
(dp1644
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1630
sg1539
(lp1645
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1646
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1647
(I1
(I18
I1
tg1524
I00
(lp1648
I12
aI5
aI11
aI9
aI4
aI10
aI0
aI13
aI6
aI15
aI14
aI8
aI1
aI3
aI16
aI7
aI17
aI2
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1649
g1
(g1554
g1517
(dp1650
g291
g362
sVY
I2
sg293
I2
sg294
g363
sg302
I2
sg299
I2
sg300
g297
sVX
I3
sg296
I0
sg304
g320
sg306
I0
sg308
g366
stRp1651
ag1
(g1554
g1517
(dp1652
g291
g415
sVY
I2
sg293
I2
sg294
g416
sg302
I3
sg299
I3
sg300
g318
sVX
I6
sg296
I0
sg304
g330
sg306
I0
sg308
g366
stRp1653
ag1
(g1554
g1517
(dp1654
g291
g457
sVY
I4
sg293
I2
sg294
g458
sg302
I1
sg299
I1
sg300
g320
sVX
I8
sg296
I0
sg304
g318
sg306
I0
sg308
g427
stRp1655
ag1
(g1554
g1517
(dp1656
g291
g423
sVY
I2
sg293
I2
sg294
g424
sg302
I6
sg299
I6
sg300
g301
sVX
I3
sg296
I0
sg304
g297
sg306
I0
sg308
g427
stRp1657
ag1
(g1554
g1517
(dp1658
g291
g346
sVY
I8
sg293
I3
sg294
g347
sg302
I9
sg299
I9
sg300
g339
sVX
I6
sg296
g307
sg304
g301
sg306
I0
sg308
g321
stRp1659
ag1
(g1554
g1517
(dp1660
g291
g314
sVY
I2
sg293
I3
sg294
g315
sg302
I4
sg299
I4
sg300
g318
sVX
I3
sg296
g316
sg304
g320
sg306
I0
sg308
g321
stRp1661
ag1
(g1554
g1517
(dp1662
g291
g380
sVY
I3
sg293
I3
sg294
g381
sg302
I6
sg299
I6
sg300
g301
sVX
I3
sg296
g316
sg304
g339
sg306
I0
sg308
g384
stRp1663
ag1
(g1554
g1517
(dp1664
g291
g441
sVY
I2
sg293
I3
sg294
g442
sg302
I3
sg299
I3
sg300
g330
sVX
I8
sg296
g339
sg304
g297
sg306
I0
sg308
g384
stRp1665
ag1
(g1554
g1517
(dp1666
g291
g407
sVY
I3
sg293
I3
sg294
g408
sg302
I7
sg299
I7
sg300
g316
sVX
I6
sg296
g320
sg304
g297
sg306
I0
sg308
g341
stRp1667
ag1
(g1554
g1517
(dp1668
g291
g336
sVY
I3
sg293
I3
sg294
g337
sg302
I1
sg299
I1
sg300
g339
sVX
I3
sg296
g301
sg304
g307
sg306
I0
sg308
g341
stRp1669
ag1
(g1554
g1517
(dp1670
g291
g354
sVY
I6
sg293
I4
sg294
g355
sg302
I8
sg299
I8
sg300
g305
sVX
I6
sg296
g318
sg304
g301
sg306
g307
sg308
g331
stRp1671
ag1
(g1554
g1517
(dp1672
g291
g326
sVY
I9
sg293
I4
sg294
g327
sg302
I8
sg299
I8
sg300
g318
sVX
I3
sg296
g316
sg304
g330
sg306
g305
sg308
g331
stRp1673
ag1
(g1554
g1517
(dp1674
g291
g292
sVY
I2
sg293
I4
sg294
g295
sg302
I8
sg299
I8
sg300
g301
sVX
I3
sg296
g297
sg304
g305
sg306
g307
sg308
g309
stRp1675
ag1
(g1554
g1517
(dp1676
g291
g371
sVY
I3
sg293
I4
sg294
g372
sg302
I2
sg299
I2
sg300
g374
sVX
I2
sg296
g305
sg304
g307
sg306
g318
sg308
g309
stRp1677
ag1
(g1554
g1517
(dp1678
g291
g399
sVY
I7
sg293
I4
sg294
g400
sg302
I8
sg299
I8
sg300
g305
sVX
I6
sg296
g301
sg304
g307
sg306
g318
sg308
g394
stRp1679
ag1
(g1554
g1517
(dp1680
g291
g389
sVY
I9
sg293
I4
sg294
g390
sg302
I1
sg299
I1
sg300
g392
sVX
I9
sg296
g320
sg304
g307
sg306
g305
sg308
g394
stRp1681
ag1
(g1554
g1517
(dp1682
g291
g432
sVY
I3
sg293
I4
sg294
g433
sg302
I6
sg299
I6
sg300
g316
sVX
I9
sg296
g297
sg304
g339
sg306
g320
sg308
g436
stRp1683
ag1
(g1554
g1517
(dp1684
g291
g449
sVY
I4
sg293
I4
sg294
g450
sg302
I6
sg299
I6
sg300
g305
sVX
I2
sg296
g297
sg304
g307
sg306
g374
sg308
g436
stRp1685
asg1567
Nsg1568
I2
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1686
(dp1687
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1688
sg1509
(lp1689
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1690
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1691
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1692
(I1
(I18
I1
tg1524
I00
S'\xc0\xb6\xd3\x04\xc0p\xf7\x04\xe0\x03\xf9\x04\xa0\x06\xd3\x04\xc0\xd7f\x0e\x80M\xf2\x04\x80\x12\xb4\x04 =\xd3\x04@\xca\xd3\x04`\x13\xf7\x04\xe04\xf6\x04\xc0\xcc\xd3\x04 R\xa0\x04 \x8c\xd1\x04\x00\x85\xf2\x04 \x1d\xf7\x04 ,\xd4\x04\xa0:\xd3\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1693
(I1
(I18
I1
tg1528
I00
S"9\xe4\xd3?\xb4\x9d5@\xe8\xd2\xdf?Y\xed\x89@\xe7\xfeE@\xf3\xdb\nA\x07\xaf3@\x86\xa7\x0c@d\x80.@\xc8\xd2\x15@\x82\xdaD@\x99'-A\xda\x1et@\xf1x/@\xc6\x9d\xe7@Ve\x86@\xd5C\x9a@\x8a\xf8\xb5@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1694
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1695
(I1
(I18
I1
tg1524
I00
S'P\xc9\xcc\x01x\x02#\x02x\x02#\x02P\xc9\xcc\x01\x00\xc8\xcc\x01x\x02#\x02\x00\xc8\xcc\x01x\x02#\x02P\xc9\xcc\x01\xc0\x02#\x02 \x03#\x02\x00\xc8\xcc\x01x\x925\x02 \x03#\x02\x08\x03#\x02\xc0\x02#\x02\x08\x86,\x02h\xcc\xcc\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1696
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x10A\x00\x00\x00\x00\x00\x00\x80A\x00\x00\xc0@\x00\x00pA\x00\x00@@\x00\x00PA\x00\x00\xa0@\x00\x00\x80@\x00\x000A\x00\x00\x80?\x00\x00 A\x00\x00`A\x00\x00\x88A\x00\x00\xe0@\x00\x00@A\x00\x00\x00@\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1697
(I1
(I18
I1
tg1528
I00
S'\xc4\xcbY?\xbc\xb8#@qE\x98?\x90\xf4f?%\x9d\x0b@8O\xe8?\xdf\x04K@\xc9\xb1e@\x95\xfcF@\r)\x80@\x92\xc4\x97@\x99\xdb\x89@\x81q\xe1@35\xbd@P\xc2\x83@T\xf6\xf4@\x04oO@.\xf3\xb5@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1698
(dp1699
g1536
(dp1700
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1686
sg1539
(lp1701
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1702
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1703
(I1
(I18
I1
tg1524
I00
(lp1704
I1
aI10
aI16
aI5
aI8
aI7
aI3
aI14
aI17
aI0
aI11
aI9
aI15
aI6
aI12
aI4
aI2
aI13
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1705
g1
(g1554
g1517
(dp1706
g465
g565
sVY
I4
sg467
I2
sg468
g566
sg475
I8
sg472
I8
sg473
g474
sVX
I2
sg470
I0
sg477
g492
sg479
I0
sg480
g481
stRp1707
ag1
(g1554
g1517
(dp1708
g465
g466
sVY
I6
sg467
I2
sg468
g469
sg475
I2
sg472
I2
sg473
g474
sVX
I6
sg470
I0
sg477
g478
sg479
I0
sg480
g481
stRp1709
ag1
(g1554
g1517
(dp1710
g465
g623
sVY
I7
sg467
I2
sg468
g624
sg475
I2
sg472
I2
sg473
g514
sVX
I8
sg470
I0
sg477
g474
sg479
I0
sg480
g543
stRp1711
ag1
(g1554
g1517
(dp1712
g465
g538
sVY
I4
sg467
I2
sg468
g539
sg475
I8
sg472
I8
sg473
g541
sVX
I4
sg470
I0
sg477
g493
sg479
I0
sg480
g543
stRp1713
ag1
(g1554
g1517
(dp1714
g465
g615
sVY
I4
sg467
I3
sg468
g616
sg475
I1
sg472
I1
sg473
g474
sVX
I6
sg470
g490
sg477
g478
sg479
I0
sg480
g515
stRp1715
ag1
(g1554
g1517
(dp1716
g465
g510
sVY
I4
sg467
I3
sg468
g511
sg475
I2
sg472
I2
sg473
g493
sVX
I4
sg470
g501
sg477
g514
sg479
I0
sg480
g515
stRp1717
ag1
(g1554
g1517
(dp1718
g465
g597
sVY
I7
sg467
I3
sg468
g598
sg475
I1
sg472
I1
sg473
g514
sVX
I3
sg470
g501
sg477
g493
sg479
I0
sg480
g533
stRp1719
ag1
(g1554
g1517
(dp1720
g465
g529
sVY
I3
sg467
I3
sg468
g530
sg475
I2
sg472
I2
sg473
g478
sVX
I9
sg470
g490
sg477
g488
sg479
I0
sg480
g533
stRp1721
ag1
(g1554
g1517
(dp1722
g465
g520
sVY
I2
sg467
I3
sg468
g521
sg475
I8
sg472
I8
sg473
g504
sVX
I7
sg470
g514
sg477
g474
sg479
I0
sg480
g524
stRp1723
ag1
(g1554
g1517
(dp1724
g465
g581
sVY
I3
sg467
I3
sg468
g582
sg475
I6
sg472
I6
sg473
g501
sVX
I4
sg470
g514
sg477
g474
sg479
I0
sg480
g524
stRp1725
ag1
(g1554
g1517
(dp1726
g465
g486
sVY
I6
sg467
I4
sg468
g487
sg475
I7
sg472
I7
sg473
g490
sVX
I4
sg470
g488
sg477
g492
sg479
g493
sg480
g494
stRp1727
ag1
(g1554
g1517
(dp1728
g465
g573
sVY
I5
sg467
I4
sg468
g574
sg475
I1
sg472
I1
sg473
g488
sVX
I6
sg470
g474
sg477
g478
sg479
g490
sg480
g494
stRp1729
ag1
(g1554
g1517
(dp1730
g465
g605
sVY
I4
sg467
I4
sg468
g606
sg475
I9
sg472
I9
sg473
g492
sVX
I9
sg470
g474
sg477
g609
sg479
g490
sg480
g610
stRp1731
ag1
(g1554
g1517
(dp1732
g465
g631
sVY
I4
sg467
I4
sg468
g632
sg475
I7
sg472
I7
sg473
g541
sVX
I3
sg470
g474
sg477
g504
sg479
g490
sg480
g610
stRp1733
ag1
(g1554
g1517
(dp1734
g465
g548
sVY
I6
sg467
I4
sg468
g549
sg475
I3
sg472
I3
sg473
g490
sVX
I4
sg470
g541
sg477
g504
sg479
g493
sg480
g552
stRp1735
ag1
(g1554
g1517
(dp1736
g465
g589
sVY
I8
sg467
I4
sg468
g590
sg475
I6
sg472
I6
sg473
g501
sVX
I9
sg470
g478
sg477
g474
sg479
g504
sg480
g552
stRp1737
ag1
(g1554
g1517
(dp1738
g465
g499
sVY
I2
sg467
I4
sg468
g500
sg475
I5
sg472
I5
sg473
g493
sVX
I8
sg470
g501
sg477
g504
sg479
g478
sg480
g505
stRp1739
ag1
(g1554
g1517
(dp1740
g465
g557
sVY
I4
sg467
I4
sg468
g558
sg475
I4
sg472
I4
sg473
g504
sVX
I4
sg470
g501
sg477
g474
sg479
g478
sg480
g505
stRp1741
asg1567
Nsg1568
I13
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1742
(dp1743
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1744
sg1509
(lp1745
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1746
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1747
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1748
(I1
(I18
I1
tg1524
I00
S' \xb8\xd3\x04`H\xf2\x04\x00\x0c\xf9\x04\xc0y\xf7\x04\xa0Lf\x0e@\xb7\xd3\x04\xe01\xd3\x04\xc0\x89\xf2\x04`\xfb\x10\x05\xa0 \xd4\x04\x80p\xf7\x04\x00\xf9\x10\x05\x80F\xf2\x04\x80\x10\xb4\x04  \xd4\x04\x00\xb2\x0e\x05\xa0\xed\xd1\x04\xc0\x9a\xf8\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1749
(I1
(I18
I1
tg1528
I00
S'\x88m-@G\xf2\x18@\xb3\xf4\x93?\x82r\x03@\x81\x08\x8d@\xeae-Au~\x05@\x8d\xf3\x15@\x82*w@\xac\xc9\xc1@\xc6\xf5\xa0@\xaa\xddD@G\xb9e@}\x89=A\xdd\xdc\xc5@\xfaw\x1bA\x00\x00\x00\x00\xc4R\x9a@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1750
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1751
(I1
(I18
I1
tg1524
I00
S'\x00\xc8\xcc\x01h\xcc\xcc\x01x\x925\x02\xc0\x02#\x02\xc0\x02#\x02 \x03#\x02P\xc9\xcc\x01x\x02#\x02\x00\xc8\xcc\x01x\x925\x02\x00\xc8\xcc\x01x\x02#\x02\x00\xc8\xcc\x01x\x02#\x02 \x03#\x02\x00\xc8\xcc\x01\xcc\x18\x1f\x1e\x08\x86,\x02'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1752
(I1
(I18
I1
tg1528
I00
S'\x00\x00@A\x00\x00PA\x00\x00\x80?\x00\x00\x88A\x00\x00\x00\x00\x00\x00\xc0@\x00\x00\xe0@\x00\x00 A\x00\x00@@\x00\x00\x80@\x00\x00\x00@\x00\x00pA\x00\x00\xa0@\x00\x00\x80A\x00\x00`A\x00\x000A\x00\x00\x00A\x00\x00\x10A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1753
(I1
(I18
I1
tg1528
I00
S"\x0b1R?\x1e\xa6\xb4?\x0f\xa6=?\xda\xd0\x12@R\x8d\x1b@:\x9c5@*\x9f5@\xd2 \xe8?\xf5\x8c/@\xc0?\xc4@\x17\\\x87@\x14\xe6\xc8@\x9e\n\xa2@d\xec\x8b@\x0f5x@cL\x97@{\xa6\x94@'1\x02A"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1754
(dp1755
g1536
(dp1756
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1742
sg1539
(lp1757
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1758
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1759
(I1
(I18
I1
tg1524
I00
(lp1760
I4
aI2
aI10
aI8
aI9
aI12
aI5
aI6
aI16
aI17
aI7
aI15
aI0
aI1
aI14
aI11
aI13
aI3
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1761
g1
(g1554
g1517
(dp1762
g639
g763
sVY
I2
sg641
I2
sg642
g764
sg650
I1
sg647
I1
sg648
g674
sVX
I9
sg644
I0
sg652
g715
sg654
I0
sg655
g767
stRp1763
ag1
(g1554
g1517
(dp1764
g639
g772
sVY
I4
sg641
I2
sg642
g773
sg650
I4
sg647
I4
sg648
g674
sVX
I3
sg644
I0
sg652
g664
sg654
I0
sg655
g767
stRp1765
ag1
(g1554
g1517
(dp1766
g639
g661
sVY
I4
sg641
I2
sg642
g662
sg650
I9
sg647
I9
sg648
g664
sVX
I2
sg644
I0
sg652
g666
sg654
I0
sg655
g667
stRp1767
ag1
(g1554
g1517
(dp1768
g639
g804
sVY
I6
sg641
I2
sg642
g805
sg650
I6
sg647
I6
sg648
g715
sVX
I8
sg644
I0
sg652
g697
sg654
I0
sg655
g667
stRp1769
ag1
(g1554
g1517
(dp1770
g639
g640
sVY
I4
sg641
I3
sg642
g643
sg650
I6
sg647
I6
sg648
g649
sVX
I6
sg644
g645
sg652
g653
sg654
I0
sg655
g656
stRp1771
ag1
(g1554
g1517
(dp1772
g639
g711
sVY
I9
sg641
I3
sg642
g712
sg650
I7
sg647
I7
sg648
g678
sVX
I9
sg644
g649
sg652
g715
sg654
I0
sg655
g656
stRp1773
ag1
(g1554
g1517
(dp1774
g639
g720
sVY
I4
sg641
I3
sg642
g721
sg650
I8
sg647
I8
sg648
g664
sVX
I3
sg644
g674
sg652
g678
sg654
I0
sg655
g724
stRp1775
ag1
(g1554
g1517
(dp1776
g639
g746
sVY
I2
sg641
I3
sg642
g747
sg650
I2
sg647
I2
sg648
g677
sVX
I4
sg644
g645
sg652
g666
sg654
I0
sg655
g724
stRp1777
ag1
(g1554
g1517
(dp1778
g639
g684
sVY
I2
sg641
I3
sg642
g685
sg650
I1
sg647
I1
sg648
g645
sVX
I8
sg644
g677
sg652
g649
sg654
I0
sg655
g688
stRp1779
ag1
(g1554
g1517
(dp1780
g639
g693
sVY
I3
sg641
I3
sg642
g694
sg650
I9
sg647
I9
sg648
g645
sVX
I2
sg644
g664
sg652
g697
sg654
I0
sg655
g688
stRp1781
ag1
(g1554
g1517
(dp1782
g639
g672
sVY
I3
sg641
I4
sg642
g673
sg650
I1
sg647
I1
sg648
g649
sVX
I6
sg644
g674
sg652
g677
sg654
g678
sg655
g679
stRp1783
ag1
(g1554
g1517
(dp1784
g639
g788
sVY
I2
sg641
I4
sg642
g789
sg650
I2
sg647
I2
sg648
g649
sVX
I3
sg644
g674
sg652
g664
sg654
g678
sg655
g679
stRp1785
ag1
(g1554
g1517
(dp1786
g639
g702
sVY
I9
sg641
I4
sg642
g703
sg650
I1
sg647
I1
sg648
g677
sVX
I3
sg644
g697
sg652
g649
sg654
g678
sg655
g706
stRp1787
ag1
(g1554
g1517
(dp1788
g639
g796
sVY
I3
sg641
I4
sg642
g797
sg650
I3
sg647
I3
sg648
g715
sVX
I6
sg644
g666
sg652
g697
sg654
g645
sg655
g706
stRp1789
ag1
(g1554
g1517
(dp1790
g639
g780
sVY
I2
sg641
I4
sg642
g781
sg650
I7
sg647
I7
sg648
g645
sVX
I2
sg644
g664
sg652
g666
sg654
g697
sg655
g758
stRp1791
ag1
(g1554
g1517
(dp1792
g639
g754
sVY
I2
sg641
I4
sg642
g755
sg650
I1
sg647
I1
sg648
g666
sVX
I8
sg644
g715
sg652
g674
sg654
g645
sg655
g758
stRp1793
ag1
(g1554
g1517
(dp1794
g639
g729
sVY
I2
sg641
I4
sg642
g730
sg650
I5
sg647
I5
sg648
g645
sVX
I2
sg644
g697
sg652
g649
sg654
g653
sg655
g733
stRp1795
ag1
(g1554
g1517
(dp1796
g639
g738
sVY
I2
sg641
I4
sg642
g739
sg650
I7
sg647
I7
sg648
g697
sVX
I2
sg644
g645
sg652
g666
sg654
g653
sg655
g733
stRp1797
asg1567
Nsg1568
I3
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1798
(dp1799
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1800
sg1509
(lp1801
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1802
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1803
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1804
(I1
(I18
I1
tg1524
I00
S'\xc0u\xf7\x04\xc0\xc5\xd3\x04\xc0\x07\xf9\x04\x00\xdd\xf8\x04\xe0S\xf5\x04\xa0\xd7f\x0e\x00{\r\x05 \xb6\x0e\x05\xc0\xf0\x10\x05\xa0\xce\xd3\x04 A\xf8\x04\x00y\r\x05\xe0\x17\xf7\x04@\xf3\xf3\x04\x80\xd2\xf8\x04\xe0\x80\xf2\x04@\xcb\xf5\x04@3\xd3\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1805
(I1
(I18
I1
tg1528
I00
S'\xd8\x941@"\xba\x96@\xad\xbe\x83@\xfc\x9d\xf2?1\xf3\xca@\x13p\x8b@\xa0\xc6\x81@\xf3B\xea?o\xb4\x92@\x16\xa47@\x08cV@\xd32L@\xd2\xf5:AS\xe1n@\xca=\xf0?\xb7`\xf3@(\xad7@\xccQ\xb1@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1806
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1807
(I1
(I18
I1
tg1524
I00
S' \x03#\x02x\x925\x02x\x02#\x02\x08\x86,\x02x\x925\x02\x08\x03#\x02P\xc9\xcc\x01x\x02#\x02x\x925\x02\xc0\x02#\x02\x08\x86,\x02x\x925\x02\x08\x86,\x02\x08\x03#\x02\xc0\x02#\x02x\x925\x02\x08\x86,\x02\x08\x86,\x02'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1808
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80@\x00\x00\x80A\x00\x00@@\x00\x00@A\x00\x00\xc0@\x00\x00\x80?\x00\x000A\x00\x00PA\x00\x00\x88A\x00\x00\x00A\x00\x00\x00@\x00\x00`A\x00\x00\xe0@\x00\x00\x00\x00\x00\x00 A\x00\x00pA\x00\x00\xa0@\x00\x00\x10A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1809
(I1
(I18
I1
tg1528
I00
S'\x0cK\x85@\x87\xa1A?\xbd\xa5^?\x98\x0fI@\xc3m\x02@\x9a\xb9\x83@\r4N@T*x@\xfe(\x81@{\xeag@\x9d\xdc\xc9@N\xbc\x83@\x02(!@\x80N\xf9@\xb4\xd9\x9b@\x188\xc3@1\xa7c@\xc4\x84\xa5@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1810
(dp1811
g1536
(dp1812
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1798
sg1539
(lp1813
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1814
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1815
(I1
(I18
I1
tg1524
I00
(lp1816
I13
aI5
aI10
aI2
aI0
aI16
aI4
aI12
aI9
aI17
aI14
aI6
aI3
aI7
aI11
aI15
aI1
aI8
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1817
g1
(g1554
g1517
(dp1818
g812
g866
sVY
I5
sg814
I2
sg815
g867
sg823
I7
sg820
I7
sg821
g828
sVX
I4
sg817
I0
sg825
g870
sg827
I0
sg829
g871
stRp1819
ag1
(g1554
g1517
(dp1820
g812
g970
sVY
I3
sg814
I2
sg815
g971
sg823
I9
sg820
I9
sg821
g818
sVX
I4
sg817
I0
sg825
g839
sg827
I0
sg829
g871
stRp1821
ag1
(g1554
g1517
(dp1822
g812
g856
sVY
I8
sg814
I2
sg815
g857
sg823
I2
sg820
I2
sg821
g850
sVX
I8
sg817
I0
sg825
g860
sg827
I0
sg829
g861
stRp1823
ag1
(g1554
g1517
(dp1824
g812
g938
sVY
I2
sg814
I2
sg815
g939
sg823
I5
sg820
I5
sg821
g850
sVX
I8
sg817
I0
sg825
g826
sg827
I0
sg829
g861
stRp1825
ag1
(g1554
g1517
(dp1826
g812
g887
sVY
I2
sg814
I3
sg815
g888
sg823
I9
sg820
I9
sg821
g818
sVX
I7
sg817
g881
sg825
g850
sg827
I0
sg829
g840
stRp1827
ag1
(g1554
g1517
(dp1828
g812
g835
sVY
I2
sg814
I3
sg815
g836
sg823
I3
sg820
I3
sg821
g826
sVX
I8
sg817
g828
sg825
g839
sg827
I0
sg829
g840
stRp1829
ag1
(g1554
g1517
(dp1830
g812
g929
sVY
I2
sg814
I3
sg815
g930
sg823
I8
sg820
I8
sg821
g822
sVX
I9
sg817
g881
sg825
g828
sg827
I0
sg829
g933
stRp1831
ag1
(g1554
g1517
(dp1832
g812
g946
sVY
I3
sg814
I3
sg815
g947
sg823
I3
sg820
I3
sg821
g850
sVX
I2
sg817
g818
sg825
g826
sg827
I0
sg829
g933
stRp1833
ag1
(g1554
g1517
(dp1834
g812
g978
sVY
I3
sg814
I3
sg815
g979
sg823
I9
sg820
I9
sg821
g828
sVX
I3
sg817
g870
sg825
g818
sg827
I0
sg829
g907
stRp1835
ag1
(g1554
g1517
(dp1836
g812
g903
sVY
I2
sg814
I3
sg815
g904
sg823
I6
sg820
I6
sg821
g826
sVX
I3
sg817
g839
sg825
g818
sg827
I0
sg829
g907
stRp1837
ag1
(g1554
g1517
(dp1838
g812
g845
sVY
I4
sg814
I4
sg815
g846
sg823
I5
sg820
I5
sg821
g848
sVX
I3
sg817
g826
sg825
g850
sg827
g818
sg829
g851
stRp1839
ag1
(g1554
g1517
(dp1840
g812
g954
sVY
I9
sg814
I4
sg815
g955
sg823
I9
sg820
I9
sg821
g828
sVX
I3
sg817
g826
sg825
g822
sg827
g879
sg829
g851
stRp1841
ag1
(g1554
g1517
(dp1842
g812
g895
sVY
I4
sg814
I4
sg815
g896
sg823
I5
sg820
I5
sg821
g839
sVX
I5
sg817
g881
sg825
g828
sg827
g818
sg829
g830
stRp1843
ag1
(g1554
g1517
(dp1844
g812
g813
sVY
I2
sg814
I4
sg815
g816
sg823
I7
sg820
I7
sg821
g822
sVX
I2
sg817
g818
sg825
g826
sg827
g828
sg829
g830
stRp1845
ag1
(g1554
g1517
(dp1846
g812
g920
sVY
I4
sg814
I4
sg815
g921
sg823
I6
sg820
I6
sg821
g848
sVX
I4
sg817
g839
sg825
g818
sg827
g826
sg829
g924
stRp1847
ag1
(g1554
g1517
(dp1848
g812
g962
sVY
I8
sg814
I4
sg815
g963
sg823
I9
sg820
I9
sg821
g826
sVX
I8
sg817
g850
sg825
g818
sg827
g848
sg829
g924
stRp1849
ag1
(g1554
g1517
(dp1850
g812
g876
sVY
I4
sg814
I4
sg815
g877
sg823
I5
sg820
I5
sg821
g879
sVX
I5
sg817
g848
sg825
g881
sg827
g870
sg829
g882
stRp1851
ag1
(g1554
g1517
(dp1852
g812
g912
sVY
I4
sg814
I4
sg815
g913
sg823
I5
sg820
I5
sg821
g826
sVX
I7
sg817
g828
sg825
g879
sg827
g822
sg829
g882
stRp1853
asg1567
Nsg1568
I8
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1854
(dp1855
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1856
sg1509
(lp1857
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1858
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1859
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1860
(I1
(I18
I1
tg1524
I00
S'\xa0\xd5f\x0e\xe0M\xf8\x04\xa0F\xf2\x04@g\x10\x05\x00\x9e\xf8\x04@\x80\xf2\x04\x80\x0e\xf9\x04\x00\xa2\xf7\x04 \xbc\xd3\x04\xe0\x18\xf7\x04 \xd6\x9f\x04\x80_\xf5\x04\x80\xa0\xf7\x04\x00\xff\xf3\x04\xa0\xc5\xf5\x04`\xd4\xf8\x04 \x06\xf5\x04\xc0\xde\xf8\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1861
(I1
(I18
I1
tg1528
I00
S'\xba\x92\xa4?i\xbb\xcf?x\x9b\xfa?l3\x94@\x04.\xd3@l\x96\x15A\xb0\xd49@\xfb\x93_@\xa11\x81@4W\x84@U\xe5f@\xb7\xef\xde@DA\x05A\xe4LJAO\xd5\xb3@|\x9b\x90@\xeb\xb2\x0eA\xe3"\xa6@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1862
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1863
(I1
(I18
I1
tg1524
I00
S'\x00\xc8\xcc\x01P\xc9\xcc\x01h\xcc\xcc\x01\x00\xc8\xcc\x01\x08\x03#\x02x\x925\x02\x00\xc8\xcc\x01\xc0\x02#\x02\xc0\x02#\x02P\xc9\xcc\x01P\xc9\xcc\x01\x00\xc8\xcc\x01\xc0\x02#\x02P\xc9\xcc\x01\x08\x86,\x02\x08\x86,\x02\x08\x86,\x02\x08\x03#\x02'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1864
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80@\x00\x00\x80?\x00\x00`A\x00\x000A\x00\x00\x88A\x00\x00PA\x00\x00\xc0@\x00\x00\x00\x00\x00\x00 A\x00\x00\x10A\x00\x00pA\x00\x00\x00A\x00\x00\xa0@\x00\x00\x00@\x00\x00\xe0@\x00\x00\x80A\x00\x00@@\x00\x00@A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1865
(I1
(I18
I1
tg1528
I00
S'l\xdc\x83?&\\T@\xb3\xcd\xcb?\x1b\xa3;@\x17\xfa\x19@D\xff\x1c@\xa2\xe9\x8c@\xe0\xbb\xf6@$\xba\xd1?|e/@\xa3\x1at@\xfc1y@t\x12\xd0@T\xd1e@\xd0\x8a\xa2@\x92\xc1\xdc@p\xcd\x9a@8\x1bK@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1866
(dp1867
g1536
(dp1868
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1854
sg1539
(lp1869
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1870
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1871
(I1
(I18
I1
tg1524
I00
(lp1872
I7
aI1
aI13
aI16
aI0
aI12
aI6
aI14
aI11
aI9
aI8
aI3
aI17
aI5
aI2
aI10
aI15
aI4
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1873
g1
(g1554
g1517
(dp1874
g986
g1041
sVY
I3
sg988
I2
sg989
g1042
sg997
I1
sg994
I1
sg995
g1000
sVX
I9
sg991
I0
sg999
g1045
sg1001
I0
sg1002
g1013
stRp1875
ag1
(g1554
g1517
(dp1876
g986
g1008
sVY
I2
sg988
I2
sg989
g1009
sg997
I8
sg994
I8
sg995
g1011
sVX
I2
sg991
I0
sg999
g996
sg1001
I0
sg1002
g1013
stRp1877
ag1
(g1554
g1517
(dp1878
g986
g1127
sVY
I3
sg988
I2
sg989
g1128
sg997
I4
sg994
I4
sg995
g1035
sVX
I6
sg991
I0
sg999
g1023
sg1001
I0
sg1002
g1105
stRp1879
ag1
(g1554
g1517
(dp1880
g986
g1101
sVY
I2
sg988
I2
sg989
g1102
sg997
I1
sg994
I1
sg995
g1045
sVX
I6
sg991
I0
sg999
g1000
sg1001
I0
sg1002
g1105
stRp1881
ag1
(g1554
g1517
(dp1882
g986
g1151
sVY
I9
sg988
I3
sg989
g1152
sg997
I3
sg994
I3
sg995
g1024
sVX
I5
sg991
g1034
sg999
g1035
sg1001
I0
sg1002
g1122
stRp1883
ag1
(g1554
g1517
(dp1884
g986
g1118
sVY
I3
sg988
I3
sg989
g1119
sg997
I9
sg994
I9
sg995
g992
sVX
I5
sg991
g1023
sg999
g996
sg1001
I0
sg1002
g1122
stRp1885
ag1
(g1554
g1517
(dp1886
g986
g1058
sVY
I2
sg988
I3
sg989
g1059
sg997
I1
sg994
I1
sg995
g1045
sVX
I7
sg991
g1034
sg999
g1000
sg1001
I0
sg1002
g1003
stRp1887
ag1
(g1554
g1517
(dp1888
g986
g987
sVY
I6
sg988
I3
sg989
g990
sg997
I6
sg994
I6
sg995
g996
sVX
I6
sg991
g992
sg999
g1000
sg1001
I0
sg1002
g1003
stRp1889
ag1
(g1554
g1517
(dp1890
g986
g1093
sVY
I2
sg988
I3
sg989
g1094
sg997
I6
sg994
I6
sg995
g1034
sVX
I2
sg991
g1021
sg999
g1011
sg1001
I0
sg1002
g1088
stRp1891
ag1
(g1554
g1517
(dp1892
g986
g1084
sVY
I6
sg988
I3
sg989
g1085
sg997
I8
sg994
I8
sg995
g1000
sVX
I2
sg991
g996
sg999
g1011
sg1001
I0
sg1002
g1088
stRp1893
ag1
(g1554
g1517
(dp1894
g986
g1135
sVY
I4
sg988
I4
sg989
g1136
sg997
I8
sg994
I8
sg995
g1011
sVX
I3
sg991
g1024
sg999
g1035
sg1001
g1034
sg1002
g1079
stRp1895
ag1
(g1554
g1517
(dp1896
g986
g1075
sVY
I8
sg988
I4
sg989
g1076
sg997
I1
sg994
I1
sg995
g1024
sVX
I2
sg991
g1034
sg999
g1035
sg1001
g1011
sg1002
g1079
stRp1897
ag1
(g1554
g1517
(dp1898
g986
g1050
sVY
I5
sg988
I4
sg989
g1051
sg997
I6
sg994
I6
sg995
g1045
sVX
I4
sg991
g1024
sg999
g1011
sg1001
g1023
sg1002
g1025
stRp1899
ag1
(g1554
g1517
(dp1900
g986
g1018
sVY
I3
sg988
I4
sg989
g1019
sg997
I7
sg994
I7
sg995
g1021
sVX
I2
sg991
g992
sg999
g1023
sg1001
g1024
sg1002
g1025
stRp1901
ag1
(g1554
g1517
(dp1902
g986
g1066
sVY
I3
sg988
I4
sg989
g1067
sg997
I5
sg994
I5
sg995
g1024
sVX
I3
sg991
g1045
sg999
g1034
sg1001
g1011
sg1002
g1070
stRp1903
ag1
(g1554
g1517
(dp1904
g986
g1143
sVY
I4
sg988
I4
sg989
g1144
sg997
I5
sg994
I5
sg995
g1034
sVX
I8
sg991
g996
sg999
g1000
sg1001
g992
sg1002
g1070
stRp1905
ag1
(g1554
g1517
(dp1906
g986
g1030
sVY
I2
sg988
I4
sg989
g1031
sg997
I5
sg994
I5
sg995
g1024
sVX
I6
sg991
g992
sg999
g1034
sg1001
g1035
sg1002
g1036
stRp1907
ag1
(g1554
g1517
(dp1908
g986
g1110
sVY
I2
sg988
I4
sg989
g1111
sg997
I3
sg994
I3
sg995
g1024
sVX
I3
sg991
g1023
sg999
g992
sg1001
g1035
sg1002
g1036
stRp1909
asg1567
Nsg1568
I4
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1910
(dp1911
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1912
sg1509
(lp1913
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1914
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1915
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1916
(I1
(I18
I1
tg1524
I00
S'\x80\xe0\xf2\x04@4\xf6\x04\xe0\x93\x0f\x05 \x02\xf9\x04\x80,\xd4\x04`1\xd3\x04\xc0\xc9\xd1\x04`\xf5\x10\x05\xe0\xf8\x10\x05\xe0\x0e\xf2\x04\x00?\xef\x04\xe0B\xf8\x04\x00~\x9e\x04 \t\xd3\x04\xe0\xc0\xf5\x04@\xcf\xf5\x04\x80If\x0e\xe0\xdcf\x0e'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1917
(I1
(I18
I1
tg1528
I00
S'\xd9\t\x1d@\x82\x8b\x04@\x99\x95\xa4?\xbe\xd8\x0c@\xda\x0fI@u\x11\xb3?\xb08\x95@\x13\xfc\x19@\xc0/\x96@\xfb\xbe\xd5@1\x12\x90@Ua,@D\xd4\x85@,\xe5\x87@ZL\x1fA\xa5\xdf\xda@\xc75\x96@\xe5Q\xc5@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1918
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1919
(I1
(I18
I1
tg1524
I00
S'h\xcc\xcc\x01\xc0\x02#\x02\x08\x03#\x02\x00\xc8\xcc\x01x\x925\x02\x08\x86,\x02\x08\x86,\x02\x08\x86,\x02P\xc9\xcc\x01\x08\x03#\x02\x08\x03#\x02x\x925\x02h\xcc\xcc\x01\x08\x03#\x02P\xc9\xcc\x01\xc0\x02#\x02\x00\xc8\xcc\x01\xc0\x02#\x02'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1920
(I1
(I18
I1
tg1528
I00
S'\x00\x00@@\x00\x00 A\x00\x00\x88A\x00\x00\x00@\x00\x000A\x00\x00PA\x00\x00\x80@\x00\x00\x00\x00\x00\x00@A\x00\x00\x80A\x00\x00pA\x00\x00\xe0@\x00\x00\xc0@\x00\x00`A\x00\x00\x10A\x00\x00\x80?\x00\x00\x00A\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1921
(I1
(I18
I1
tg1528
I00
S"\xdd\x9d8@7ZV?\x12\xedM?\xb7\x9d=?\x182\x83@N\xb0c@\xba\xca\xb0@\xe1h\xf3?\x041%@\xde\xcd\x11@\xa1/\x98@2\x12\xe4@\xc4\xad\x14@\x7f\xd1\xc6@\xfc\xf0g@x]'@h\x80\xa3@[\xdek@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1922
(dp1923
g1536
(dp1924
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1910
sg1539
(lp1925
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1926
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1927
(I1
(I18
I1
tg1524
I00
(lp1928
I7
aI15
aI3
aI0
aI6
aI17
aI12
aI11
aI16
aI14
aI1
aI4
aI8
aI5
aI13
aI10
aI9
aI2
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1929
g1
(g1554
g1517
(dp1930
g1159
g1203
sVY
I2
sg1161
I2
sg1162
g1204
sg1170
I4
sg1167
I4
sg1168
g1165
sVX
I3
sg1164
I0
sg1172
g1169
sg1174
I0
sg1175
g1207
stRp1931
ag1
(g1554
g1517
(dp1932
g1159
g1266
sVY
I2
sg1161
I2
sg1162
g1267
sg1170
I6
sg1167
I6
sg1168
g1214
sVX
I2
sg1164
I0
sg1172
g1169
sg1174
I0
sg1175
g1207
stRp1933
ag1
(g1554
g1517
(dp1934
g1159
g1325
sVY
I5
sg1161
I2
sg1162
g1326
sg1170
I3
sg1167
I3
sg1168
g1183
sVX
I4
sg1164
I0
sg1172
g1173
sg1174
I0
sg1175
g1198
stRp1935
ag1
(g1554
g1517
(dp1936
g1159
g1193
sVY
I2
sg1161
I2
sg1162
g1194
sg1170
I1
sg1167
I1
sg1168
g1196
sVX
I5
sg1164
I0
sg1172
g1173
sg1174
I0
sg1175
g1198
stRp1937
ag1
(g1554
g1517
(dp1938
g1159
g1274
sVY
I3
sg1161
I3
sg1162
g1275
sg1170
I9
sg1167
I9
sg1168
g1165
sVX
I8
sg1164
g1185
sg1172
g1169
sg1174
I0
sg1175
g1278
stRp1939
ag1
(g1554
g1517
(dp1940
g1159
g1293
sVY
I5
sg1161
I3
sg1162
g1294
sg1170
I5
sg1167
I5
sg1168
g1173
sVX
I6
sg1164
g1185
sg1172
g1169
sg1174
I0
sg1175
g1278
stRp1941
ag1
(g1554
g1517
(dp1942
g1159
g1212
sVY
I7
sg1161
I3
sg1162
g1213
sg1170
I5
sg1167
I5
sg1168
g1183
sVX
I7
sg1164
g1214
sg1172
g1173
sg1174
I0
sg1175
g1176
stRp1943
ag1
(g1554
g1517
(dp1944
g1159
g1160
sVY
I5
sg1161
I3
sg1162
g1163
sg1170
I5
sg1167
I5
sg1168
g1169
sVX
I4
sg1164
g1165
sg1172
g1173
sg1174
I0
sg1175
g1176
stRp1945
ag1
(g1554
g1517
(dp1946
g1159
g1283
sVY
I5
sg1161
I3
sg1162
g1284
sg1170
I8
sg1167
I8
sg1168
g1165
sVX
I5
sg1164
g1169
sg1172
g1287
sg1174
I0
sg1175
g1288
stRp1947
ag1
(g1554
g1517
(dp1948
g1159
g1317
sVY
I2
sg1161
I3
sg1162
g1318
sg1170
I3
sg1167
I3
sg1168
g1185
sVX
I4
sg1164
g1233
sg1172
g1187
sg1174
I0
sg1175
g1288
stRp1949
ag1
(g1554
g1517
(dp1950
g1159
g1309
sVY
I5
sg1161
I4
sg1162
g1310
sg1170
I3
sg1167
I3
sg1168
g1185
sVX
I5
sg1164
g1214
sg1172
g1196
sg1174
g1187
sg1175
g1245
stRp1951
ag1
(g1554
g1517
(dp1952
g1159
g1241
sVY
I3
sg1161
I4
sg1162
g1242
sg1170
I9
sg1167
I9
sg1168
g1214
sVX
I3
sg1164
g1173
sg1172
g1169
sg1174
g1235
sg1175
g1245
stRp1953
ag1
(g1554
g1517
(dp1954
g1159
g1230
sVY
I6
sg1161
I4
sg1162
g1231
sg1170
I4
sg1167
I4
sg1168
g1233
sVX
I3
sg1164
g1187
sg1172
g1214
sg1174
g1235
sg1175
g1236
stRp1955
ag1
(g1554
g1517
(dp1956
g1159
g1301
sVY
I3
sg1161
I4
sg1162
g1302
sg1170
I3
sg1167
I3
sg1168
g1196
sVX
I3
sg1164
g1235
sg1172
g1187
sg1174
g1165
sg1175
g1236
stRp1957
ag1
(g1554
g1517
(dp1958
g1159
g1258
sVY
I2
sg1161
I4
sg1162
g1259
sg1170
I8
sg1167
I8
sg1168
g1235
sVX
I9
sg1164
g1183
sg1172
g1173
sg1174
g1214
sg1175
g1188
stRp1959
ag1
(g1554
g1517
(dp1960
g1159
g1181
sVY
I3
sg1161
I4
sg1162
g1182
sg1170
I6
sg1167
I6
sg1168
g1185
sVX
I2
sg1164
g1183
sg1172
g1187
sg1174
g1165
sg1175
g1188
stRp1961
ag1
(g1554
g1517
(dp1962
g1159
g1250
sVY
I2
sg1161
I4
sg1162
g1251
sg1170
I1
sg1167
I1
sg1168
g1214
sVX
I8
sg1164
g1185
sg1172
g1173
sg1174
g1233
sg1175
g1225
stRp1963
ag1
(g1554
g1517
(dp1964
g1159
g1221
sVY
I2
sg1161
I4
sg1162
g1222
sg1170
I6
sg1167
I6
sg1168
g1165
sVX
I3
sg1164
g1185
sg1172
g1187
sg1174
g1169
sg1175
g1225
stRp1965
asg1567
Nsg1568
I2
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbag1
(g1504
g3
NtRp1966
(dp1967
g1507
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cCCDL\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1968
sg1509
(lp1969
sg1511
I87590064
sg10
g1577
sg6
g1513
sg1514
I1
sg24
I01
sg25
g26
sg1515
g1
(g1516
g1517
(dp1970
g22
g1519
(g1520
g1521
g1522
S'b'
tRp1971
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1519
(g1520
g1521
g1522
S'b'
tRp1972
(I1
(I18
I1
tg1524
I00
S'\x00\x14\xf7\x04\x00Df\x0e\x80\xc3\xd3\x04 \xb7\x0e\x05\x806\xf6\x04`\x07\xf9\x04@|\x9e\x04\xa0\xc8\xf1\x04\xc0\x15\xf7\x04\xe0\x1c\xf7\x04@-\xd4\x04\x80\x02\xd3\x04\xa0y\xf7\x04\x00W\xf5\x04@\xb1\x0e\x05@\xc3\xd1\x04 \xc5\xf1\x04\xe0\xe7\xd1\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1519
(g1520
g1521
g1522
S'b'
tRp1973
(I1
(I18
I1
tg1528
I00
S'\xcbs\x05@4@\xea?\x8c\x1c\xb1?:\x93\x03@\xb0@#@\x7fG)@\x0e\xb2\x08@K\t\x1b@g1u@d_\x01@j\tA@\xd2\xe0\x9d@nPu@\xfa\x0f\xbb@\xf9\xb6\x98@\x9a\x1d6A9={A\x1b\xf4\x0eA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1526
g1519
(g1520
g1521
g1522
S'b'
tRp1974
(I1
(I18
I1
tg1528
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1519
(g1520
g1521
g1522
S'b'
tRp1975
(I1
(I18
I1
tg1524
I00
S' \x03#\x02x\x02#\x02P\xc9\xcc\x01\xc0\x02#\x02 \x03#\x02P\xc9\xcc\x01x\x02#\x02\x08\x86,\x02\xc0\x02#\x02\x08\x86,\x02x\x925\x02P\xc9\xcc\x01\xc0\x02#\x02\x08\x03#\x02\x08\x86,\x02P\xc9\xcc\x01\x00\xc8\xcc\x01\x00\xc8\xcc\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1531
g1519
(g1520
g1521
g1522
S'b'
tRp1976
(I1
(I18
I1
tg1528
I00
S'\x00\x00pA\x00\x00\xc0@\x00\x00\x00@\x00\x00\x88A\x00\x00@A\x00\x00\xa0@\x00\x00\x00A\x00\x00 A\x00\x00`A\x00\x00@@\x00\x00PA\x00\x00\x80?\x00\x000A\x00\x00\x80@\x00\x00\x80A\x00\x00\xe0@\x00\x00\x10A\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1519
(g1520
g1521
g1522
S'b'
tRp1977
(I1
(I18
I1
tg1528
I00
S'\x1a\xc9I?\xb1\xaeA?\x0f\x8a\xa4?v\xd91?\xb2\x07\xc1?\xfa\xee\x15@\x87\x89\xae?Uu0A\xb4\xcb\x11@\x13\xab\x0e@\xdd-Q@9\x0c\x19@\x11\x04"@\xd8\xef\x8b@\xb0{\xa0@\xd5\xa2\xaa@K9\x7f@9\x03\x80@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1978
(dp1979
g1536
(dp1980
g1526
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1531
I01
ssg1538
g1966
sg1539
(lp1981
g1526
ag1531
ag19
ag20
ag21
ag22
ag23
asg1541
(lp1982
I18
aI1
asbsg1543
g1544
sg1545
g1546
(g1521
(I0
tS'b'
tRp1983
(I1
(I18
I1
tg1524
I00
(lp1984
I17
aI11
aI2
aI9
aI13
aI5
aI1
aI15
aI6
aI16
aI7
aI12
aI4
aI10
aI8
aI0
aI14
aI3
atbsg1549
I01
sg1550
I1
sg1551
I-1
sg1552
(lp1985
g1
(g1554
g1517
(dp1986
g1333
g1482
sVY
I5
sg1335
I2
sg1336
g1483
sg1344
I7
sg1341
I7
sg1342
g1363
sVX
I3
sg1338
I0
sg1346
g1362
sg1348
I0
sg1350
g1411
stRp1987
ag1
(g1554
g1517
(dp1988
g1333
g1406
sVY
I4
sg1335
I2
sg1336
g1407
sg1344
I2
sg1341
I2
sg1342
g1363
sVX
I9
sg1338
I0
sg1346
g1410
sg1348
I0
sg1350
g1411
stRp1989
ag1
(g1554
g1517
(dp1990
g1333
g1369
sVY
I3
sg1335
I2
sg1336
g1370
sg1344
I8
sg1341
I8
sg1342
g1372
sVX
I3
sg1338
I0
sg1346
g1363
sg1348
I0
sg1350
g1374
stRp1991
ag1
(g1554
g1517
(dp1992
g1333
g1498
sVY
I8
sg1335
I2
sg1336
g1499
sg1344
I6
sg1341
I6
sg1342
g1362
sVX
I4
sg1338
I0
sg1346
g1343
sg1348
I0
sg1350
g1374
stRp1993
ag1
(g1554
g1517
(dp1994
g1333
g1458
sVY
I5
sg1335
I3
sg1336
g1459
sg1344
I7
sg1341
I7
sg1342
g1358
sVX
I2
sg1338
g1363
sg1346
g1362
sg1348
I0
sg1350
g1401
stRp1995
ag1
(g1554
g1517
(dp1996
g1333
g1397
sVY
I2
sg1335
I3
sg1336
g1398
sg1344
I8
sg1341
I8
sg1342
g1360
sVX
I4
sg1338
g1343
sg1346
g1362
sg1348
I0
sg1350
g1401
stRp1997
ag1
(g1554
g1517
(dp1998
g1333
g1425
sVY
I3
sg1335
I3
sg1336
g1426
sg1344
I2
sg1341
I2
sg1342
g1349
sVX
I3
sg1338
g1339
sg1346
g1358
sg1348
I0
sg1350
g1429
stRp1999
ag1
(g1554
g1517
(dp2000
g1333
g1442
sVY
I3
sg1335
I3
sg1336
g1443
sg1344
I5
sg1341
I5
sg1342
g1362
sVX
I2
sg1338
g1343
sg1346
g1339
sg1348
I0
sg1350
g1429
stRp2001
ag1
(g1554
g1517
(dp2002
g1333
g1474
sVY
I4
sg1335
I3
sg1336
g1475
sg1344
I6
sg1341
I6
sg1342
g1347
sVX
I5
sg1338
g1362
sg1346
g1358
sg1348
I0
sg1350
g1383
stRp2003
ag1
(g1554
g1517
(dp2004
g1333
g1379
sVY
I3
sg1335
I3
sg1336
g1380
sg1344
I5
sg1341
I5
sg1342
g1339
sVX
I3
sg1338
g1372
sg1346
g1343
sg1348
I0
sg1350
g1383
stRp2005
ag1
(g1554
g1517
(dp2006
g1333
g1466
sVY
I4
sg1335
I4
sg1336
g1467
sg1344
I9
sg1341
I9
sg1342
g1363
sVX
I9
sg1338
g1347
sg1346
g1362
sg1348
g1358
sg1350
g1364
stRp2007
ag1
(g1554
g1517
(dp2008
g1333
g1356
sVY
I2
sg1335
I4
sg1336
g1357
sg1344
I8
sg1341
I8
sg1342
g1360
sVX
I2
sg1338
g1358
sg1346
g1362
sg1348
g1363
sg1350
g1364
stRp2009
ag1
(g1554
g1517
(dp2010
g1333
g1450
sVY
I6
sg1335
I4
sg1336
g1451
sg1344
I6
sg1341
I6
sg1342
g1362
sVX
I6
sg1338
g1347
sg1346
g1363
sg1348
g1343
sg1350
g1392
stRp2011
ag1
(g1554
g1517
(dp2012
g1333
g1388
sVY
I2
sg1335
I4
sg1336
g1389
sg1344
I3
sg1341
I3
sg1342
g1349
sVX
I9
sg1338
g1358
sg1346
g1363
sg1348
g1347
sg1350
g1392
stRp2013
ag1
(g1554
g1517
(dp2014
g1333
g1490
sVY
I3
sg1335
I4
sg1336
g1491
sg1344
I5
sg1341
I5
sg1342
g1358
sVX
I3
sg1338
g1372
sg1346
g1363
sg1348
g1347
sg1350
g1420
stRp2015
ag1
(g1554
g1517
(dp2016
g1333
g1416
sVY
I3
sg1335
I4
sg1336
g1417
sg1344
I8
sg1341
I8
sg1342
g1360
sVX
I3
sg1338
g1349
sg1346
g1363
sg1348
g1358
sg1350
g1420
stRp2017
ag1
(g1554
g1517
(dp2018
g1333
g1434
sVY
I4
sg1335
I4
sg1336
g1435
sg1344
I3
sg1341
I3
sg1342
g1343
sVX
I3
sg1338
g1347
sg1346
g1339
sg1348
g1372
sg1350
g1351
stRp2019
ag1
(g1554
g1517
(dp2020
g1333
g1334
sVY
I2
sg1335
I4
sg1336
g1337
sg1344
I1
sg1341
I1
sg1342
g1343
sVX
I7
sg1338
g1339
sg1346
g1347
sg1348
g1349
sg1350
g1351
stRp2021
asg1567
Nsg1568
I3
sg1569
I18
sg1570
I0
sg1571
I18
sg1572
I01
sbasS'savePickle'
p2022
I00
sb.