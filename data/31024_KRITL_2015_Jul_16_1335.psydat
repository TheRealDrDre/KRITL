ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cdata/31024_KRITL_2015_Jul_16_1335
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'KRITL'
p11
sS'dataNames'
p12
(lp13
S'practice_encoding.keys'
p14
aS'practice_encoding.rt'
p15
aS'practice_execution.keys'
p16
aS'practice_execution.corr'
p17
aS'practice_execution.rt'
p18
aS'encoding.keys'
p19
aS'encoding.rt'
p20
aS'execution.keys'
p21
aS'execution.corr'
p22
aS'execution.rt'
p23
asS'autoLog'
p24
I01
sS'extraInfo'
p25
(dp26
S'date'
p27
V2015_Jul_16_1335
p28
sS'frameRate'
p29
NsS'expName'
p30
g11
sVsession
p31
V001
p32
sVparticipant
p33
V31024
p34
ssS'loopsUnfinished'
p35
(lp36
sS'saveWideText'
p37
I01
sS'thisEntry'
p38
(dp39
sS'version'
p40
S''
sS'_paramNamesSoFar'
p41
(lp42
Voperationc
p43
aVoperationb
p44
aVoperationa
p45
aVcorrectresponse
p46
aVvaluey
p47
aVoperationd
p48
aVcondition
p49
aVvaluex
p50
aVRule
p51
aVOperatora
p52
aVLength
p53
aVIntermediate
p54
aVCorrectResponse
p55
aVResult
p56
aVY
aVX
aVOperatorc
p57
aVOperatorb
p58
aVOperatord
p59
aVStructure
p60
asS'entries'
p61
(lp62
(dp63
g31
g32
sg43
I0
sg27
g28
sg16
Nsg29
Nsg14
(lp64
S'space'
p65
asg49
I2
sg45
VTIMES
p66
sg17
I0
sS'practice_trials.thisN'
p67
I0
sg44
Vdecrease
p68
sS'practice_trials.thisIndex'
p69
I1
sg30
g11
sg46
I8
sS'practice_trials.thisTrialN'
p70
I0
sg48
I0
sS'practice_trials.thisRepN'
p71
I0
sg33
g34
sg50
I3
sg47
I3
sg15
(lp72
F4.2322763619740726
asa(dp73
g18
F3.7417038532148581
sg29
Nsg17
I0
sg43
Vincrease
p74
sg44
VDIVIDE
p75
sg45
Vtriple
p76
sg31
g32
sg46
I3
sS'practice_trials.thisTrialN'
p77
I1
sg48
I0
sS'practice_trials.thisRepN'
p78
I0
sg33
g34
sg49
I3
sg27
g28
sg16
S'6'
sg14
(lp79
S'space'
p80
asS'practice_trials.thisIndex'
p81
I4
sS'practice_trials.thisN'
p82
I1
sg30
g11
sg15
(lp83
F8.6213262146047782
asg47
I3
sg50
I2
sa(dp84
g18
F3.6810306844563456
sg29
Nsg17
I0
sg43
I0
sg44
VADD
p85
sg45
g68
sg31
g32
sg46
I7
sS'practice_trials.thisTrialN'
p86
I2
sg48
I0
sS'practice_trials.thisRepN'
p87
I0
sg33
g34
sg49
I2
sg27
g28
sg16
S'2'
sg14
(lp88
S'space'
p89
asS'practice_trials.thisIndex'
p90
I0
sS'practice_trials.thisN'
p91
I2
sg30
g11
sg15
(lp92
F5.3217921209870838
asg47
I5
sg50
I3
sa(dp93
g18
F8.7130250458430964
sg29
Nsg17
I0
sg43
g74
sg44
g75
sg45
Vdouble
p94
sg31
g32
sg46
I9
sS'practice_trials.thisTrialN'
p95
I3
sg48
g76
sS'practice_trials.thisRepN'
p96
I0
sg33
g34
sg49
I4
sg27
g28
sg16
S'8'
sg14
(lp97
S'space'
p98
asS'practice_trials.thisIndex'
p99
I5
sS'practice_trials.thisN'
p100
I3
sg30
g11
sg15
(lp101
F7.4391408256487921
asg47
I8
sg50
I8
sa(dp102
g18
F11.698632447703858
sg29
Nsg17
I1
sg43
I0
sg44
g85
sg45
Vhalf
p103
sg31
g32
sg46
I7
sS'practice_trials.thisTrialN'
p104
I4
sg48
I0
sS'practice_trials.thisRepN'
p105
I0
sg33
g34
sg49
I2
sg27
g28
sg16
S'7'
sg14
(lp106
S'space'
p107
asS'practice_trials.thisIndex'
p108
I2
sS'practice_trials.thisN'
p109
I4
sg30
g11
sg15
(lp110
F6.1623792057216633
asg47
I5
sg50
I4
sa(dp111
g18
F6.9990631477558054
sg29
Nsg17
I0
sg43
g85
sg44
Vtriple 
p112
sg45
g103
sg31
g32
sg46
I8
sS'practice_trials.thisTrialN'
p113
I5
sg48
I0
sS'practice_trials.thisRepN'
p114
I0
sg33
g34
sg49
I3
sg27
g28
sg16
S'9'
sg14
(lp115
S'space'
p116
asS'practice_trials.thisIndex'
p117
I3
sS'practice_trials.thisN'
p118
I5
sg30
g11
sg15
(lp119
F3.5699897215672536
asg47
I2
sg50
I4
sa(dp120
S'block.thisTrialN'
p121
I0
sS'block.thisRepN'
p122
I0
sg29
NsS'block.thisN'
p123
I0
sg51
(S'TIMES'
S'THIRD'
S'HALF'
S'x'
S'y'
tp124
sg27
g28
sg53
I3
sg54
(I3
I1
I5
tp125
sg22
I1
sg20
F4.522361791547155
sg23
F6.0280513228499331
sVY
I5
sVX
I6
sg57
Vhalf
p126
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p127
sg30
g11
sg56
I5
sg52
Vthird
p128
sg55
I5
sS'block.thisIndex'
p129
I5
sg58
VTIMES
p130
sg59
I0
sg60
VBUUxy
p131
sa(dp132
S'block.thisTrialN'
p133
I1
sS'block.thisRepN'
p134
I0
sg29
NsS'block.thisN'
p135
I1
sg51
(S'TIMES'
S'INCREASE'
S'x'
S'y'
tp136
sg27
g28
sg53
I2
sg54
(I3
I6
tp137
sg22
I1
sg20
F2.3854994731227634
sg23
F2.5440773755253758
sVY
I2
sVX
I2
sg57
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p138
sg30
g11
sg56
I6
sg52
Vincrease
p139
sg55
I6
sS'block.thisIndex'
p140
I1
sg58
g130
sg59
I0
sg60
VBUxy
p141
sa(dp142
S'block.thisTrialN'
p143
I2
sS'block.thisRepN'
p144
I0
sg29
NsS'block.thisN'
p145
I2
sg51
(S'THIRD'
S'INCREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp146
sg27
g28
sg53
I4
sg54
(I4
I2
I3
I1
tp147
sg22
I0
sg20
F4.0416747012350243
sg23
F6.8499836042174138
sVY
I2
sVX
I8
sg57
g126
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p148
sg30
g11
sg56
I1
sg52
g139
sg55
I1
sS'block.thisIndex'
p149
I16
sg58
g128
sg59
VDIVIDE
p150
sg60
VUUUBxy
p151
sa(dp152
S'block.thisTrialN'
p153
I3
sS'block.thisRepN'
p154
I0
sg29
NsS'block.thisN'
p155
I3
sg51
(S'THIRD'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp156
sg27
g28
sg53
I3
sg54
(I3
I15
I5
tp157
sg22
I1
sg20
F3.3524874179274775
sg23
F9.330278035486117
sVY
I5
sVX
I4
sg57
Vdecrease
p158
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p159
sg30
g11
sg56
I5
sg52
g130
sg55
I5
sS'block.thisIndex'
p160
I7
sg58
g128
sg59
I0
sg60
VUBUxy
p161
sa(dp162
S'block.thisTrialN'
p163
I4
sS'block.thisRepN'
p164
I0
sg29
NsS'block.thisN'
p165
I4
sg51
(S'TRIPLE'
S'HALF'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp166
sg27
g28
sg53
I4
sg54
(I1
I4
I2
I6
tp167
sg22
I0
sg20
F3.7579845043219393
sg23
F9.6343438062176574
sVY
I3
sVX
I2
sg57
VADD
p168
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p169
sg30
g11
sg56
I6
sg52
g126
sg55
I6
sS'block.thisIndex'
p170
I15
sg58
Vtriple
p171
sg59
g158
sg60
VUUBUxy
p172
sa(dp173
S'block.thisTrialN'
p174
I5
sS'block.thisRepN'
p175
I0
sg29
NsS'block.thisN'
p176
I5
sg51
(S'THIRD'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp177
sg27
g28
sg53
I3
sg54
(I8
I15
I5
tp178
sg22
I0
sg20
F4.059918997445493
sg23
F4.8291898240422597
sVY
I7
sVX
I7
sg57
g139
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p179
sg30
g11
sg56
I5
sg52
g168
sg55
I5
sS'block.thisIndex'
p180
I6
sg58
g128
sg59
I0
sg60
g161
sa(dp181
S'block.thisTrialN'
p182
I6
sS'block.thisRepN'
p183
I0
sg29
NsS'block.thisN'
p184
I6
sg51
(S'SUBTRACT'
S'HALF'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp185
sg27
g28
sg53
I4
sg54
(I15
I16
I8
I3
tp186
sg22
I0
sg20
F5.0756666541856248
sg23
F5.9096191312419251
sVY
I5
sVX
I5
sg57
g139
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p187
sg30
g11
sg56
I3
sg52
g126
sg55
I3
sS'block.thisIndex'
p188
I10
sg58
VSUBTRACT
p189
sg59
g171
sg60
VBUUUxy
p190
sa(dp191
S'block.thisTrialN'
p192
I7
sS'block.thisRepN'
p193
I0
sg29
NsS'block.thisN'
p194
I7
sg51
(S'THIRD'
S'DECREASE'
S'TIMES'
S'x'
S'y'
tp195
sg27
g28
sg53
I3
sg54
(I25
I24
I8
tp196
sg22
I1
sg20
F5.5770383360504638
sg23
F4.682277604326373
sVY
I5
sVX
I5
sg57
g130
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p197
sg30
g11
sg56
I8
sg52
g158
sg55
I8
sS'block.thisIndex'
p198
I8
sg58
g128
sg59
I0
sg60
VUUBxy
p199
sa(dp200
S'block.thisTrialN'
p201
I8
sS'block.thisRepN'
p202
I0
sg29
NsS'block.thisN'
p203
I8
sg51
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp204
sg27
g28
sg53
I4
sg54
(I6
I3
I2
I6
tp205
sg22
I1
sg20
F3.3597778571711387
sg23
F8.5480624096962856
sVY
I2
sVX
I3
sg57
g126
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p206
sg30
g11
sg56
I6
sg52
g158
sg55
I6
sS'block.thisIndex'
p207
I17
sg58
g171
sg59
g130
sg60
g151
sa(dp208
S'block.thisTrialN'
p209
I9
sS'block.thisRepN'
p210
I0
sg29
NsS'block.thisN'
p211
I9
sg51
(S'THIRD'
S'ADD'
S'x'
S'y'
tp212
sg27
g28
sg53
I2
sg54
(I9
I3
tp213
sg22
I1
sg20
F2.957844098971691
sg23
F2.6614169811364263
sVY
I5
sVX
I4
sg57
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p214
sg30
g11
sg56
I3
sg52
g168
sg55
I3
sS'block.thisIndex'
p215
I2
sg58
g128
sg59
I0
sg60
VUBxy
p216
sa(dp217
S'block.thisTrialN'
p218
I10
sS'block.thisRepN'
p219
I0
sg29
NsS'block.thisN'
p220
I10
sg51
(S'THIRD'
S'DOUBLE'
S'ADD'
S'INCREASE'
S'x'
S'y'
tp221
sg27
g28
sg53
I4
sg54
(I10
I12
I24
I8
tp222
sg22
I1
sg20
F5.0535055666841799
sg23
F10.760284464311553
sVY
I2
sVX
I9
sg57
g168
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p223
sg30
g11
sg56
I8
sg52
Vdouble
p224
sg55
I8
sS'block.thisIndex'
p225
I14
sg58
g128
sg59
g139
sg60
g172
sa(dp226
S'block.thisTrialN'
p227
I11
sS'block.thisRepN'
p228
I0
sg29
NsS'block.thisN'
p229
I11
sg51
(S'TIMES'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp230
sg27
g28
sg53
I3
sg54
(I4
I3
I9
tp231
sg22
I1
sg20
F3.7274669888138305
sg23
F7.0243606079602614
sVY
I3
sVX
I8
sg57
g126
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p232
sg30
g11
sg56
I9
sg52
g158
sg55
I9
sS'block.thisIndex'
p233
I4
sg58
g130
sg59
I0
sg60
g131
sa(dp234
S'block.thisTrialN'
p235
I12
sS'block.thisRepN'
p236
I0
sg29
NsS'block.thisN'
p237
I12
sg51
(S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp238
sg27
g28
sg53
I4
sg54
(I2
I4
I1
I3
tp239
sg22
I1
sg20
F4.9161438503942918
sg23
F15.813729137356859
sVY
I3
sVX
I3
sg57
g224
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p240
sg30
g11
sg56
I3
sg52
g189
sg55
I3
sS'block.thisIndex'
p241
I13
sg58
g171
sg59
g158
sg60
VUBUUxy
p242
sa(dp243
S'block.thisTrialN'
p244
I13
sS'block.thisRepN'
p245
I0
sg29
NsS'block.thisN'
p246
I13
sg51
(S'TRIPLE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp247
sg27
g28
sg53
I3
sg54
(I2
I1
I3
tp248
sg22
I1
sg20
F2.7965140837623039
sg23
F7.1895458209037315
sVY
I2
sVX
I4
sg57
g150
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p249
sg30
g11
sg56
I3
sg52
g126
sg55
I3
sS'block.thisIndex'
p250
I9
sg58
g171
sg59
I0
sg60
g199
sa(dp251
S'block.thisTrialN'
p252
I14
sS'block.thisRepN'
p253
I0
sg29
NsS'block.thisN'
p254
I14
sg51
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp255
sg27
g28
sg53
I4
sg54
(I6
I18
I3
I4
tp256
sg22
I0
sg20
F11.610241121336003
sg23
F13.450846404171898
sVY
I6
sVX
I3
sg57
g171
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p257
sg30
g11
sg56
I4
sg52
g150
sg55
I4
sS'block.thisIndex'
p258
I12
sg58
g139
sg59
g224
sg60
g242
sa(dp259
S'block.thisTrialN'
p260
I15
sS'block.thisRepN'
p261
I0
sg29
NsS'block.thisN'
p262
I15
sg51
(S'TIMES'
S'DECREASE'
S'x'
S'y'
tp263
sg27
g28
sg53
I2
sg54
(I2
I4
tp264
sg22
I0
sg20
F2.5306545261992142
sg23
F3.0802266783430241
sVY
I2
sVX
I3
sg57
I0
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p265
sg30
g11
sg56
I4
sg52
g158
sg55
I4
sS'block.thisIndex'
p266
I0
sg58
g130
sg59
I0
sg60
g141
sa(dp267
S'block.thisTrialN'
p268
I16
sS'block.thisRepN'
p269
I0
sg29
NsS'block.thisN'
p270
I16
sg51
(S'TIMES'
S'INCREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp271
sg27
g28
sg53
I4
sg54
(I6
I2
I3
I9
tp272
sg22
I0
sg20
F6.5824904171313392
sg23
F13.806306761893211
sVY
I3
sVX
I3
sg57
g128
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p273
sg30
g11
sg56
I9
sg52
g139
sg55
I9
sS'block.thisIndex'
p274
I11
sg58
g130
sg59
g224
sg60
g190
sa(dp275
S'block.thisTrialN'
p276
I17
sS'block.thisRepN'
p277
I0
sg29
NsS'block.thisN'
p278
I17
sg51
(S'THIRD'
S'SUBTRACT'
S'x'
S'y'
tp279
sg27
g28
sg53
I2
sg54
(I3
I1
tp280
sg22
I1
sg20
F1.2121849585091695
sg23
F11.071029288097634
sVY
I2
sVX
I5
sg57
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p281
sg30
g11
sg56
I1
sg52
g189
sg55
I1
sS'block.thisIndex'
p282
I3
sg58
g128
sg59
I0
sg60
g216
sa(dp283
S'block.thisTrialN'
p284
I0
sS'block.thisRepN'
p285
I0
sg29
NsS'block.thisN'
p286
I0
sVRule
p287
(S'INCREASE'
S'HALF'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp288
sg27
g28
sVLength
p289
I4
sVIntermediate
p290
(I12
I4
I2
I3
tp291
sg22
I1
sg20
F6.4542067535221577
sg23
F6.6704040433396585
sVY
I4
sVX
I3
sVOperatorc
p292
Vthird
p293
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p294
sg30
g11
sVResult
p295
I3
sVOperatora
p296
Vhalf
p297
sVCorrectResponse
p298
I3
sS'block.thisIndex'
p299
I16
sVOperatorb
p300
Vincrease
p301
sVOperatord
p302
VTIMES
p303
sVStructure
p304
VUUUBxy
p305
sa(dp306
S'block.thisTrialN'
p307
I1
sS'block.thisRepN'
p308
I0
sg29
NsS'block.thisN'
p309
I1
sg287
(S'DECREASE'
S'ADD'
S'THIRD'
S'HALF'
S'x'
S'y'
tp310
sg27
g28
sg289
I4
sg290
(I3
I1
I7
I6
tp311
sg22
I0
sg20
F4.4134993513434893
sg23
F13.122246093611466
sVY
I6
sVX
I6
sg292
g293
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p312
sg30
g11
sg295
I6
sg296
VADD
p313
sg298
I6
sS'block.thisIndex'
p314
I12
sg300
Vdecrease
p315
sg302
g297
sg304
VUBUUxy
p316
sa(dp317
S'block.thisTrialN'
p318
I2
sS'block.thisRepN'
p319
I0
sg29
NsS'block.thisN'
p320
I2
sg287
(S'DECREASE'
S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp321
sg27
g28
sg289
I4
sg290
(I1
I3
I6
I5
tp322
sg22
I1
sg20
F3.6884411611536052
sg23
F4.6590799250116106
sVY
I3
sVX
I3
sg292
g303
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p323
sg30
g11
sg295
I5
sg296
Vdouble
p324
sg298
I5
sS'block.thisIndex'
p325
I14
sg300
g315
sg302
g293
sg304
VUUBUxy
p326
sa(dp327
S'block.thisTrialN'
p328
I3
sS'block.thisRepN'
p329
I0
sg29
NsS'block.thisN'
p330
I3
sg287
(S'DECREASE'
S'SUBTRACT'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp331
sg27
g28
sg289
I4
sg290
(I3
I6
I4
I3
tp332
sg22
I0
sg20
F5.677371466284967
sg23
F11.33412133443926
sVY
I2
sVX
I9
sg292
g324
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p333
sg30
g11
sg295
I3
sg296
VSUBTRACT
p334
sg298
I3
sS'block.thisIndex'
p335
I13
sg300
g315
sg302
g293
sg304
g316
sa(dp336
S'block.thisTrialN'
p337
I4
sS'block.thisRepN'
p338
I0
sg29
NsS'block.thisN'
p339
I4
sg287
(S'HALF'
S'ADD'
S'x'
S'y'
tp340
sg27
g28
sg289
I2
sg290
(I12
I6
tp341
sg22
I1
sg20
F1.6127902553271269
sg23
F4.6088262189878151
sVY
I8
sVX
I4
sg292
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p342
sg30
g11
sg295
I6
sg296
g313
sg298
I6
sS'block.thisIndex'
p343
I3
sg300
g297
sg302
I0
sg304
VUBxy
p344
sa(dp345
S'block.thisTrialN'
p346
I5
sS'block.thisRepN'
p347
I0
sg29
NsS'block.thisN'
p348
I5
sg287
(S'INCREASE'
S'ADD'
S'HALF'
S'x'
S'y'
tp349
sg27
g28
sg289
I3
sg290
(I1
I4
I5
tp350
sg22
I0
sg20
F1.9853760760161094
sg23
F16.127946648761281
sVY
I3
sVX
I2
sg292
g297
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p351
sg30
g11
sg295
I5
sg296
g313
sg298
I5
sS'block.thisIndex'
p352
I7
sg300
g301
sg302
I0
sg304
VUBUxy
p353
sa(dp354
S'block.thisTrialN'
p355
I6
sS'block.thisRepN'
p356
I0
sg29
NsS'block.thisN'
p357
I6
sg287
(S'DECREASE'
S'TRIPLE'
S'SUBTRACT'
S'DOUBLE'
S'x'
S'y'
tp358
sg27
g28
sg289
I4
sg290
(I6
I3
I9
I8
tp359
sg22
I0
sg20
F5.2514071156620048
sg23
F8.1518621031864313
sVY
I3
sVX
I3
sg292
g334
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p360
sg30
g11
sg295
I8
sg296
Vtriple
p361
sg298
I8
sS'block.thisIndex'
p362
I15
sg300
g315
sg302
g324
sg304
g326
sa(dp363
S'block.thisTrialN'
p364
I7
sS'block.thisRepN'
p365
I0
sg29
NsS'block.thisN'
p366
I7
sg287
(S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp367
sg27
g28
sg289
I2
sg290
(I8
I2
tp368
sg22
I1
sg20
F3.2761239864630625
sg23
F3.4662454972858541
sVY
I4
sVX
I9
sg292
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p369
sg30
g11
sg295
I2
sg296
g315
sg298
I2
sS'block.thisIndex'
p370
I1
sg300
VDIVIDE
p371
sg302
I0
sg304
VBUxy
p372
sa(dp373
S'block.thisTrialN'
p374
I8
sS'block.thisRepN'
p375
I0
sg29
NsS'block.thisN'
p376
I8
sg287
(S'DOUBLE'
S'THIRD'
S'ADD'
S'x'
S'y'
tp377
sg27
g28
sg289
I3
sg290
(I9
I3
I6
tp378
sg22
I1
sg20
F5.0588652574078878
sg23
F3.6290579578053439
sVY
I4
sVX
I5
sg292
g313
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p379
sg30
g11
sg295
I6
sg296
g293
sg298
I6
sS'block.thisIndex'
p380
I8
sg300
g324
sg302
I0
sg304
VUUBxy
p381
sa(dp382
S'block.thisTrialN'
p383
I9
sS'block.thisRepN'
p384
I0
sg29
NsS'block.thisN'
p385
I9
sg287
(S'ADD'
S'TRIPLE'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp386
sg27
g28
sg289
I4
sg290
(I1
I2
I6
I8
tp387
sg22
I1
sg20
F7.1623309107671957
sg23
F5.4058823961677263
sVY
I2
sVX
I2
sg292
g324
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p388
sg30
g11
sg295
I8
sg296
g361
sg298
I8
sS'block.thisIndex'
p389
I11
sg300
g313
sg302
g315
sg304
VBUUUxy
p390
sa(dp391
S'block.thisTrialN'
p392
I10
sS'block.thisRepN'
p393
I0
sg29
NsS'block.thisN'
p394
I10
sg287
(S'THIRD'
S'HALF'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp395
sg27
g28
sg289
I4
sg290
(I5
I6
I3
I1
tp396
sg22
I0
sg20
F2.3251293727516895
sg23
F10.1486739358661
sVY
I2
sVX
I7
sg292
g301
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p397
sg30
g11
sg295
I1
sg296
g297
sg298
I1
sS'block.thisIndex'
p398
I17
sg300
g293
sg302
g334
sg304
g305
sa(dp399
S'block.thisTrialN'
p400
I11
sS'block.thisRepN'
p401
I0
sg29
NsS'block.thisN'
p402
I11
sg287
(S'ADD'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp403
sg27
g28
sg289
I3
sg290
(I2
I6
I8
tp404
sg22
I0
sg20
F3.7479451019316912
sg23
F4.2465419233485591
sVY
I2
sVX
I4
sg292
g297
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p405
sg30
g11
sg295
I8
sg296
g361
sg298
I8
sS'block.thisIndex'
p406
I5
sg300
g313
sg302
I0
sg304
VBUUxy
p407
sa(dp408
S'block.thisTrialN'
p409
I12
sS'block.thisRepN'
p410
I0
sg29
NsS'block.thisN'
p411
I12
sg287
(S'ADD'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp412
sg27
g28
sg289
I4
sg290
(I18
I6
I5
I9
tp413
sg22
I1
sg20
F3.5241007600852754
sg23
F6.4146535308973398
sVY
I4
sVX
I9
sg292
g293
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p414
sg30
g11
sg295
I9
sg296
g315
sg298
I9
sS'block.thisIndex'
p415
I10
sg300
g313
sg302
g324
sg304
g390
sa(dp416
S'block.thisTrialN'
p417
I13
sS'block.thisRepN'
p418
I0
sg29
NsS'block.thisN'
p419
I13
sg287
(S'DECREASE'
S'TIMES'
S'x'
S'y'
tp420
sg27
g28
sg289
I2
sg290
(I9
I8
tp421
sg22
I1
sg20
F3.8844151112862164
sg23
F2.5616574410378234
sVY
I3
sVX
I3
sg292
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p422
sg30
g11
sg295
I8
sg296
g303
sg298
I8
sS'block.thisIndex'
p423
I2
sg300
g315
sg302
I0
sg304
g344
sa(dp424
S'block.thisTrialN'
p425
I14
sS'block.thisRepN'
p426
I0
sg29
NsS'block.thisN'
p427
I14
sg287
(S'ADD'
S'DECREASE'
S'x'
S'y'
tp428
sg27
g28
sg289
I2
sg290
(I2
I7
tp429
sg22
I0
sg20
F3.4635815752699273
sg23
F3.4936042423942126
sVY
I5
sVX
I3
sg292
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p430
sg30
g11
sg295
I7
sg296
g315
sg298
I7
sS'block.thisIndex'
p431
I0
sg300
g313
sg302
I0
sg304
g372
sa(dp432
S'block.thisTrialN'
p433
I15
sS'block.thisRepN'
p434
I0
sg29
NsS'block.thisN'
p435
I15
sg287
(S'HALF'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp436
sg27
g28
sg289
I3
sg290
(I9
I10
I5
tp437
sg22
I1
sg20
F2.07552386909083
sg23
F3.9173939199536107
sVY
I3
sVX
I3
sg292
g303
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p438
sg30
g11
sg295
I5
sg296
g301
sg298
I5
sS'block.thisIndex'
p439
I9
sg300
g297
sg302
I0
sg304
g381
sa(dp440
S'block.thisTrialN'
p441
I16
sS'block.thisRepN'
p442
I0
sg29
NsS'block.thisN'
p443
I16
sg287
(S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp444
sg27
g28
sg289
I3
sg290
(I4
I1
I2
tp445
sg22
I1
sg20
F2.2033707782538841
sg23
F13.699784177530091
sVY
I3
sVX
I3
sg292
g301
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p446
sg30
g11
sg295
I2
sg296
g334
sg298
I2
sS'block.thisIndex'
p447
I6
sg300
g324
sg302
I0
sg304
g353
sa(dp448
S'block.thisTrialN'
p449
I17
sS'block.thisRepN'
p450
I0
sg29
NsS'block.thisN'
p451
I17
sg287
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp452
sg27
g28
sg289
I3
sg290
(I1
I2
I7
tp453
sg22
I0
sg20
F2.8303132068249397
sg23
F3.4617397174588405
sVY
I5
sVX
I2
sg292
g315
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p454
sg30
g11
sg295
I7
sg296
g324
sg298
I7
sS'block.thisIndex'
p455
I4
sg300
g313
sg302
I0
sg304
g407
sa(dp456
S'block.thisTrialN'
p457
I0
sS'block.thisRepN'
p458
I0
sg29
NsS'block.thisN'
p459
I0
sVRule
p460
(S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp461
sg27
g28
sVLength
p462
I3
sVIntermediate
p463
(I6
I3
I9
tp464
sg22
I0
sVY
I3
sVX
I3
sVOperatorc
p465
VADD
p466
sg31
g32
sg33
g34
sg21
Nsg19
Nsg30
g11
sVResult
p467
I9
sVOperatora
p468
Vhalf
p469
sVCorrectResponse
p470
I9
sS'block.thisIndex'
p471
I8
sVOperatorb
p472
Vtriple
p473
sVOperatord
p474
I0
sVStructure
p475
VUUBxy
p476
sa(dp477
S'block.thisTrialN'
p478
I1
sS'block.thisRepN'
p479
I0
sg29
NsS'block.thisN'
p480
I1
sg460
(S'DOUBLE'
S'DIVIDE'
S'x'
S'y'
tp481
sg27
g28
sg462
I2
sg463
(I1
I2
tp482
sg22
I1
sg20
F3.5872089747426799
sg23
F2.4466181454045
sVY
I8
sVX
I8
sg465
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p483
sg30
g11
sg467
I2
sg468
VDIVIDE
p484
sg470
I2
sS'block.thisIndex'
p485
I2
sg472
Vdouble
p486
sg474
I0
sg475
VUBxy
p487
sa(dp488
S'block.thisTrialN'
p489
I2
sS'block.thisRepN'
p490
I0
sg29
NsS'block.thisN'
p491
I2
sg460
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'TRIPLE'
S'x'
S'y'
tp492
sg27
g28
sg462
I4
sg463
(I9
I10
I20
I5
tp493
sg22
I0
sg20
F3.3948931929044193
sVY
I4
sVX
I3
sg465
Vincrease
p494
sg31
g32
sg33
g34
sg21
Nsg19
S'space'
p495
sg30
g11
sg467
I5
sg468
g486
sg470
I5
sS'block.thisIndex'
p496
I10
sg472
g484
sg474
g473
sg475
VBUUUxy
p497
sa(dp498
S'block.thisTrialN'
p499
I3
sS'block.thisRepN'
p500
I0
sg29
NsS'block.thisN'
p501
I3
sg460
(S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp502
sg27
g28
sg462
I2
sg463
(I4
I5
tp503
sg22
I1
sg20
F2.3486955636180937
sg23
F5.2360272705554962
sVY
I2
sVX
I8
sg465
I0
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p504
sg30
g11
sg467
I5
sg468
g484
sg470
I5
sS'block.thisIndex'
p505
I3
sg472
g494
sg474
I0
sg475
g487
sa(dp506
S'block.thisTrialN'
p507
I4
sS'block.thisRepN'
p508
I0
sg29
NsS'block.thisN'
p509
I4
sg460
(S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp510
sg27
g28
sg462
I4
sg463
(I16
I2
I3
I9
tp511
sg22
I1
sg20
F5.6956434096064186
sg23
F4.0978214423375903
sVY
I8
sVX
I8
sg465
g484
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p512
sg30
g11
sg467
I9
sg468
g494
sg470
I9
sS'block.thisIndex'
p513
I15
sg472
g473
sg474
g486
sg475
VUUBUxy
p514
sa(dp515
S'block.thisTrialN'
p516
I5
sS'block.thisRepN'
p517
I0
sg29
NsS'block.thisN'
p518
I5
sg460
(S'THIRD'
S'INCREASE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp519
sg27
g28
sg462
I4
sg463
(I28
I14
I15
I5
tp520
sg22
I0
sg20
F5.4129485088196816
sVY
I4
sVX
I7
sg465
g469
sg31
g32
sg33
g34
sg21
Nsg19
S'space'
p521
sg30
g11
sg467
I5
sg468
g494
sg470
I5
sS'block.thisIndex'
p522
I17
sg472
Vthird
p523
sg474
VTIMES
p524
sg475
VUUUBxy
p525
sa(dp526
S'block.thisTrialN'
p527
I6
sS'block.thisRepN'
p528
I0
sg29
NsS'block.thisN'
p529
I6
sg460
(S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp530
sg27
g28
sg462
I2
sg463
(I12
I9
tp531
sg22
I0
sg20
F2.0067217485775473
sg23
F8.057102491351543
sVY
I3
sVX
I4
sg465
I0
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p532
sg30
g11
sg467
I9
sg468
g473
sg470
I9
sS'block.thisIndex'
p533
I1
sg472
VSUBTRACT
p534
sg474
I0
sg475
VBUxy
p535
sa(dp536
S'block.thisTrialN'
p537
I7
sS'block.thisRepN'
p538
I0
sg29
NsS'block.thisN'
p539
I7
sg460
(S'HALF'
S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp540
sg27
g28
sg462
I4
sg463
(I15
I14
I10
I5
tp541
sg22
I0
sg20
F4.06635552579246
sg23
F8.8818113829911454
sVY
I4
sVX
I5
sg465
Vdecrease
p542
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p543
sg30
g11
sg467
I5
sg468
g534
sg470
I5
sS'block.thisIndex'
p544
I12
sg472
g469
sg474
g473
sg475
VUBUUxy
p545
sa(dp546
S'block.thisTrialN'
p547
I8
sS'block.thisRepN'
p548
I0
sg29
NsS'block.thisN'
p549
I8
sg460
(S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp550
sg27
g28
sg462
I3
sg463
(I1
I2
I6
tp551
sg22
I0
sg20
F1.7333512747864006
sg23
F3.7254707971296739
sVY
I2
sVX
I3
sg465
g534
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p552
sg30
g11
sg467
I6
sg468
g494
sg470
I6
sS'block.thisIndex'
p553
I9
sg472
g473
sg474
I0
sg475
g476
sa(dp554
S'block.thisTrialN'
p555
I9
sS'block.thisRepN'
p556
I0
sg29
NsS'block.thisN'
p557
I9
sg460
(S'INCREASE'
S'TIMES'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp558
sg27
g28
sg462
I4
sg463
(I1
I3
I6
I7
tp559
sg22
I1
sg20
F3.8351154057163512
sg23
F10.31190775243158
sVY
I2
sVX
I2
sg465
g473
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p560
sg30
g11
sg467
I7
sg468
g524
sg470
I7
sS'block.thisIndex'
p561
I13
sg472
g494
sg474
g469
sg475
g545
sa(dp562
S'block.thisTrialN'
p563
I10
sS'block.thisRepN'
p564
I0
sg29
NsS'block.thisN'
p565
I10
sg460
(S'DIVIDE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp566
sg27
g28
sg462
I3
sg463
(I6
I18
I9
tp567
sg22
I0
sg20
F2.9884473555284785
sVY
I2
sVX
I7
sg465
g542
sg31
g32
sg33
g34
sg21
Nsg19
S'space'
p568
sg30
g11
sg467
I9
sg468
g473
sg470
I9
sS'block.thisIndex'
p569
I4
sg472
g484
sg474
I0
sg475
VBUUxy
p570
sa(dp571
S'block.thisTrialN'
p572
I11
sS'block.thisRepN'
p573
I0
sg29
NsS'block.thisN'
p574
I11
sg460
(S'TIMES'
S'HALF'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp575
sg27
g28
sg462
I4
sg463
(I1
I2
I1
I9
tp576
sg22
I0
sg20
F3.8075340838113334
sg23
F6.5052846235485049
sVY
I9
sVX
I3
sg465
g494
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p577
sg30
g11
sg467
I9
sg468
g469
sg470
I9
sS'block.thisIndex'
p578
I11
sg472
g524
sg474
g523
sg475
g497
sa(dp579
S'block.thisTrialN'
p580
I12
sS'block.thisRepN'
p581
I0
sg29
NsS'block.thisN'
p582
I12
sg460
(S'HALF'
S'TIMES'
S'DECREASE'
S'x'
S'y'
tp583
sg27
g28
sg462
I3
sg463
(I8
I16
I8
tp584
sg22
I1
sg20
F7.1823950170801254
sg23
F10.287400859728223
sVY
I2
sVX
I9
sg465
g542
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p585
sg30
g11
sg467
I8
sg468
g524
sg470
I8
sS'block.thisIndex'
p586
I6
sg472
g469
sg474
I0
sg475
VUBUxy
p587
sa(dp588
S'block.thisTrialN'
p589
I13
sS'block.thisRepN'
p590
I0
sg29
NsS'block.thisN'
p591
I13
sg460
(S'DECREASE'
S'THIRD'
S'DOUBLE'
S'ADD'
S'x'
S'y'
tp592
sg27
g28
sg462
I4
sg463
(I9
I18
I6
I5
tp593
sg22
I0
sg20
F4.746794771970599
sg23
F4.4080234727589414
sVY
I4
sVX
I5
sg465
g486
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p594
sg30
g11
sg467
I5
sg468
g523
sg470
I5
sS'block.thisIndex'
p595
I16
sg472
g542
sg474
g466
sg475
g525
sa(dp596
S'block.thisTrialN'
p597
I14
sS'block.thisRepN'
p598
I0
sg29
NsS'block.thisN'
p599
I14
sg460
(S'ADD'
S'HALF'
S'x'
S'y'
tp600
sg27
g28
sg462
I2
sg463
(I2
I7
tp601
sg22
I1
sg20
F2.210772505888599
sg23
F5.9198296657705214
sVY
I5
sVX
I4
sg465
I0
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p602
sg30
g11
sg467
I7
sg468
g469
sg470
I7
sS'block.thisIndex'
p603
I0
sg472
g466
sg474
I0
sg475
g535
sa(dp604
S'block.thisTrialN'
p605
I15
sS'block.thisRepN'
p606
I0
sg29
NsS'block.thisN'
p607
I15
sg460
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp608
sg27
g28
sg462
I4
sg463
(I5
I1
I2
I6
tp609
sg22
I1
sg20
F3.4891047619166784
sg23
F9.4307224541116739
sVY
I4
sVX
I4
sg465
g534
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p610
sg30
g11
sg467
I6
sg468
g486
sg470
I6
sS'block.thisIndex'
p611
I14
sg472
g473
sg474
g494
sg475
g514
sa(dp612
S'block.thisTrialN'
p613
I16
sS'block.thisRepN'
p614
I0
sg29
NsS'block.thisN'
p615
I16
sg460
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'x'
S'y'
tp616
sg27
g28
sg462
I3
sg463
(I6
I2
I3
tp617
sg22
I0
sg20
F3.0720728791930014
sg23
F15.323930047903559
sVY
I3
sVX
I2
sg465
g473
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p618
sg30
g11
sg467
I3
sg468
g484
sg470
I3
sS'block.thisIndex'
p619
I7
sg472
g494
sg474
I0
sg475
g587
sa(dp620
S'block.thisTrialN'
p621
I17
sS'block.thisRepN'
p622
I0
sg29
NsS'block.thisN'
p623
I17
sg460
(S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp624
sg27
g28
sg462
I3
sg463
(I4
I5
I3
tp625
sg22
I0
sg20
F2.7795744514151011
sg23
F4.3851866057812003
sVY
I2
sVX
I8
sg465
g469
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p626
sg30
g11
sg467
I3
sg468
g494
sg470
I3
sS'block.thisIndex'
p627
I5
sg472
g534
sg474
I0
sg475
g570
sa(dp628
S'block.thisTrialN'
p629
I0
sS'block.thisRepN'
p630
I0
sg29
NsS'block.thisN'
p631
I0
sVRule
p632
(S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp633
sg27
g28
sVLength
p634
I2
sVIntermediate
p635
(I3
I1
tp636
sg22
I0
sg20
F2.658495486000902
sg23
F3.9724571740953252
sVY
I3
sVX
I9
sVOperatorc
p637
I0
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p638
sg30
g11
sVResult
p639
I1
sVOperatora
p640
Vthird
p641
sVCorrectResponse
p642
I1
sS'block.thisIndex'
p643
I0
sVOperatorb
p644
VDIVIDE
p645
sVOperatord
p646
I0
sVStructure
p647
VBUxy
p648
sa(dp649
S'block.thisTrialN'
p650
I1
sS'block.thisRepN'
p651
I0
sg29
NsS'block.thisN'
p652
I1
sg632
(S'THIRD'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp653
sg27
g28
sg634
I3
sg635
(I6
I3
I1
tp654
sg22
I1
sg20
F3.4073378942994168
sg23
F7.5921004143165192
sVY
I2
sVX
I7
sg637
Vdecrease
p655
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p656
sg30
g11
sg639
I1
sg640
g645
sg642
I1
sS'block.thisIndex'
p657
I6
sg644
g641
sg646
I0
sg647
VUBUxy
p658
sa(dp659
S'block.thisTrialN'
p660
I2
sS'block.thisRepN'
p661
I0
sg29
NsS'block.thisN'
p662
I2
sg632
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp663
sg27
g28
sg634
I3
sg635
(I4
I12
I3
tp664
sg22
I0
sg20
F2.5443216500279959
sg23
F14.46978572786611
sVY
I9
sVX
I5
sg637
g655
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p665
sg30
g11
sg639
I3
sg640
Vtriple
p666
sg642
I3
sS'block.thisIndex'
p667
I4
sg644
VSUBTRACT
p668
sg646
I0
sg647
VBUUxy
p669
sa(dp670
S'block.thisTrialN'
p671
I3
sS'block.thisRepN'
p672
I0
sg29
NsS'block.thisN'
p673
I3
sg632
(S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp674
sg27
g28
sg634
I3
sg635
(I3
I18
I6
tp675
sg22
I0
sg20
F3.0260064862231957
sg23
F4.4599542037758511
sVY
I6
sVX
I6
sg637
Vhalf
p676
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p677
sg30
g11
sg639
I6
sg640
VTIMES
p678
sg642
I6
sS'block.thisIndex'
p679
I7
sg644
g641
sg646
I0
sg647
g658
sa(dp680
S'block.thisTrialN'
p681
I4
sS'block.thisRepN'
p682
I0
sg29
NsS'block.thisN'
p683
I4
sg632
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp684
sg27
g28
sg634
I4
sg635
(I6
I2
I6
I5
tp685
sg22
I0
sg20
F4.9050405590242008
sg23
F9.5187029233493377
sVY
I3
sVX
I3
sg637
g645
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p686
sg30
g11
sg639
I5
sg640
g666
sg642
I5
sS'block.thisIndex'
p687
I14
sg644
g655
sg646
Vdouble
p688
sg647
VUUBUxy
p689
sa(dp690
S'block.thisTrialN'
p691
I5
sS'block.thisRepN'
p692
I0
sg29
NsS'block.thisN'
p693
I5
sg632
(S'THIRD'
S'DECREASE'
S'TIMES'
S'HALF'
S'x'
S'y'
tp694
sg27
g28
sg634
I4
sg635
(I4
I16
I15
I5
tp695
sg22
I0
sg20
F3.262314077524934
sg23
F5.268018132308498
sVY
I4
sVX
I8
sg637
g678
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p696
sg30
g11
sg639
I5
sg640
g655
sg642
I5
sS'block.thisIndex'
p697
I15
sg644
g641
sg646
g676
sg647
g689
sa(dp698
S'block.thisTrialN'
p699
I6
sS'block.thisRepN'
p700
I0
sg29
NsS'block.thisN'
p701
I6
sg632
(S'INCREASE'
S'ADD'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp702
sg27
g28
sg634
I4
sg635
(I6
I3
I6
I7
tp703
sg22
I0
sg20
F2.5000407707411796
sg23
F15.905257536374847
sVY
I3
sVX
I2
sg637
g676
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p704
sg30
g11
sg639
I7
sg640
VADD
p705
sg642
I7
sS'block.thisIndex'
p706
I13
sg644
Vincrease
p707
sg646
g666
sg647
VUBUUxy
p708
sa(dp709
S'block.thisTrialN'
p710
I7
sS'block.thisRepN'
p711
I0
sg29
NsS'block.thisN'
p712
I7
sg632
(S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp713
sg27
g28
sg634
I2
sg635
(I3
I4
tp714
sg22
I1
sg20
F4.0637017527187709
sg23
F5.7583439168083714
sVY
I3
sVX
I6
sg637
I0
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p715
sg30
g11
sg639
I4
sg640
g668
sg642
I4
sS'block.thisIndex'
p716
I2
sg644
g707
sg646
I0
sg647
VUBxy
p717
sa(dp718
S'block.thisTrialN'
p719
I8
sS'block.thisRepN'
p720
I0
sg29
NsS'block.thisN'
p721
I8
sg632
(S'SUBTRACT'
S'DOUBLE'
S'TRIPLE'
S'DECREASE'
S'x'
S'y'
tp722
sg27
g28
sg634
I4
sg635
(I2
I6
I12
I8
tp723
sg22
I0
sg20
F5.1735535396874184
sg23
F5.0224400083825458
sVY
I4
sVX
I3
sg637
g666
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p724
sg30
g11
sg639
I8
sg640
g688
sg642
I8
sS'block.thisIndex'
p725
I10
sg644
g668
sg646
g655
sg647
VBUUUxy
p726
sa(dp727
S'block.thisTrialN'
p728
I9
sS'block.thisRepN'
p729
I0
sg29
NsS'block.thisN'
p730
I9
sg632
(S'DOUBLE'
S'DECREASE'
S'ADD'
S'x'
S'y'
tp731
sg27
g28
sg634
I3
sg635
(I4
I3
I6
tp732
sg22
I1
sg20
F2.1685501118045067
sg23
F12.013608329958515
sVY
I2
sVX
I2
sg637
g705
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p733
sg30
g11
sg639
I6
sg640
g655
sg642
I6
sS'block.thisIndex'
p734
I8
sg644
g688
sg646
I0
sg647
VUUBxy
p735
sa(dp736
S'block.thisTrialN'
p737
I10
sS'block.thisRepN'
p738
I0
sg29
NsS'block.thisN'
p739
I10
sg632
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp740
sg27
g28
sg634
I4
sg635
(I4
I2
I6
I5
tp741
sg22
I0
sg20
F4.4863155529601499
sg23
F11.754308137940825
sVY
I2
sVX
I6
sg637
g676
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p742
sg30
g11
sg639
I5
sg640
g666
sg642
I5
sS'block.thisIndex'
p743
I16
sg644
g655
sg646
g668
sg647
VUUUBxy
p744
sa(dp745
S'block.thisTrialN'
p746
I11
sS'block.thisRepN'
p747
I0
sg29
NsS'block.thisN'
p748
I11
sg632
(S'THIRD'
S'DIVIDE'
S'x'
S'y'
tp749
sg27
g28
sg634
I2
sg635
(I3
I1
tp750
sg22
I1
sg20
F1.4714746516256128
sg23
F4.4350704004027648
sVY
I2
sVX
I6
sg637
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p751
sg30
g11
sg639
I1
sg640
g645
sg642
I1
sS'block.thisIndex'
p752
I3
sg644
g641
sg646
I0
sg647
g717
sa(dp753
S'block.thisTrialN'
p754
I12
sS'block.thisRepN'
p755
I0
sg29
NsS'block.thisN'
p756
I12
sg632
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp757
sg27
g28
sg634
I4
sg635
(I1
I2
I6
I3
tp758
sg22
I0
sg20
F4.4535558214411139
sg23
F5.4408262497890973
sVY
I2
sVX
I3
sg637
g707
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p759
sg30
g11
sg639
I3
sg640
g666
sg642
I3
sS'block.thisIndex'
p760
I17
sg644
g676
sg646
g668
sg647
g744
sa(dp761
S'block.thisTrialN'
p762
I13
sS'block.thisRepN'
p763
I0
sg29
NsS'block.thisN'
p764
I13
sg632
(S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp765
sg27
g28
sg634
I3
sg635
(I6
I3
I9
tp766
sg22
I1
sg20
F1.2068312171613798
sg23
F11.010263029049383
sVY
I3
sVX
I5
sg637
g707
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p767
sg30
g11
sg639
I9
sg640
g676
sg642
I9
sS'block.thisIndex'
p768
I5
sg644
g678
sg646
I0
sg647
g669
sa(dp769
S'block.thisTrialN'
p770
I14
sS'block.thisRepN'
p771
I0
sg29
NsS'block.thisN'
p772
I14
sg632
(S'DOUBLE'
S'DIVIDE'
S'TRIPLE'
S'INCREASE'
S'x'
S'y'
tp773
sg27
g28
sg634
I4
sg635
(I5
I15
I3
I6
tp774
sg22
I0
sg20
F3.0946644217619905
sg23
F10.764470727473963
sVY
I5
sVX
I4
sg637
g666
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p775
sg30
g11
sg639
I6
sg640
g645
sg642
I6
sS'block.thisIndex'
p776
I12
sg644
g688
sg646
g707
sg647
g708
sa(dp777
S'block.thisTrialN'
p778
I15
sS'block.thisRepN'
p779
I0
sg29
NsS'block.thisN'
p780
I15
sg632
(S'SUBTRACT'
S'TRIPLE'
S'DECREASE'
S'DOUBLE'
S'x'
S'y'
tp781
sg27
g28
sg634
I4
sg635
(I4
I3
I9
I1
tp782
sg22
I0
sg20
F3.598025296072592
sg23
F11.877736758164247
sVY
I8
sVX
I2
sg637
g655
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p783
sg30
g11
sg639
I1
sg640
g666
sg642
I1
sS'block.thisIndex'
p784
I11
sg644
g668
sg646
g688
sg647
g726
sa(dp785
S'block.thisTrialN'
p786
I16
sS'block.thisRepN'
p787
I0
sg29
NsS'block.thisN'
p788
I16
sg632
(S'DOUBLE'
S'THIRD'
S'TIMES'
S'x'
S'y'
tp789
sg27
g28
sg634
I3
sg635
(I12
I4
I8
tp790
sg22
I0
sg20
F1.6848463362839539
sg23
F4.6733668341767043
sVY
I6
sVX
I2
sg637
g678
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p791
sg30
g11
sg639
I8
sg640
g641
sg642
I8
sS'block.thisIndex'
p792
I9
sg644
g688
sg646
I0
sg647
g735
sa(dp793
S'block.thisTrialN'
p794
I17
sS'block.thisRepN'
p795
I0
sg29
NsS'block.thisN'
p796
I17
sg632
(S'TIMES'
S'DOUBLE'
S'x'
S'y'
tp797
sg27
g28
sg634
I2
sg635
(I4
I8
tp798
sg22
I1
sg20
F1.4010217533796094
sg23
F3.1170379370887531
sVY
I2
sVX
I2
sg637
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p799
sg30
g11
sg639
I8
sg640
g688
sg642
I8
sS'block.thisIndex'
p800
I1
sg644
g678
sg646
I0
sg647
g648
sa(dp801
S'block.thisTrialN'
p802
I0
sS'block.thisRepN'
p803
I0
sg29
NsS'block.thisN'
p804
I0
sVRule
p805
(S'TIMES'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp806
sg27
g28
sVLength
p807
I4
sVIntermediate
p808
(I6
I2
I1
I2
tp809
sg22
I0
sg20
F3.9430364441359416
sg23
F9.1421240193594713
sVY
I2
sVX
I3
sVOperatorc
p810
Vthird
p811
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p812
sg30
g11
sVResult
p813
I2
sVOperatora
p814
Vdecrease
p815
sVCorrectResponse
p816
I2
sS'block.thisIndex'
p817
I11
sVOperatorb
p818
VTIMES
p819
sVOperatord
p820
Vdouble
p821
sVStructure
p822
VBUUUxy
p823
sa(dp824
S'block.thisTrialN'
p825
I1
sS'block.thisRepN'
p826
I0
sg29
NsS'block.thisN'
p827
I1
sg805
(S'INCREASE'
S'DIVIDE'
S'HALF'
S'x'
S'y'
tp828
sg27
g28
sg807
I3
sg808
(I2
I1
I2
tp829
sg22
I0
sg20
F4.1965195431839675
sg23
F7.4106146023696056
sVY
I2
sVX
I4
sg810
Vhalf
p830
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p831
sg30
g11
sg813
I2
sg814
VDIVIDE
p832
sg816
I2
sS'block.thisIndex'
p833
I7
sg818
Vincrease
p834
sg820
I0
sg822
VUBUxy
p835
sa(dp836
S'block.thisTrialN'
p837
I2
sS'block.thisRepN'
p838
I0
sg29
NsS'block.thisN'
p839
I2
sg805
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp840
sg27
g28
sg807
I4
sg808
(I4
I2
I3
I1
tp841
sg22
I0
sg20
F3.2977188330405625
sVY
I2
sVX
I8
sg810
VSUBTRACT
p842
sg31
g32
sg33
g34
sg21
Nsg19
S'space'
p843
sg30
g11
sg813
I1
sg814
g834
sg816
I1
sS'block.thisIndex'
p844
I15
sg818
g811
sg820
g830
sg822
VUUBUxy
p845
sa(dp846
S'block.thisTrialN'
p847
I3
sS'block.thisRepN'
p848
I0
sg29
NsS'block.thisN'
p849
I3
sg805
(S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp850
sg27
g28
sg807
I2
sg808
(I2
I6
tp851
sg22
I1
sg20
F1.185078537062509
sg23
F3.5573689885495696
sVY
I6
sVX
I8
sg810
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p852
sg30
g11
sg813
I6
sg814
g842
sg816
I6
sS'block.thisIndex'
p853
I3
sg818
Vtriple
p854
sg820
I0
sg822
VUBxy
p855
sa(dp856
S'block.thisTrialN'
p857
I4
sS'block.thisRepN'
p858
I0
sg29
NsS'block.thisN'
p859
I4
sg805
(S'INCREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp860
sg27
g28
sg807
I4
sg808
(I4
I2
I6
I7
tp861
sg22
I0
sg20
F4.355585994606372
sg23
F10.007846531210816
sVY
I2
sVX
I2
sg810
g830
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p862
sg30
g11
sg813
I7
sg814
g854
sg816
I7
sS'block.thisIndex'
p863
I17
sg818
g834
sg820
VADD
p864
sg822
VUUUBxy
p865
sa(dp866
S'block.thisTrialN'
p867
I5
sS'block.thisRepN'
p868
I0
sg29
NsS'block.thisN'
p869
I5
sg805
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'ADD'
S'x'
S'y'
tp870
sg27
g28
sg807
I4
sg808
(I4
I12
I6
I5
tp871
sg22
I0
sg20
F4.4680296111182543
sg23
F14.928713838715339
sVY
I2
sVX
I2
sg810
g854
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p872
sg30
g11
sg813
I5
sg814
g830
sg816
I5
sS'block.thisIndex'
p873
I16
sg818
g815
sg820
g864
sg822
g865
sa(dp874
S'block.thisTrialN'
p875
I6
sS'block.thisRepN'
p876
I0
sg29
NsS'block.thisN'
p877
I6
sg805
(S'DECREASE'
S'HALF'
S'DIVIDE'
S'x'
S'y'
tp878
sg27
g28
sg807
I3
sg808
(I4
I2
I1
tp879
sg22
I0
sg20
F2.3559741041099187
sg23
F5.2044955608871533
sVY
I2
sVX
I8
sg810
g832
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p880
sg30
g11
sg813
I1
sg814
g830
sg816
I1
sS'block.thisIndex'
p881
I8
sg818
g815
sg820
I0
sg822
VUUBxy
p882
sa(dp883
S'block.thisTrialN'
p884
I7
sS'block.thisRepN'
p885
I0
sg29
NsS'block.thisN'
p886
I7
sg805
(S'DECREASE'
S'DIVIDE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp887
sg27
g28
sg807
I4
sg808
(I6
I18
I2
I1
tp888
sg22
I0
sg20
F4.2627105861465679
sg23
F16.2669769909553
sVY
I9
sVX
I3
sg810
g854
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p889
sg30
g11
sg813
I1
sg814
g832
sg816
I1
sS'block.thisIndex'
p890
I12
sg818
g815
sg820
g821
sg822
VUBUUxy
p891
sa(dp892
S'block.thisTrialN'
p893
I8
sS'block.thisRepN'
p894
I0
sg29
NsS'block.thisN'
p895
I8
sg805
(S'INCREASE'
S'HALF'
S'TIMES'
S'TRIPLE'
S'x'
S'y'
tp896
sg27
g28
sg807
I4
sg808
(I6
I12
I6
I7
tp897
sg22
I1
sg20
F5.4873097992240218
sg23
F13.716336400291766
sVY
I2
sVX
I2
sg810
g819
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p898
sg30
g11
sg813
I7
sg814
g830
sg816
I7
sS'block.thisIndex'
p899
I14
sg818
g834
sg820
g854
sg822
g845
sa(dp900
S'block.thisTrialN'
p901
I9
sS'block.thisRepN'
p902
I0
sg29
NsS'block.thisN'
p903
I9
sg805
(S'TIMES'
S'THIRD'
S'x'
S'y'
tp904
sg27
g28
sg807
I2
sg808
(I1
I4
tp905
sg22
I1
sg20
F2.0553589732880937
sg23
F6.0110329487069976
sVY
I4
sVX
I3
sg810
I0
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p906
sg30
g11
sg813
I4
sg814
g811
sg816
I4
sS'block.thisIndex'
p907
I1
sg818
g819
sg820
I0
sg822
VBUxy
p908
sa(dp909
S'block.thisTrialN'
p910
I10
sS'block.thisRepN'
p911
I0
sg29
NsS'block.thisN'
p912
I10
sg805
(S'TRIPLE'
S'SUBTRACT'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp913
sg27
g28
sg807
I4
sg808
(I3
I4
I1
I3
tp914
sg22
I0
sg20
F5.2215191844734363
sg23
F1.580941128791892
sVY
I3
sVX
I6
sg810
g834
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p915
sg30
g11
sg813
I3
sg814
g842
sg816
I3
sS'block.thisIndex'
p916
I13
sg818
g854
sg820
g830
sg822
g891
sa(dp917
S'block.thisTrialN'
p918
I11
sS'block.thisRepN'
p919
I0
sg29
NsS'block.thisN'
p920
I11
sg805
(S'DOUBLE'
S'TIMES'
S'THIRD'
S'x'
S'y'
tp921
sg27
g28
sg807
I3
sg808
(I1
I4
I8
tp922
sg22
I1
sg20
F3.4370116478385171
sg23
F10.057438806252321
sVY
I4
sVX
I3
sg810
g811
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p923
sg30
g11
sg813
I8
sg814
g819
sg816
I8
sS'block.thisIndex'
p924
I6
sg818
g821
sg820
I0
sg822
g835
sa(dp925
S'block.thisTrialN'
p926
I12
sS'block.thisRepN'
p927
I0
sg29
NsS'block.thisN'
p928
I12
sg805
(S'DIVIDE'
S'DECREASE'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp929
sg27
g28
sg807
I4
sg808
(I12
I4
I3
I1
tp930
sg22
I1
sg20
F1.8907085045648273
sg23
F6.8923452837625518
sVY
I3
sVX
I6
sg810
g811
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p931
sg30
g11
sg813
I1
sg814
g815
sg816
I1
sS'block.thisIndex'
p932
I10
sg818
g832
sg820
g821
sg822
g823
sa(dp933
S'block.thisTrialN'
p934
I13
sS'block.thisRepN'
p935
I0
sg29
NsS'block.thisN'
p936
I13
sg805
(S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp937
sg27
g28
sg807
I2
sg808
(I3
I1
tp938
sg22
I0
sg20
F1.099831632556743
sg23
F5.7341484916105401
sVY
I2
sVX
I9
sg810
I0
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p939
sg30
g11
sg813
I1
sg814
g811
sg816
I1
sS'block.thisIndex'
p940
I0
sg818
g842
sg820
I0
sg822
g908
sa(dp941
S'block.thisTrialN'
p942
I14
sS'block.thisRepN'
p943
I0
sg29
NsS'block.thisN'
p944
I14
sg805
(S'SUBTRACT'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp945
sg27
g28
sg807
I3
sg808
(I8
I16
I7
tp946
sg22
I0
sg20
F2.5887341156048933
sg23
F4.0958570973161841
sVY
I9
sVX
I9
sg810
g815
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p947
sg30
g11
sg813
I7
sg814
g821
sg816
I7
sS'block.thisIndex'
p948
I5
sg818
g842
sg820
I0
sg822
VBUUxy
p949
sa(dp950
S'block.thisTrialN'
p951
I15
sS'block.thisRepN'
p952
I0
sg29
NsS'block.thisN'
p953
I15
sg805
(S'ADD'
S'DECREASE'
S'HALF'
S'x'
S'y'
tp954
sg27
g28
sg807
I3
sg808
(I3
I2
I6
tp955
sg22
I1
sg20
F1.6831441139074741
sg23
F16.068698881266755
sVY
I4
sVX
I6
sg810
g830
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p956
sg30
g11
sg813
I6
sg814
g815
sg816
I6
sS'block.thisIndex'
p957
I4
sg818
g864
sg820
I0
sg822
g949
sa(dp958
S'block.thisTrialN'
p959
I16
sS'block.thisRepN'
p960
I0
sg29
NsS'block.thisN'
p961
I16
sg805
(S'INCREASE'
S'TIMES'
S'x'
S'y'
tp962
sg27
g28
sg807
I2
sg808
(I8
I9
tp963
sg22
I1
sg20
F3.658572127998923
sg23
F1.6866210011066869
sVY
I4
sVX
I2
sg810
I0
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p964
sg30
g11
sg813
I9
sg814
g819
sg816
I9
sS'block.thisIndex'
p965
I2
sg818
g834
sg820
I0
sg822
g855
sa(dp966
S'block.thisTrialN'
p967
I17
sS'block.thisRepN'
p968
I0
sg29
NsS'block.thisN'
p969
I17
sg805
(S'TRIPLE'
S'HALF'
S'TIMES'
S'x'
S'y'
tp970
sg27
g28
sg807
I3
sg808
(I6
I3
I9
tp971
sg22
I0
sg20
F4.5750067980407039
sg23
F12.357434851670405
sVY
I3
sVX
I2
sg810
g819
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p972
sg30
g11
sg813
I9
sg814
g830
sg816
I9
sS'block.thisIndex'
p973
I9
sg818
g854
sg820
I0
sg822
g882
sa(dp974
S'block.thisTrialN'
p975
I0
sS'block.thisRepN'
p976
I0
sg29
NsS'block.thisN'
p977
I0
sVRule
p978
(S'THIRD'
S'INCREASE'
S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp979
sg27
g28
sVLength
p980
I4
sVIntermediate
p981
(I18
I2
I3
I1
tp982
sg22
I1
sg20
F2.8582885875803186
sg23
F11.32670385845995
sVY
I9
sVX
I9
sVOperatorc
p983
VDIVIDE
p984
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p985
sg30
g11
sVResult
p986
I1
sVOperatora
p987
Vincrease
p988
sVCorrectResponse
p989
I1
sS'block.thisIndex'
p990
I15
sVOperatorb
p991
Vthird
p992
sVOperatord
p993
Vdouble
p994
sVStructure
p995
VUUBUxy
p996
sa(dp997
S'block.thisTrialN'
p998
I1
sS'block.thisRepN'
p999
I0
sg29
NsS'block.thisN'
p1000
I1
sg978
(S'INCREASE'
S'SUBTRACT'
S'HALF'
S'x'
S'y'
tp1001
sg27
g28
sg980
I3
sg981
(I4
I2
I3
tp1002
sg22
I0
sg20
F1.6349747903877869
sg23
F10.236506020606612
sVY
I2
sVX
I8
sg983
Vhalf
p1003
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1004
sg30
g11
sg986
I3
sg987
VSUBTRACT
p1005
sg989
I3
sS'block.thisIndex'
p1006
I7
sg991
g988
sg993
I0
sg995
VUBUxy
p1007
sa(dp1008
S'block.thisTrialN'
p1009
I2
sS'block.thisRepN'
p1010
I0
sg29
NsS'block.thisN'
p1011
I2
sg978
(S'ADD'
S'DOUBLE'
S'DECREASE'
S'THIRD'
S'x'
S'y'
tp1012
sg27
g28
sg980
I4
sg981
(I2
I1
I2
I8
tp1013
sg22
I1
sg20
F2.5012456950207707
sg23
F16.725357058996451
sVY
I6
sVX
I6
sg983
Vdecrease
p1014
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1015
sg30
g11
sg986
I8
sg987
g994
sg989
I8
sS'block.thisIndex'
p1016
I10
sg991
VADD
p1017
sg993
g992
sg995
VBUUUxy
p1018
sa(dp1019
S'block.thisTrialN'
p1020
I3
sS'block.thisRepN'
p1021
I0
sg29
NsS'block.thisN'
p1022
I3
sg978
(S'DOUBLE'
S'ADD'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp1023
sg27
g28
sg980
I4
sg981
(I1
I2
I4
I8
tp1024
sg22
I0
sg20
F3.0765499620029004
sVY
I2
sVX
I3
sg983
g988
sg31
g32
sg33
g34
sg21
Nsg19
S'space'
p1025
sg30
g11
sg986
I8
sg987
g1017
sg989
I8
sS'block.thisIndex'
p1026
I12
sg991
g994
sg993
g992
sg995
VUBUUxy
p1027
sa(dp1028
S'block.thisTrialN'
p1029
I4
sS'block.thisRepN'
p1030
I0
sg29
NsS'block.thisN'
p1031
I4
sg978
(S'THIRD'
S'DOUBLE'
S'ADD'
S'DECREASE'
S'x'
S'y'
tp1032
sg27
g28
sg980
I4
sg981
(I5
I12
I24
I8
tp1033
sg22
I1
sg20
F7.6122807085048407
sg23
F4.980151821160689
sVY
I7
sVX
I6
sg983
g1017
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1034
sg30
g11
sg986
I8
sg987
g994
sg989
I8
sS'block.thisIndex'
p1035
I14
sg991
g992
sg993
g1014
sg995
g996
sa(dp1036
S'block.thisTrialN'
p1037
I5
sS'block.thisRepN'
p1038
I0
sg29
NsS'block.thisN'
p1039
I5
sg978
(S'DECREASE'
S'DIVIDE'
S'x'
S'y'
tp1040
sg27
g28
sg980
I2
sg981
(I2
I1
tp1041
sg22
I1
sg20
F2.382259161255206
sg23
F2.7965074344538152
sVY
I4
sVX
I8
sg983
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1042
sg30
g11
sg986
I1
sg987
g984
sg989
I1
sS'block.thisIndex'
p1043
I2
sg991
g1014
sg993
I0
sg995
VUBxy
p1044
sa(dp1045
S'block.thisTrialN'
p1046
I6
sS'block.thisRepN'
p1047
I0
sg29
NsS'block.thisN'
p1048
I6
sg978
(S'SUBTRACT'
S'DECREASE'
S'TRIPLE'
S'DOUBLE'
S'x'
S'y'
tp1049
sg27
g28
sg980
I4
sg981
(I6
I18
I17
I8
tp1050
sg22
I0
sg20
F4.2707327990356134
sg23
F14.598532393138157
sVY
I9
sVX
I3
sg983
Vtriple
p1051
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1052
sg30
g11
sg986
I8
sg987
g1014
sg989
I8
sS'block.thisIndex'
p1053
I11
sg991
g1005
sg993
g994
sg995
g1018
sa(dp1054
S'block.thisTrialN'
p1055
I7
sS'block.thisRepN'
p1056
I0
sg29
NsS'block.thisN'
p1057
I7
sg978
(S'DIVIDE'
S'DECREASE'
S'TRIPLE'
S'x'
S'y'
tp1058
sg27
g28
sg980
I3
sg981
(I9
I8
I4
tp1059
sg22
I1
sg20
F10.954161433255649
sg23
F14.506979846657487
sVY
I2
sVX
I3
sg983
g1051
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1060
sg30
g11
sg986
I4
sg987
g1014
sg989
I4
sS'block.thisIndex'
p1061
I5
sg991
g984
sg993
I0
sg995
VBUUxy
p1062
sa(dp1063
S'block.thisTrialN'
p1064
I8
sS'block.thisRepN'
p1065
I0
sg29
NsS'block.thisN'
p1066
I8
sg978
(S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp1067
sg27
g28
sg980
I2
sg981
(I5
I3
tp1068
sg22
I0
sg20
F1.2549417468253523
sg23
F4.5907495552819455
sVY
I2
sVX
I6
sg983
I0
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1069
sg30
g11
sg986
I3
sg987
g1014
sg989
I3
sS'block.thisIndex'
p1070
I1
sg991
g1005
sg993
I0
sg995
VBUxy
p1071
sa(dp1072
S'block.thisTrialN'
p1073
I9
sS'block.thisRepN'
p1074
I0
sg29
NsS'block.thisN'
p1075
I9
sg978
(S'THIRD'
S'DOUBLE'
S'INCREASE'
S'TIMES'
S'x'
S'y'
tp1076
sg27
g28
sg980
I4
sg981
(I8
I9
I18
I6
tp1077
sg22
I0
sg20
F3.8758249076781794
sg23
F10.680270913726417
sVY
I4
sVX
I2
sg983
g988
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1078
sg30
g11
sg986
I6
sg987
g994
sg989
I6
sS'block.thisIndex'
p1079
I17
sg991
g992
sg993
VTIMES
p1080
sg995
VUUUBxy
p1081
sa(dp1082
S'block.thisTrialN'
p1083
I10
sS'block.thisRepN'
p1084
I0
sg29
NsS'block.thisN'
p1085
I10
sg978
(S'ADD'
S'HALF'
S'THIRD'
S'x'
S'y'
tp1086
sg27
g28
sg980
I3
sg981
(I2
I1
I9
tp1087
sg22
I1
sg20
F1.7796003487019334
sg23
F7.5504957057710271
sVY
I8
sVX
I6
sg983
g992
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1088
sg30
g11
sg986
I9
sg987
g1003
sg989
I9
sS'block.thisIndex'
p1089
I4
sg991
g1017
sg993
I0
sg995
g1062
sa(dp1090
S'block.thisTrialN'
p1091
I11
sS'block.thisRepN'
p1092
I0
sg29
NsS'block.thisN'
p1093
I11
sg978
(S'HALF'
S'TRIPLE'
S'INCREASE'
S'DIVIDE'
S'x'
S'y'
tp1094
sg27
g28
sg980
I4
sg981
(I3
I4
I12
I6
tp1095
sg22
I0
sg20
F9.6560709390032571
sg23
F6.0282840485597262
sVY
I3
sVX
I9
sg983
g988
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1096
sg30
g11
sg986
I6
sg987
g1051
sg989
I6
sS'block.thisIndex'
p1097
I16
sg991
g1003
sg993
g984
sg995
g1081
sa(dp1098
S'block.thisTrialN'
p1099
I12
sS'block.thisRepN'
p1100
I0
sg29
NsS'block.thisN'
p1101
I12
sg978
(S'INCREASE'
S'ADD'
S'x'
S'y'
tp1102
sg27
g28
sg980
I2
sg981
(I5
I6
tp1103
sg22
I1
sg20
F0.82040084117033985
sg23
F2.9832829444349045
sVY
I2
sVX
I3
sg983
I0
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1104
sg30
g11
sg986
I6
sg987
g1017
sg989
I6
sS'block.thisIndex'
p1105
I3
sg991
g988
sg993
I0
sg995
g1044
sa(dp1106
S'block.thisTrialN'
p1107
I13
sS'block.thisRepN'
p1108
I0
sg29
NsS'block.thisN'
p1109
I13
sg978
(S'THIRD'
S'HALF'
S'ADD'
S'x'
S'y'
tp1110
sg27
g28
sg980
I3
sg981
(I6
I3
I1
tp1111
sg22
I1
sg20
F1.674259591018199
sg23
F6.9325893343047937
sVY
I3
sVX
I3
sg983
g1017
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1112
sg30
g11
sg986
I1
sg987
g1003
sg989
I1
sS'block.thisIndex'
p1113
I9
sg991
g992
sg993
I0
sg995
VUUBxy
p1114
sa(dp1115
S'block.thisTrialN'
p1116
I14
sS'block.thisRepN'
p1117
I0
sg29
NsS'block.thisN'
p1118
I14
sg978
(S'DIVIDE'
S'INCREASE'
S'x'
S'y'
tp1119
sg27
g28
sg980
I2
sg981
(I4
I2
tp1120
sg22
I0
sg20
F1.262345574243227
sg23
F2.678848312178161
sVY
I2
sVX
I3
sg983
I0
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1121
sg30
g11
sg986
I2
sg987
g988
sg989
I2
sS'block.thisIndex'
p1122
I0
sg991
g984
sg993
I0
sg995
g1071
sa(dp1123
S'block.thisTrialN'
p1124
I15
sS'block.thisRepN'
p1125
I0
sg29
NsS'block.thisN'
p1126
I15
sg978
(S'INCREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp1127
sg27
g28
sg980
I3
sg981
(I2
I6
I7
tp1128
sg22
I1
sg20
F2.6683413585851667
sg23
F4.6924772899947129
sVY
I3
sVX
I6
sg983
g984
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p1129
sg30
g11
sg986
I7
sg987
g1051
sg989
I7
sS'block.thisIndex'
p1130
I8
sg991
g988
sg993
I0
sg995
g1114
sa(dp1131
S'block.thisTrialN'
p1132
I16
sS'block.thisRepN'
p1133
I0
sg29
NsS'block.thisN'
p1134
I16
sg978
(S'HALF'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp1135
sg27
g28
sg980
I3
sg981
(I9
I12
I6
tp1136
sg22
I1
sg20
F2.2951081054634415
sg23
F4.6658671167679131
sVY
I3
sVX
I3
sg983
g1051
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1137
sg30
g11
sg986
I6
sg987
g1017
sg989
I6
sS'block.thisIndex'
p1138
I6
sg991
g1003
sg993
I0
sg995
g1007
sa(dp1139
S'block.thisTrialN'
p1140
I17
sS'block.thisRepN'
p1141
I0
sg29
NsS'block.thisN'
p1142
I17
sg978
(S'THIRD'
S'TIMES'
S'DOUBLE'
S'DECREASE'
S'x'
S'y'
tp1143
sg27
g28
sg980
I4
sg981
(I1
I2
I6
I2
tp1144
sg22
I0
sg20
F1.662259693199303
sg23
F6.442797944022459
sVY
I3
sVX
I2
sg983
g994
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1145
sg30
g11
sg986
I2
sg987
g1080
sg989
I2
sS'block.thisIndex'
p1146
I13
sg991
g992
sg993
g1014
sg995
g1027
sa(dp1147
S'block.thisTrialN'
p1148
I0
sS'block.thisRepN'
p1149
I0
sg29
NsS'block.thisN'
p1150
I0
sVRule
p1151
(S'INCREASE'
S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp1152
sg27
g28
sVLength
p1153
I4
sVIntermediate
p1154
(I2
I6
I2
I3
tp1155
sg22
I0
sg20
F2.4185916699643712
sg23
F7.4050869291822892
sVY
I3
sVX
I4
sVOperatorc
p1156
Vtriple
p1157
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1158
sg30
g11
sVResult
p1159
I3
sVOperatora
p1160
VDIVIDE
p1161
sVCorrectResponse
p1162
I3
sS'block.thisIndex'
p1163
I12
sVOperatorb
p1164
Vincrease
p1165
sVOperatord
p1166
Vhalf
p1167
sVStructure
p1168
VUBUUxy
p1169
sa(dp1170
S'block.thisTrialN'
p1171
I1
sS'block.thisRepN'
p1172
I0
sg29
NsS'block.thisN'
p1173
I1
sg1151
(S'DIVIDE'
S'TRIPLE'
S'HALF'
S'x'
S'y'
tp1174
sg27
g28
sg1153
I3
sg1154
(I4
I12
I4
tp1175
sg22
I1
sg20
F1.0094007190346019
sg23
F5.9112247636949178
sVY
I3
sVX
I8
sg1156
g1167
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1176
sg30
g11
sg1159
I4
sg1160
g1157
sg1162
I4
sS'block.thisIndex'
p1177
I4
sg1164
g1161
sg1166
I0
sg1168
VBUUxy
p1178
sa(dp1179
S'block.thisTrialN'
p1180
I2
sS'block.thisRepN'
p1181
I0
sg29
NsS'block.thisN'
p1182
I2
sg1151
(S'THIRD'
S'TIMES'
S'HALF'
S'INCREASE'
S'x'
S'y'
tp1183
sg27
g28
sg1153
I4
sg1154
(I8
I4
I12
I4
tp1184
sg22
I0
sg20
F1.788418028576416
sg23
F8.0182040504005272
sVY
I3
sVX
I7
sg1156
g1167
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p1185
sg30
g11
sg1159
I4
sg1160
VTIMES
p1186
sg1162
I4
sS'block.thisIndex'
p1187
I13
sg1164
Vthird
p1188
sg1166
g1165
sg1168
g1169
sa(dp1189
S'block.thisTrialN'
p1190
I3
sS'block.thisRepN'
p1191
I0
sg29
NsS'block.thisN'
p1192
I3
sg1151
(S'DIVIDE'
S'DOUBLE'
S'INCREASE'
S'THIRD'
S'x'
S'y'
tp1193
sg27
g28
sg1153
I4
sg1154
(I2
I3
I6
I2
tp1194
sg22
I1
sg20
F2.0992769404547289
sg23
F12.865716212501866
sVY
I3
sVX
I6
sg1156
g1165
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1195
sg30
g11
sg1159
I2
sg1160
Vdouble
p1196
sg1162
I2
sS'block.thisIndex'
p1197
I10
sg1164
g1161
sg1166
g1188
sg1168
VBUUUxy
p1198
sa(dp1199
S'block.thisTrialN'
p1200
I4
sS'block.thisRepN'
p1201
I0
sg29
NsS'block.thisN'
p1202
I4
sg1151
(S'THIRD'
S'INCREASE'
S'ADD'
S'DOUBLE'
S'x'
S'y'
tp1203
sg27
g28
sg1153
I4
sg1154
(I16
I20
I21
I7
tp1204
sg22
I0
sg20
F1.951819127672934
sg23
F7.2530130980885588
sVY
I4
sVX
I8
sg1156
VADD
p1205
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1206
sg30
g11
sg1159
I7
sg1160
g1165
sg1162
I7
sS'block.thisIndex'
p1207
I14
sg1164
g1188
sg1166
g1196
sg1168
VUUBUxy
p1208
sa(dp1209
S'block.thisTrialN'
p1210
I5
sS'block.thisRepN'
p1211
I0
sg29
NsS'block.thisN'
p1212
I5
sg1151
(S'THIRD'
S'INCREASE'
S'SUBTRACT'
S'x'
S'y'
tp1213
sg27
g28
sg1153
I3
sg1154
(I2
I3
I1
tp1214
sg22
I1
sg20
F1.3201861385896336
sg23
F4.5264997597405454
sVY
I6
sVX
I8
sg1156
VSUBTRACT
p1215
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1216
sg30
g11
sg1159
I1
sg1160
g1165
sg1162
I1
sS'block.thisIndex'
p1217
I9
sg1164
g1188
sg1166
I0
sg1168
VUUBxy
p1218
sa(dp1219
S'block.thisTrialN'
p1220
I6
sS'block.thisRepN'
p1221
I0
sg29
NsS'block.thisN'
p1222
I6
sg1151
(S'ADD'
S'THIRD'
S'x'
S'y'
tp1223
sg27
g28
sg1153
I2
sg1154
(I1
I7
tp1224
sg22
I0
sg20
F1.2371667516417801
sg23
F3.8221660569834057
sVY
I6
sVX
I3
sg1156
I0
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1225
sg30
g11
sg1159
I7
sg1160
g1188
sg1162
I7
sS'block.thisIndex'
p1226
I0
sg1164
g1205
sg1166
I0
sg1168
VBUxy
p1227
sa(dp1228
S'block.thisTrialN'
p1229
I7
sS'block.thisRepN'
p1230
I0
sg29
NsS'block.thisN'
p1231
I7
sg1151
(S'DECREASE'
S'TRIPLE'
S'HALF'
S'ADD'
S'x'
S'y'
tp1232
sg27
g28
sg1153
I4
sg1154
(I6
I3
I9
I8
tp1233
sg22
I0
sg20
F1.3739499783259816
sg23
F9.8215994661004515
sVY
I2
sVX
I4
sg1156
g1167
sg31
g32
sg33
g34
sg21
S'7'
sg19
S'space'
p1234
sg30
g11
sg1159
I8
sg1160
g1157
sg1162
I8
sS'block.thisIndex'
p1235
I16
sg1164
Vdecrease
p1236
sg1166
g1205
sg1168
VUUUBxy
p1237
sa(dp1238
S'block.thisTrialN'
p1239
I8
sS'block.thisRepN'
p1240
I0
sg29
NsS'block.thisN'
p1241
I8
sg1151
(S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp1242
sg27
g28
sg1153
I3
sg1154
(I2
I6
I5
tp1243
sg22
I1
sg20
F1.3959773797541857
sg23
F4.1354792627389543
sVY
I4
sVX
I8
sg1156
g1161
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1244
sg30
g11
sg1159
I5
sg1160
g1157
sg1162
I5
sS'block.thisIndex'
p1245
I8
sg1164
g1236
sg1166
I0
sg1168
g1218
sa(dp1246
S'block.thisTrialN'
p1247
I9
sS'block.thisRepN'
p1248
I0
sg29
NsS'block.thisN'
p1249
I9
sg1151
(S'DOUBLE'
S'ADD'
S'x'
S'y'
tp1250
sg27
g28
sg1153
I2
sg1154
(I4
I8
tp1251
sg22
I1
sg20
F1.1782906453736359
sg23
F1.7980273258581292
sVY
I2
sVX
I2
sg1156
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1252
sg30
g11
sg1159
I8
sg1160
g1205
sg1162
I8
sS'block.thisIndex'
p1253
I2
sg1164
g1196
sg1166
I0
sg1168
VUBxy
p1254
sa(dp1255
S'block.thisTrialN'
p1256
I10
sS'block.thisRepN'
p1257
I0
sg29
NsS'block.thisN'
p1258
I10
sg1151
(S'INCREASE'
S'SUBTRACT'
S'THIRD'
S'x'
S'y'
tp1259
sg27
g28
sg1153
I3
sg1154
(I3
I1
I2
tp1260
sg22
I1
sg20
F1.5835259590676287
sg23
F4.5568916383490432
sVY
I2
sVX
I9
sg1156
g1188
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1261
sg30
g11
sg1159
I2
sg1160
g1215
sg1162
I2
sS'block.thisIndex'
p1262
I7
sg1164
g1165
sg1166
I0
sg1168
VUBUxy
p1263
sa(dp1264
S'block.thisTrialN'
p1265
I11
sS'block.thisRepN'
p1266
I0
sg29
NsS'block.thisN'
p1267
I11
sg1151
(S'TRIPLE'
S'DECREASE'
S'HALF'
S'SUBTRACT'
S'x'
S'y'
tp1268
sg27
g28
sg1153
I4
sg1154
(I4
I2
I1
I3
tp1269
sg22
I0
sg20
F1.6721374124608701
sg23
F8.6555788903497159
sVY
I5
sVX
I9
sg1156
g1167
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1270
sg30
g11
sg1159
I3
sg1160
g1236
sg1162
I3
sS'block.thisIndex'
p1271
I17
sg1164
g1157
sg1166
g1215
sg1168
g1237
sa(dp1272
S'block.thisTrialN'
p1273
I12
sS'block.thisRepN'
p1274
I0
sg29
NsS'block.thisN'
p1275
I12
sg1151
(S'TRIPLE'
S'DOUBLE'
S'SUBTRACT'
S'DECREASE'
S'x'
S'y'
tp1276
sg27
g28
sg1153
I4
sg1154
(I4
I1
I2
I6
tp1277
sg22
I0
sg20
F4.2880552914284635
sg23
F9.4486167868308257
sVY
I3
sVX
I5
sg1156
g1215
sg31
g32
sg33
g34
sg21
S'9'
sg19
S'space'
p1278
sg30
g11
sg1159
I6
sg1160
g1196
sg1162
I6
sS'block.thisIndex'
p1279
I15
sg1164
g1157
sg1166
g1236
sg1168
g1208
sa(dp1280
S'block.thisTrialN'
p1281
I13
sS'block.thisRepN'
p1282
I0
sg29
NsS'block.thisN'
p1283
I13
sg1151
(S'SUBTRACT'
S'INCREASE'
S'x'
S'y'
tp1284
sg27
g28
sg1153
I2
sg1154
(I6
I2
tp1285
sg22
I1
sg20
F1.1646438194147777
sg23
F6.1090759179205634
sVY
I4
sVX
I5
sg1156
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1286
sg30
g11
sg1159
I2
sg1160
g1165
sg1162
I2
sS'block.thisIndex'
p1287
I1
sg1164
g1215
sg1166
I0
sg1168
g1227
sa(dp1288
S'block.thisTrialN'
p1289
I14
sS'block.thisRepN'
p1290
I0
sg29
NsS'block.thisN'
p1291
I14
sg1151
(S'TIMES'
S'INCREASE'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp1292
sg27
g28
sg1153
I4
sg1154
(I6
I3
I4
I8
tp1293
sg22
I0
sg20
F3.137931456847582
sg23
F6.9063322742149467
sVY
I2
sVX
I2
sg1156
g1167
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1294
sg30
g11
sg1159
I8
sg1160
g1165
sg1162
I8
sS'block.thisIndex'
p1295
I11
sg1164
g1186
sg1166
g1157
sg1168
g1198
sa(dp1296
S'block.thisTrialN'
p1297
I15
sS'block.thisRepN'
p1298
I0
sg29
NsS'block.thisN'
p1299
I15
sg1151
(S'INCREASE'
S'ADD'
S'TRIPLE'
S'x'
S'y'
tp1300
sg27
g28
sg1153
I3
sg1154
(I6
I8
I9
tp1301
sg22
I0
sg20
F7.6783972092380282
sg23
F8.1258272699342342
sVY
I2
sVX
I2
sg1156
g1157
sg31
g32
sg33
g34
sg21
S'6'
sg19
S'space'
p1302
sg30
g11
sg1159
I9
sg1160
g1205
sg1162
I9
sS'block.thisIndex'
p1303
I6
sg1164
g1165
sg1166
I0
sg1168
g1263
sa(dp1304
S'block.thisTrialN'
p1305
I16
sS'block.thisRepN'
p1306
I0
sg29
NsS'block.thisN'
p1307
I16
sg1151
(S'TIMES'
S'THIRD'
S'DOUBLE'
S'x'
S'y'
tp1308
sg27
g28
sg1153
I3
sg1154
(I6
I2
I4
tp1309
sg22
I1
sg20
F1.6261592102819122
sg23
F11.894527306081727
sVY
I2
sVX
I3
sg1156
g1196
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1310
sg30
g11
sg1159
I4
sg1160
g1188
sg1162
I4
sS'block.thisIndex'
p1311
I5
sg1164
g1186
sg1166
I0
sg1168
g1178
sa(dp1312
S'block.thisTrialN'
p1313
I17
sS'block.thisRepN'
p1314
I0
sg29
NsS'block.thisN'
p1315
I17
sg1151
(S'DOUBLE'
S'TIMES'
S'x'
S'y'
tp1316
sg27
g28
sg1153
I2
sg1154
(I4
I8
tp1317
sg22
I1
sg20
F0.91436988550412934
sg23
F1.8936999924044358
sVY
I2
sVX
I2
sg1156
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1318
sg30
g11
sg1159
I8
sg1160
g1186
sg1162
I8
sS'block.thisIndex'
p1319
I3
sg1164
g1196
sg1166
I0
sg1168
g1254
sa(dp1320
S'block.thisTrialN'
p1321
I0
sS'block.thisRepN'
p1322
I0
sg29
NsS'block.thisN'
p1323
I0
sVRule
p1324
(S'INCREASE'
S'DIVIDE'
S'THIRD'
S'x'
S'y'
tp1325
sg27
g28
sVLength
p1326
I3
sVIntermediate
p1327
(I3
I1
I2
tp1328
sg22
I1
sg20
F2.123139550385531
sg23
F6.1894667291489895
sVY
I3
sVX
I9
sVOperatorc
p1329
Vthird
p1330
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1331
sg30
g11
sVResult
p1332
I2
sVOperatora
p1333
VDIVIDE
p1334
sVCorrectResponse
p1335
I2
sS'block.thisIndex'
p1336
I7
sVOperatorb
p1337
Vincrease
p1338
sVOperatord
p1339
I0
sVStructure
p1340
VUBUxy
p1341
sa(dp1342
S'block.thisTrialN'
p1343
I1
sS'block.thisRepN'
p1344
I0
sg29
NsS'block.thisN'
p1345
I1
sg1324
(S'DIVIDE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp1346
sg27
g28
sg1326
I3
sg1327
(I2
I4
I1
tp1347
sg22
I1
sg20
F1.157663447826053
sg23
F7.6655710476625245
sVY
I4
sVX
I6
sg1329
g1330
sg31
g32
sg33
g34
sg21
S'1'
sg19
S'space'
p1348
sg30
g11
sg1332
I1
sg1333
Vdouble
p1349
sg1335
I1
sS'block.thisIndex'
p1350
I4
sg1337
g1334
sg1339
I0
sg1340
VBUUxy
p1351
sa(dp1352
S'block.thisTrialN'
p1353
I2
sS'block.thisRepN'
p1354
I0
sg29
NsS'block.thisN'
p1355
I2
sg1324
(S'DECREASE'
S'TIMES'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp1356
sg27
g28
sg1326
I4
sg1327
(I1
I2
I8
I7
tp1357
sg22
I0
sg20
F2.3975287678767927
sg23
F8.0606441217823885
sVY
I4
sVX
I3
sg1329
g1349
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1358
sg30
g11
sg1332
I7
sg1333
VTIMES
p1359
sg1335
I7
sS'block.thisIndex'
p1360
I13
sg1337
Vdecrease
p1361
sg1339
g1330
sg1340
VUBUUxy
p1362
sa(dp1363
S'block.thisTrialN'
p1364
I3
sS'block.thisRepN'
p1365
I0
sg29
NsS'block.thisN'
p1366
I3
sg1324
(S'DOUBLE'
S'TRIPLE'
S'SUBTRACT'
S'x'
S'y'
tp1367
sg27
g28
sg1326
I3
sg1327
(I1
I3
I6
tp1368
sg22
I0
sg20
F1.4950418923835969
sg23
F4.353728738395148
sVY
I3
sVX
I4
sg1329
VSUBTRACT
p1369
sg31
g32
sg33
g34
sg21
S'3'
sg19
S'space'
p1370
sg30
g11
sg1332
I6
sg1333
Vtriple
p1371
sg1335
I6
sS'block.thisIndex'
p1372
I9
sg1337
g1349
sg1339
I0
sg1340
VUUBxy
p1373
sa(dp1374
S'block.thisTrialN'
p1375
I4
sS'block.thisRepN'
p1376
I0
sg29
NsS'block.thisN'
p1377
I4
sg1324
(S'DOUBLE'
S'SUBTRACT'
S'x'
S'y'
tp1378
sg27
g28
sg1326
I2
sg1327
(I1
I2
tp1379
sg22
I1
sg20
F1.8930858064995846
sg23
F1.1926590960210888
sVY
I7
sVX
I8
sg1329
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1380
sg30
g11
sg1332
I2
sg1333
g1369
sg1335
I2
sS'block.thisIndex'
p1381
I2
sg1337
g1349
sg1339
I0
sg1340
VUBxy
p1382
sa(dp1383
S'block.thisTrialN'
p1384
I5
sS'block.thisRepN'
p1385
I0
sg29
NsS'block.thisN'
p1386
I5
sg1324
(S'DECREASE'
S'THIRD'
S'TIMES'
S'HALF'
S'x'
S'y'
tp1387
sg27
g28
sg1326
I4
sg1327
(I2
I12
I4
I3
tp1388
sg22
I0
sg20
F1.847983562911395
sg23
F10.338270151507459
sVY
I6
sVX
I4
sg1329
g1359
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1389
sg30
g11
sg1332
I3
sg1333
g1330
sg1335
I3
sS'block.thisIndex'
p1390
I14
sg1337
g1361
sg1339
Vhalf
p1391
sg1340
VUUBUxy
p1392
sa(dp1393
S'block.thisTrialN'
p1394
I6
sS'block.thisRepN'
p1395
I0
sg29
NsS'block.thisN'
p1396
I6
sg1324
(S'DOUBLE'
S'DECREASE'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp1397
sg27
g28
sg1326
I4
sg1327
(I1
I3
I2
I4
tp1398
sg22
I0
sg20
F5.1058034094021423
sg23
F4.7567771303001791
sVY
I4
sVX
I4
sg1329
g1371
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1399
sg30
g11
sg1332
I4
sg1333
g1361
sg1335
I4
sS'block.thisIndex'
p1400
I17
sg1337
g1349
sg1339
g1334
sg1340
VUUUBxy
p1401
sa(dp1402
S'block.thisTrialN'
p1403
I7
sS'block.thisRepN'
p1404
I0
sg29
NsS'block.thisN'
p1405
I7
sg1324
(S'DECREASE'
S'HALF'
S'TRIPLE'
S'DIVIDE'
S'x'
S'y'
tp1406
sg27
g28
sg1326
I4
sg1327
(I4
I12
I6
I5
tp1407
sg22
I1
sg20
F7.0795452994498191
sg23
F7.8654204933700385
sVY
I2
sVX
I8
sg1329
g1371
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1408
sg30
g11
sg1332
I5
sg1333
g1391
sg1335
I5
sS'block.thisIndex'
p1409
I16
sg1337
g1361
sg1339
g1334
sg1340
g1401
sa(dp1410
S'block.thisTrialN'
p1411
I8
sS'block.thisRepN'
p1412
I0
sg29
NsS'block.thisN'
p1413
I8
sg1324
(S'DOUBLE'
S'TRIPLE'
S'DIVIDE'
S'DECREASE'
S'x'
S'y'
tp1414
sg27
g28
sg1326
I4
sg1327
(I8
I1
I3
I6
tp1415
sg22
I0
sg20
F1.8332116043602582
sg23
F18.494720275935833
sVY
I8
sVX
I9
sg1329
g1334
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1416
sg30
g11
sg1332
I6
sg1333
g1371
sg1335
I6
sS'block.thisIndex'
p1417
I15
sg1337
g1349
sg1339
g1361
sg1340
g1392
sa(dp1418
S'block.thisTrialN'
p1419
I9
sS'block.thisRepN'
p1420
I0
sg29
NsS'block.thisN'
p1421
I9
sg1324
(S'HALF'
S'SUBTRACT'
S'TRIPLE'
S'x'
S'y'
tp1422
sg27
g28
sg1326
I3
sg1327
(I9
I2
I1
tp1423
sg22
I0
sg20
F3.609155184662086
sVY
I7
sVX
I3
sg1329
g1371
sg31
g32
sg33
g34
sg21
Nsg19
S'space'
p1424
sg30
g11
sg1332
I1
sg1333
g1369
sg1335
I1
sS'block.thisIndex'
p1425
I6
sg1337
g1391
sg1339
I0
sg1340
g1341
sa(dp1426
S'block.thisTrialN'
p1427
I10
sS'block.thisRepN'
p1428
I0
sg29
NsS'block.thisN'
p1429
I10
sg1324
(S'ADD'
S'THIRD'
S'INCREASE'
S'HALF'
S'x'
S'y'
tp1430
sg27
g28
sg1326
I4
sg1327
(I2
I3
I1
I7
tp1431
sg22
I0
sg20
F1.8360561075533042
sg23
F8.061312202073168
sVY
I6
sVX
I4
sg1329
g1338
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1432
sg30
g11
sg1332
I7
sg1333
g1330
sg1335
I7
sS'block.thisIndex'
p1433
I10
sg1337
VADD
p1434
sg1339
g1391
sg1340
VBUUUxy
p1435
sa(dp1436
S'block.thisTrialN'
p1437
I11
sS'block.thisRepN'
p1438
I0
sg29
NsS'block.thisN'
p1439
I11
sg1324
(S'HALF'
S'TIMES'
S'x'
S'y'
tp1440
sg27
g28
sg1326
I2
sg1327
(I16
I8
tp1441
sg22
I1
sg20
F1.3000292919459753
sg23
F3.1755525311018573
sVY
I4
sVX
I4
sg1329
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1442
sg30
g11
sg1332
I8
sg1333
g1359
sg1335
I8
sS'block.thisIndex'
p1443
I3
sg1337
g1391
sg1339
I0
sg1340
g1382
sa(dp1444
S'block.thisTrialN'
p1445
I12
sS'block.thisRepN'
p1446
I0
sg29
NsS'block.thisN'
p1447
I12
sg1324
(S'DOUBLE'
S'DECREASE'
S'SUBTRACT'
S'x'
S'y'
tp1448
sg27
g28
sg1326
I3
sg1327
(I5
I4
I8
tp1449
sg22
I1
sg20
F1.4591821843350772
sg23
F11.659715108718956
sVY
I2
sVX
I7
sg1329
g1369
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1450
sg30
g11
sg1332
I8
sg1333
g1361
sg1335
I8
sS'block.thisIndex'
p1451
I8
sg1337
g1349
sg1339
I0
sg1340
g1373
sa(dp1452
S'block.thisTrialN'
p1453
I13
sS'block.thisRepN'
p1454
I0
sg29
NsS'block.thisN'
p1455
I13
sg1324
(S'SUBTRACT'
S'HALF'
S'TRIPLE'
S'x'
S'y'
tp1456
sg27
g28
sg1326
I3
sg1327
(I12
I6
I2
tp1457
sg22
I1
sg20
F4.2088186597684398
sg23
F4.394363698142115
sVY
I4
sVX
I4
sg1329
g1371
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1458
sg30
g11
sg1332
I2
sg1333
g1391
sg1335
I2
sS'block.thisIndex'
p1459
I5
sg1337
g1369
sg1339
I0
sg1340
g1351
sa(dp1460
S'block.thisTrialN'
p1461
I14
sS'block.thisRepN'
p1462
I0
sg29
NsS'block.thisN'
p1463
I14
sg1324
(S'DIVIDE'
S'INCREASE'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp1464
sg27
g28
sg1326
I4
sg1327
(I2
I4
I5
I1
tp1465
sg22
I0
sg20
F2.9373488376440946
sg23
F16.699397467877134
sVY
I5
sVX
I6
sg1329
g1349
sg31
g32
sg33
g34
sg21
S'5'
sg19
S'space'
p1466
sg30
g11
sg1332
I1
sg1333
g1338
sg1335
I1
sS'block.thisIndex'
p1467
I11
sg1337
g1334
sg1339
g1330
sg1340
g1435
sa(dp1468
S'block.thisTrialN'
p1469
I15
sS'block.thisRepN'
p1470
I0
sg29
NsS'block.thisN'
p1471
I15
sg1324
(S'DECREASE'
S'ADD'
S'DOUBLE'
S'THIRD'
S'x'
S'y'
tp1472
sg27
g28
sg1326
I4
sg1327
(I3
I6
I10
I9
tp1473
sg22
I0
sg20
F3.2052294343011454
sg23
F9.701131536916364
sVY
I4
sVX
I9
sg1329
g1349
sg31
g32
sg33
g34
sg21
S'4'
sg19
S'space'
p1474
sg30
g11
sg1332
I9
sg1333
g1434
sg1335
I9
sS'block.thisIndex'
p1475
I12
sg1337
Vdecrease 
p1476
sg1339
g1330
sg1340
g1362
sa(dp1477
S'block.thisTrialN'
p1478
I16
sS'block.thisRepN'
p1479
I0
sg29
NsS'block.thisN'
p1480
I16
sg1324
(S'DIVIDE'
S'DOUBLE'
S'x'
S'y'
tp1481
sg27
g28
sg1326
I2
sg1327
(I12
I2
tp1482
sg22
I1
sg20
F0.67225814987614285
sg23
F2.227411169646075
sVY
I6
sVX
I6
sg1329
I0
sg31
g32
sg33
g34
sg21
S'2'
sg19
S'space'
p1483
sg30
g11
sg1332
I2
sg1333
g1349
sg1335
I2
sS'block.thisIndex'
p1484
I1
sg1337
g1334
sg1339
I0
sg1340
VBUxy
p1485
sa(dp1486
S'block.thisTrialN'
p1487
I17
sS'block.thisRepN'
p1488
I0
sg29
NsS'block.thisN'
p1489
I17
sg1324
(S'ADD'
S'DOUBLE'
S'x'
S'y'
tp1490
sg27
g28
sg1326
I2
sg1327
(I4
I8
tp1491
sg22
I1
sg20
F1.704127224322292
sg23
F3.275830367099843
sVY
I4
sVX
I2
sg1329
I0
sg31
g32
sg33
g34
sg21
S'8'
sg19
S'space'
p1492
sg30
g11
sg1332
I8
sg1333
g1349
sg1335
I8
sS'block.thisIndex'
p1493
I0
sg1337
g1434
sg1339
I0
sg1340
g1485
sasS'loops'
p1494
(lp1495
g1
(cpsychopy.data
TrialHandler
p1496
g3
NtRp1497
(dp1498
S'origin'
p1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1500
sS'thisTrial'
p1501
(lp1502
sS'_exp'
p1503
I73766480
sg10
S'practice_trials'
p1504
sg6
S'C:\\Users\\experimenter\\Desktop\\Experiments\\KRITL\\kritl_experimenter.py'
p1505
sS'thisRepN'
p1506
I1
sg24
I01
sg25
g26
sS'data'
p1507
g1
(cpsychopy.data
DataHandler
p1508
c__builtin__
dict
p1509
(dp1510
g15
cnumpy.ma.core
_mareconstruct
p1511
(cnumpy.ma.core
MaskedArray
p1512
cnumpy
ndarray
p1513
(I0
tp1514
S'b'
tRp1515
(I1
(I6
I1
tcnumpy
dtype
p1516
(S'O4'
I0
I1
tRp1517
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'\x98\x0b\x17\x04\xa03\x16\x04\x08\xda\x18\x04\xc8\xd3\x19\x04\x10l\x16\x04\xb8n\x17\x04'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg16
g1511
(g1512
g1513
g1514
S'b'
tRp1518
(I1
(I6
I1
tg1517
I00
S'x\x02s\x01\xcc\x18\x1f\x1e\x08\x03s\x01`r\x86\x01\xc0\x02s\x01\xf0\xe8.\x01'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'ran'
p1519
g1511
(g1512
g1513
g1514
S'b'
tRp1520
(I1
(I6
I1
tg1516
(S'f4'
I0
I1
tRp1521
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg18
g1511
(g1512
g1513
g1514
S'b'
tRp1522
(I1
(I6
I1
tg1521
I00
S'\x02\x96k@\x00\x00\x00\x00\x99-;AS\xf8\xdf@\x13xo@\x8dh\x0bA'
S'\x00\x01\x00\x00\x00\x00'
Ntbsg14
g1511
(g1512
g1513
g1514
S'b'
tRp1523
(I1
(I6
I1
tg1517
I00
S'x\r\x17\x04\x986\x16\x04(x\x18\x04\xe8\xdb\x19\x04@Y\xe7\x03`\xdc\x17\x04'
S'\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1524
g1511
(g1512
g1513
g1514
S'b'
tRp1525
(I1
(I6
I1
tg1521
I00
S'\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x80@\x00\x00\xa0@\x00\x00\x80?\x00\x00@@'
S'\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1511
(g1512
g1513
g1514
S'b'
tRp1526
(I1
(I6
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00'
NtbstRp1527
(dp1528
S'isNumeric'
p1529
(dp1530
g16
I00
sg1519
I01
sg18
I01
sg14
I00
sg17
I01
sg1524
I01
sg15
I00
ssS'trials'
p1531
g1497
sS'dataTypes'
p1532
(lp1533
g1519
ag1524
ag14
ag15
ag16
ag17
ag18
asS'dataShape'
p1534
(lp1535
I6
aI1
asbsS'method'
p1536
S'fullRandom'
p1537
sS'sequenceIndices'
p1538
cnumpy.core.multiarray
_reconstruct
p1539
(g1513
(I0
tS'b'
tRp1540
(I1
(I6
I1
tg1517
I00
(lp1541
I1
aI4
aI0
aI5
aI2
aI3
atbsS'finished'
p1542
I01
sS'nReps'
p1543
I1
sS'nRemaining'
p1544
I-1
sS'trialList'
p1545
(lp1546
g1
(cpsychopy.data
TrialType
p1547
g1509
(dp1548
g43
I0
sg44
g85
sg45
g68
sg46
I7
sg49
I2
sg48
I0
sg47
I5
sg50
I3
stRp1549
ag1
(g1547
g1509
(dp1550
g43
I0
sg44
g68
sg45
g66
sg46
I8
sg49
I2
sg48
I0
sg47
I3
sg50
I3
stRp1551
ag1
(g1547
g1509
(dp1552
g43
I0
sg44
g85
sg45
g103
sg46
I7
sg49
I2
sg48
I0
sg47
I5
sg50
I4
stRp1553
ag1
(g1547
g1509
(dp1554
g43
g85
sg44
g112
sg45
g103
sg46
I8
sg49
I3
sg48
I0
sg47
I2
sg50
I4
stRp1555
ag1
(g1547
g1509
(dp1556
g43
g74
sg44
g75
sg45
g76
sg46
I3
sg49
I3
sg48
I0
sg47
I3
sg50
I2
stRp1557
ag1
(g1547
g1509
(dp1558
g43
g74
sg44
g75
sg45
g94
sg46
I9
sg49
I4
sg48
g76
sg47
I8
sg50
I8
stRp1559
asS'seed'
p1560
NsS'thisIndex'
p1561
I3
sS'thisN'
p1562
I6
sS'thisTrialN'
p1563
I0
sS'nTotal'
p1564
I6
sS'_warnUseOfNext'
p1565
I01
sbag1
(g1496
g3
NtRp1566
(dp1567
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1568
sg1501
(lp1569
sg1503
I73766480
sg10
S'block'
p1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1571
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1572
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1573
(I1
(I18
I1
tg1517
I00
S'\xa0\xec\x8f\x04\x00\x92-\x04@\x06,\x04\x80\xfb(\x04@\xe4\x8f\x04\xe0(H\x04`\xde+\x04\xe0O\x8c\x04\xc0K+\x04\xc0\xf5\x1e\x04\xe0\x99\x18\x04\x00\x02,\x04\xc0\xee\x8f\x04\xa0\xf4\x1e\x04\x00\xde\x8e\x04\x00\x13-\x04\xc0\xca\x8c\x04\x006\x17\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1574
(I1
(I18
I1
tg1521
I00
S'o"E@*\xd2"@\xa8T*@\xf0"1A\x90\xc7\xe0@\xcc\xe5\xc0@\xb9\x88\x9a@\xd2H\x15A8\xd5\x95@\xc2\x10\xe6@\x9a\x1b\xbd@\xa2\xe6\\A\xab6WA\t\x05}A *,AF&\x1aA\x113\xdb@\xdd\xc4\x08A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1575
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1576
(I1
(I18
I1
tg1517
I00
S'8\xec.\x01\xc0\x02s\x018\xec.\x01\xe8\xe7.\x01`r\x86\x01\xf0\x05|\x01\xf0\xe8.\x01\xf0\x05|\x01\xf0\xe8.\x018\xec.\x01`r\x86\x01\x08\x03s\x01`r\x86\x018\xec.\x01\xf0\xe8.\x01`r\x86\x01x\x02s\x01\xc0\x02s\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1577
(I1
(I18
I1
tg1521
I00
S'\x00\x00pA\x00\x00\x80?\x00\x00\x10A\x00\x00\x88A\x00\x000A\x00\x00\x00\x00\x00\x00\xa0@\x00\x00@@\x00\x00\xe0@\x00\x00PA\x00\x00\xc0@\x00\x00\x80A\x00\x00`A\x00\x00@A\x00\x00 A\x00\x00\x80@\x00\x00\x00@\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1578
(I1
(I18
I1
tg1521
I00
S">\xf6!@\x06\xac\x18@QM=@\xe0(\x9b?\xd2\x8en@0\xb7\x90@\xdb\xea\x81@'\x8fV@\x19w\xb2@\x16\xfa2@\xdck\xa2@\xc3\xa3\xd2@\x8c\xc39A\rQ\x9d@Q\xb6\xa1@\xd1\x82p@fU\x81@\x9a\x06W@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1579
(dp1580
g1529
(dp1581
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1566
sg1532
(lp1582
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1583
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1584
(I1
(I18
I1
tg1517
I00
(lp1585
I5
aI1
aI16
aI7
aI15
aI6
aI10
aI8
aI17
aI2
aI14
aI4
aI13
aI9
aI12
aI0
aI11
aI3
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1586
g1
(g1547
g1509
(dp1587
g51
g263
sVY
I2
sg53
I2
sg54
g264
sg55
I4
sg56
I4
sg52
g158
sVX
I3
sg57
I0
sg58
g130
sg59
I0
sg60
g141
stRp1588
ag1
(g1547
g1509
(dp1589
g51
g136
sVY
I2
sg53
I2
sg54
g137
sg55
I6
sg56
I6
sg52
g139
sVX
I2
sg57
I0
sg58
g130
sg59
I0
sg60
g141
stRp1590
ag1
(g1547
g1509
(dp1591
g51
g212
sVY
I5
sg53
I2
sg54
g213
sg55
I3
sg56
I3
sg52
g168
sVX
I4
sg57
I0
sg58
g128
sg59
I0
sg60
g216
stRp1592
ag1
(g1547
g1509
(dp1593
g51
g279
sVY
I2
sg53
I2
sg54
g280
sg55
I1
sg56
I1
sg52
g189
sVX
I5
sg57
I0
sg58
g128
sg59
I0
sg60
g216
stRp1594
ag1
(g1547
g1509
(dp1595
g51
g230
sVY
I3
sg53
I3
sg54
g231
sg55
I9
sg56
I9
sg52
g158
sVX
I8
sg57
g126
sg58
g130
sg59
I0
sg60
g131
stRp1596
ag1
(g1547
g1509
(dp1597
g51
g124
sVY
I5
sg53
I3
sg54
g125
sg55
I5
sg56
I5
sg52
g128
sVX
I6
sg57
g126
sg58
g130
sg59
I0
sg60
g131
stRp1598
ag1
(g1547
g1509
(dp1599
g51
g177
sVY
I7
sg53
I3
sg54
g178
sg55
I5
sg56
I5
sg52
g168
sVX
I7
sg57
g139
sg58
g128
sg59
I0
sg60
g161
stRp1600
ag1
(g1547
g1509
(dp1601
g51
g156
sVY
I5
sg53
I3
sg54
g157
sg55
I5
sg56
I5
sg52
g130
sVX
I4
sg57
g158
sg58
g128
sg59
I0
sg60
g161
stRp1602
ag1
(g1547
g1509
(dp1603
g51
g195
sVY
I5
sg53
I3
sg54
g196
sg55
I8
sg56
I8
sg52
g158
sVX
I5
sg57
g130
sg58
g128
sg59
I0
sg60
g199
stRp1604
ag1
(g1547
g1509
(dp1605
g51
g247
sVY
I2
sg53
I3
sg54
g248
sg55
I3
sg56
I3
sg52
g126
sVX
I4
sg57
g150
sg58
g171
sg59
I0
sg60
g199
stRp1606
ag1
(g1547
g1509
(dp1607
g51
g185
sVY
I5
sg53
I4
sg54
g186
sg55
I3
sg56
I3
sg52
g126
sVX
I5
sg57
g139
sg58
g189
sg59
g171
sg60
g190
stRp1608
ag1
(g1547
g1509
(dp1609
g51
g271
sVY
I3
sg53
I4
sg54
g272
sg55
I9
sg56
I9
sg52
g139
sVX
I3
sg57
g128
sg58
g130
sg59
g224
sg60
g190
stRp1610
ag1
(g1547
g1509
(dp1611
g51
g255
sVY
I6
sg53
I4
sg54
g256
sg55
I4
sg56
I4
sg52
g150
sVX
I3
sg57
g171
sg58
g139
sg59
g224
sg60
g242
stRp1612
ag1
(g1547
g1509
(dp1613
g51
g238
sVY
I3
sg53
I4
sg54
g239
sg55
I3
sg56
I3
sg52
g189
sVX
I3
sg57
g224
sg58
g171
sg59
g158
sg60
g242
stRp1614
ag1
(g1547
g1509
(dp1615
g51
g221
sVY
I2
sg53
I4
sg54
g222
sg55
I8
sg56
I8
sg52
g224
sVX
I9
sg57
g168
sg58
g128
sg59
g139
sg60
g172
stRp1616
ag1
(g1547
g1509
(dp1617
g51
g166
sVY
I3
sg53
I4
sg54
g167
sg55
I6
sg56
I6
sg52
g126
sVX
I2
sg57
g168
sg58
g171
sg59
g158
sg60
g172
stRp1618
ag1
(g1547
g1509
(dp1619
g51
g146
sVY
I2
sg53
I4
sg54
g147
sg55
I1
sg56
I1
sg52
g139
sVX
I8
sg57
g126
sg58
g128
sg59
g150
sg60
g151
stRp1620
ag1
(g1547
g1509
(dp1621
g51
g204
sVY
I2
sg53
I4
sg54
g205
sg55
I6
sg56
I6
sg52
g158
sVX
I3
sg57
g126
sg58
g171
sg59
g130
sg60
g151
stRp1622
asg1560
Nsg1561
I3
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1623
(dp1624
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1625
sg1501
(lp1626
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1627
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1628
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1629
(I1
(I18
I1
tg1517
I00
S'`\x9cX\x04\x00\xd2+\x04 \x98X\x04\xe0m \x04\xc0sW\x04@\xde\x8e\x04`\xcfY\x04\xc0\x93-\x04\xc0\x00\x19\x04\x00\xc3Y\x04\xa0\xee\x8f\x04\xc0>\x17\x04@\x10-\x04\x80\xd9!\x04`d \x04\xc0\x1c-\x04\x80B+\x04 \x05,\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1630
(I1
(I18
I1
tg1521
I00
S'6\x97_@\xf7\xd6]@2\xf2#@\x81{\x93@%\x8d]@\xac\xe3\x87@Q2[A\t\x06\x81A|Bh@\x95\xb6z@\xd7D\xcd@\xfd\xfc\xac@\xb8\xf4QA\x90X5A/\x17\x95@\x07n\x02A\xf3s\xd5@\xf8`"A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1631
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1632
(I1
(I18
I1
tg1517
I00
S'\xc0\x02s\x01x\x02s\x01\xf0\xe8.\x01\xc0\x02s\x01\xe8\xe7.\x01\x08\x03s\x01x\x02s\x018\xec.\x01\xc0\x02s\x01\xf0\x05|\x01`r\x86\x01\xf0\xe8.\x01 \xe9.\x01 \xe9.\x01\xf0\x05|\x01\xc0\x02s\x018\xec.\x01x\x02s\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1633
(I1
(I18
I1
tg1521
I00
S'\x00\x00`A\x00\x00\xe0@\x00\x00PA\x00\x00\x80@\x00\x00\x88A\x00\x000A\x00\x00\x80A\x00\x00\xa0@\x00\x00\x00A\x00\x00pA\x00\x00@A\x00\x00\x10A\x00\x00\x80?\x00\x00@@\x00\x00\x00@\x00\x00\xc0@\x00\x00\x00\x00\x00\x00 A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1634
(I1
(I18
I1
tg1521
I00
S'R\xab]@\x04\xacQ@B\x9ax@\xe9o\xce?\xda#5@U\xdeo@\x07\x04\r@\xce \xfe?9\xe2\xa1@b\xd5\x04@\xde\x8aa@\xd11\xe5@c;\x8d@\x07\xad\xb5@l\x0fl@\x87\x0b\xa8@\xdd\x88\xce@\xeb\xce\x14@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1635
(dp1636
g1529
(dp1637
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1623
sg1532
(lp1638
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1639
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1640
(I1
(I18
I1
tg1517
I00
(lp1641
I16
aI12
aI14
aI13
aI3
aI7
aI15
aI1
aI8
aI11
aI17
aI5
aI10
aI2
aI0
aI9
aI6
aI4
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1642
g1
(g1547
g1509
(dp1643
g287
g428
sVY
I5
sg289
I2
sg290
g429
sg298
I7
sg295
I7
sg296
g315
sVX
I3
sg292
I0
sg300
g313
sg302
I0
sg304
g372
stRp1644
ag1
(g1547
g1509
(dp1645
g287
g367
sVY
I4
sg289
I2
sg290
g368
sg298
I2
sg295
I2
sg296
g315
sVX
I9
sg292
I0
sg300
g371
sg302
I0
sg304
g372
stRp1646
ag1
(g1547
g1509
(dp1647
g287
g420
sVY
I3
sg289
I2
sg290
g421
sg298
I8
sg295
I8
sg296
g303
sVX
I3
sg292
I0
sg300
g315
sg302
I0
sg304
g344
stRp1648
ag1
(g1547
g1509
(dp1649
g287
g340
sVY
I8
sg289
I2
sg290
g341
sg298
I6
sg295
I6
sg296
g313
sVX
I4
sg292
I0
sg300
g297
sg302
I0
sg304
g344
stRp1650
ag1
(g1547
g1509
(dp1651
g287
g452
sVY
I5
sg289
I3
sg290
g453
sg298
I7
sg295
I7
sg296
g324
sVX
I2
sg292
g315
sg300
g313
sg302
I0
sg304
g407
stRp1652
ag1
(g1547
g1509
(dp1653
g287
g403
sVY
I2
sg289
I3
sg290
g404
sg298
I8
sg295
I8
sg296
g361
sVX
I4
sg292
g297
sg300
g313
sg302
I0
sg304
g407
stRp1654
ag1
(g1547
g1509
(dp1655
g287
g444
sVY
I3
sg289
I3
sg290
g445
sg298
I2
sg295
I2
sg296
g334
sVX
I3
sg292
g301
sg300
g324
sg302
I0
sg304
g353
stRp1656
ag1
(g1547
g1509
(dp1657
g287
g349
sVY
I3
sg289
I3
sg290
g350
sg298
I5
sg295
I5
sg296
g313
sVX
I2
sg292
g297
sg300
g301
sg302
I0
sg304
g353
stRp1658
ag1
(g1547
g1509
(dp1659
g287
g377
sVY
I4
sg289
I3
sg290
g378
sg298
I6
sg295
I6
sg296
g293
sVX
I5
sg292
g313
sg300
g324
sg302
I0
sg304
g381
stRp1660
ag1
(g1547
g1509
(dp1661
g287
g436
sVY
I3
sg289
I3
sg290
g437
sg298
I5
sg295
I5
sg296
g301
sVX
I3
sg292
g303
sg300
g297
sg302
I0
sg304
g381
stRp1662
ag1
(g1547
g1509
(dp1663
g287
g412
sVY
I4
sg289
I4
sg290
g413
sg298
I9
sg295
I9
sg296
g315
sVX
I9
sg292
g293
sg300
g313
sg302
g324
sg304
g390
stRp1664
ag1
(g1547
g1509
(dp1665
g287
g386
sVY
I2
sg289
I4
sg290
g387
sg298
I8
sg295
I8
sg296
g361
sVX
I2
sg292
g324
sg300
g313
sg302
g315
sg304
g390
stRp1666
ag1
(g1547
g1509
(dp1667
g287
g310
sVY
I6
sg289
I4
sg290
g311
sg298
I6
sg295
I6
sg296
g313
sVX
I6
sg292
g293
sg300
g315
sg302
g297
sg304
g316
stRp1668
ag1
(g1547
g1509
(dp1669
g287
g331
sVY
I2
sg289
I4
sg290
g332
sg298
I3
sg295
I3
sg296
g334
sVX
I9
sg292
g324
sg300
g315
sg302
g293
sg304
g316
stRp1670
ag1
(g1547
g1509
(dp1671
g287
g321
sVY
I3
sg289
I4
sg290
g322
sg298
I5
sg295
I5
sg296
g324
sVX
I3
sg292
g303
sg300
g315
sg302
g293
sg304
g326
stRp1672
ag1
(g1547
g1509
(dp1673
g287
g358
sVY
I3
sg289
I4
sg290
g359
sg298
I8
sg295
I8
sg296
g361
sVX
I3
sg292
g334
sg300
g315
sg302
g324
sg304
g326
stRp1674
ag1
(g1547
g1509
(dp1675
g287
g288
sVY
I4
sg289
I4
sg290
g291
sg298
I3
sg295
I3
sg296
g297
sVX
I3
sg292
g293
sg300
g301
sg302
g303
sg304
g305
stRp1676
ag1
(g1547
g1509
(dp1677
g287
g395
sVY
I2
sg289
I4
sg290
g396
sg298
I1
sg295
I1
sg296
g297
sVX
I7
sg292
g301
sg300
g293
sg302
g334
sg304
g305
stRp1678
asg1560
Nsg1561
I4
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1679
(dp1680
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1681
sg1501
(lp1682
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1683
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1684
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1685
(I1
(I18
I1
tg1521
I00
S'L}\r@!n\x00@\xd5\x94e@\x07Q\x16@\xb9B?@\x8c\xe41@.\xd6\xe5@\xd8\x9cD@\x00\x00\x00\x00t\xde\xdd?\xeeEY@\xa3\xaes@\x96\x1f\x82@\x88ru@~M_@\xb6B\xb6@\xbe\xe5\x97@\xe06\xad@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1686
(I1
(I18
I1
tg1521
I00
S'?o\xbd@\xe4\xe9\x00Ad\x95\x1c@\x89\x8d\xa7@\x00\x00\x00\x00sS\x8c@2\x99$A\xd1.uA\x00\x00\x00\x00\x1dnn@\x00\x00\x00\x00K+\xd0@\xe6\x1b\x0eA\x93\xfd$A=\xe4\x16AZ!\x83@\x87\x0e\x8d@\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x01'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1687
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1688
(I1
(I18
I1
tg1517
I00
S'\x08\x03s\x01\xf0\x05|\x01x\x02s\x01\xf0\x05|\x01\xcc\x18\x1f\x1e\xc0\x02s\x01\xf0\xe8.\x01\xf0\xe8.\x01\xcc\x18\x1f\x1e \xe9.\x01\xcc\x18\x1f\x1e\xc0\x02s\x01 \xe9.\x01\x08\x03s\x01\xc0\x02s\x01`r\x86\x01\x08\x03s\x01\xcc\x18\x1f\x1e'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1689
(I1
(I18
I1
tg1521
I00
S'\x00\x00`A\x00\x00\xc0@\x00\x00\x80?\x00\x00@@\x00\x00 A\x00\x00\x88A\x00\x00@A\x00\x00\x80A\x00\x00\x00\x00\x00\x00\x00A\x00\x00\x00@\x00\x000A\x00\x00\xe0@\x00\x00\x10A\x00\x00pA\x00\x00\x80@\x00\x00PA\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1690
(I1
(I18
I1
tg1517
I00
S'\xc07E\x04\xc0s{\x04\xc0\xeeD\x04\xa09(\x04\xa0Gx\x04\xc0\xccY\x04@\x1eY\x04\xe00E\x04\xcc\x18\x1f\x1e\xc0\x8fD\x04`\xc62\x04 \xe3O\x04\xe0\x88D\x04\xe0\xd6E\x04\xa0\x0cy\x04\xe0w{\x04@\xecy\x04`\xc5y\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1691
(dp1692
g1529
(dp1693
g1519
I01
sg21
I00
sg19
I00
sg22
I01
sg20
I01
sg23
I01
sg1524
I01
ssg1531
g1679
sg1532
(lp1694
g1519
ag1524
ag19
ag21
ag22
ag20
ag23
asg1534
(lp1695
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1696
(I1
(I18
I1
tg1517
I00
(lp1697
I8
aI2
aI10
aI3
aI15
aI17
aI1
aI12
aI9
aI13
aI4
aI11
aI6
aI16
aI0
aI14
aI7
aI5
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1698
g1
(g1547
g1509
(dp1699
g460
g600
sVY
I5
sg462
I2
sg463
g601
sg470
I7
sg467
I7
sg468
g469
sVX
I4
sg465
I0
sg472
g466
sg474
I0
sg475
g535
stRp1700
ag1
(g1547
g1509
(dp1701
g460
g530
sVY
I3
sg462
I2
sg463
g531
sg470
I9
sg467
I9
sg468
g473
sVX
I4
sg465
I0
sg472
g534
sg474
I0
sg475
g535
stRp1702
ag1
(g1547
g1509
(dp1703
g460
g481
sVY
I8
sg462
I2
sg463
g482
sg470
I2
sg467
I2
sg468
g484
sVX
I8
sg465
I0
sg472
g486
sg474
I0
sg475
g487
stRp1704
ag1
(g1547
g1509
(dp1705
g460
g502
sVY
I2
sg462
I2
sg463
g503
sg470
I5
sg467
I5
sg468
g484
sVX
I8
sg465
I0
sg472
g494
sg474
I0
sg475
g487
stRp1706
ag1
(g1547
g1509
(dp1707
g460
g566
sVY
I2
sg462
I3
sg463
g567
sg470
I9
sg467
I9
sg468
g473
sVX
I7
sg465
g542
sg472
g484
sg474
I0
sg475
g570
stRp1708
ag1
(g1547
g1509
(dp1709
g460
g624
sVY
I2
sg462
I3
sg463
g625
sg470
I3
sg467
I3
sg468
g494
sVX
I8
sg465
g469
sg472
g534
sg474
I0
sg475
g570
stRp1710
ag1
(g1547
g1509
(dp1711
g460
g583
sVY
I2
sg462
I3
sg463
g584
sg470
I8
sg467
I8
sg468
g524
sVX
I9
sg465
g542
sg472
g469
sg474
I0
sg475
g587
stRp1712
ag1
(g1547
g1509
(dp1713
g460
g616
sVY
I3
sg462
I3
sg463
g617
sg470
I3
sg467
I3
sg468
g484
sVX
I2
sg465
g473
sg472
g494
sg474
I0
sg475
g587
stRp1714
ag1
(g1547
g1509
(dp1715
g460
g461
sVY
I3
sg462
I3
sg463
g464
sg470
I9
sg467
I9
sg468
g469
sVX
I3
sg465
g466
sg472
g473
sg474
I0
sg475
g476
stRp1716
ag1
(g1547
g1509
(dp1717
g460
g550
sVY
I2
sg462
I3
sg463
g551
sg470
I6
sg467
I6
sg468
g494
sVX
I3
sg465
g534
sg472
g473
sg474
I0
sg475
g476
stRp1718
ag1
(g1547
g1509
(dp1719
g460
g492
sVY
I4
sg462
I4
sg463
g493
sg470
I5
sg467
I5
sg468
g486
sVX
I3
sg465
g494
sg472
g484
sg474
g473
sg475
g497
stRp1720
ag1
(g1547
g1509
(dp1721
g460
g575
sVY
I9
sg462
I4
sg463
g576
sg470
I9
sg467
I9
sg468
g469
sVX
I3
sg465
g494
sg472
g524
sg474
g523
sg475
g497
stRp1722
ag1
(g1547
g1509
(dp1723
g460
g540
sVY
I4
sg462
I4
sg463
g541
sg470
I5
sg467
I5
sg468
g534
sVX
I5
sg465
g542
sg472
g469
sg474
g473
sg475
g545
stRp1724
ag1
(g1547
g1509
(dp1725
g460
g558
sVY
I2
sg462
I4
sg463
g559
sg470
I7
sg467
I7
sg468
g524
sVX
I2
sg465
g473
sg472
g494
sg474
g469
sg475
g545
stRp1726
ag1
(g1547
g1509
(dp1727
g460
g608
sVY
I4
sg462
I4
sg463
g609
sg470
I6
sg467
I6
sg468
g486
sVX
I4
sg465
g534
sg472
g473
sg474
g494
sg475
g514
stRp1728
ag1
(g1547
g1509
(dp1729
g460
g510
sVY
I8
sg462
I4
sg463
g511
sg470
I9
sg467
I9
sg468
g494
sVX
I8
sg465
g484
sg472
g473
sg474
g486
sg475
g514
stRp1730
ag1
(g1547
g1509
(dp1731
g460
g592
sVY
I4
sg462
I4
sg463
g593
sg470
I5
sg467
I5
sg468
g523
sVX
I5
sg465
g486
sg472
g542
sg474
g466
sg475
g525
stRp1732
ag1
(g1547
g1509
(dp1733
g460
g519
sVY
I4
sg462
I4
sg463
g520
sg470
I5
sg467
I5
sg468
g494
sVX
I7
sg465
g469
sg472
g523
sg474
g524
sg475
g525
stRp1734
asg1560
Nsg1561
I5
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1735
(dp1736
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1737
sg1501
(lp1738
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1739
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1740
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1741
(I1
(I18
I1
tg1517
I00
S"\xc0\xf9N\x04@fz\x04\x80\x8cO\x04`\xecD\x04\x80|&\x04\x80\x8cE\x04\xe0\xb4x\x04 \x8e'\x04`6(\x04 \xe0\x8f\x04@t{\x04\xe0<E\x04@1z\x04\x0014\x04 \x86O\x04@\xe9&\x04 \xbfx\x04`V&\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1742
(I1
(I18
I1
tg1521
I00
S'\xbd<~@\x8d}G@ZD\xb8@\x19\xec\x8d@>\x84gA\n*0A}\xf2\xf2@\xf2\xb7\x8e@\xbd7@A9\x8c\x95@\xd4\xb7\xa0@6\x0b>AF;,A\xef{~A\x9bL\x18A\x9b\x93\xa8@\xa5\x11<A@\x1b\xae@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1743
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1744
(I1
(I18
I1
tg1517
I00
S'`r\x86\x01\xf0\xe8.\x01 \xe9.\x01\xe8\xe7.\x01\x08\x03s\x01`r\x86\x01\xe8\xe7.\x01 \xe9.\x01\xc0\x02s\x01\xc0\x02s\x018\xec.\x01 \xe9.\x01x\x02s\x01\xe8\xe7.\x01\xf0\xe8.\x01\xe8\xe7.\x01 \xe9.\x01x\x02s\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1745
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x88A\x00\x00\xe0@\x00\x000A\x00\x00\x00@\x00\x00PA\x00\x00\x80?\x00\x00@@\x00\x00\x10A\x00\x00\x80A\x00\x00\x00A\x00\x00pA\x00\x00`A\x00\x00\xc0@\x00\x00\x80@\x00\x00\xa0@\x00\x00 A\x00\x00@A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1746
(I1
(I18
I1
tg1521
I00
S'\xca$*@\xaeT\xb3?\xd8\t\x82@HY\xbc?*\xd6"@ry\x9a?\xd3\x11Z@\x17\xaaA@\x86\xc9\n@\x0b\xa9\xd7?\xc0\x8d\xa5@\x0cFf@\xfb\x0eF@\xab\x00 @\x18\xf6\x9c@\xc1\xc9P@\xe6\x8f\x8f@\x87\x83\x8e@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1747
(dp1748
g1529
(dp1749
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1735
sg1532
(lp1750
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1751
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1752
(I1
(I18
I1
tg1517
I00
(lp1753
I0
aI6
aI4
aI7
aI14
aI15
aI13
aI2
aI10
aI8
aI16
aI3
aI17
aI5
aI12
aI11
aI9
aI1
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1754
g1
(g1547
g1509
(dp1755
g632
g633
sVY
I3
sg634
I2
sg635
g636
sg642
I1
sg639
I1
sg640
g641
sVX
I9
sg637
I0
sg644
g645
sg646
I0
sg647
g648
stRp1756
ag1
(g1547
g1509
(dp1757
g632
g797
sVY
I2
sg634
I2
sg635
g798
sg642
I8
sg639
I8
sg640
g688
sVX
I2
sg637
I0
sg644
g678
sg646
I0
sg647
g648
stRp1758
ag1
(g1547
g1509
(dp1759
g632
g713
sVY
I3
sg634
I2
sg635
g714
sg642
I4
sg639
I4
sg640
g668
sVX
I6
sg637
I0
sg644
g707
sg646
I0
sg647
g717
stRp1760
ag1
(g1547
g1509
(dp1761
g632
g749
sVY
I2
sg634
I2
sg635
g750
sg642
I1
sg639
I1
sg640
g645
sVX
I6
sg637
I0
sg644
g641
sg646
I0
sg647
g717
stRp1762
ag1
(g1547
g1509
(dp1763
g632
g663
sVY
I9
sg634
I3
sg635
g664
sg642
I3
sg639
I3
sg640
g666
sVX
I5
sg637
g655
sg644
g668
sg646
I0
sg647
g669
stRp1764
ag1
(g1547
g1509
(dp1765
g632
g765
sVY
I3
sg634
I3
sg635
g766
sg642
I9
sg639
I9
sg640
g676
sVX
I5
sg637
g707
sg644
g678
sg646
I0
sg647
g669
stRp1766
ag1
(g1547
g1509
(dp1767
g632
g653
sVY
I2
sg634
I3
sg635
g654
sg642
I1
sg639
I1
sg640
g645
sVX
I7
sg637
g655
sg644
g641
sg646
I0
sg647
g658
stRp1768
ag1
(g1547
g1509
(dp1769
g632
g674
sVY
I6
sg634
I3
sg635
g675
sg642
I6
sg639
I6
sg640
g678
sVX
I6
sg637
g676
sg644
g641
sg646
I0
sg647
g658
stRp1770
ag1
(g1547
g1509
(dp1771
g632
g731
sVY
I2
sg634
I3
sg635
g732
sg642
I6
sg639
I6
sg640
g655
sVX
I2
sg637
g705
sg644
g688
sg646
I0
sg647
g735
stRp1772
ag1
(g1547
g1509
(dp1773
g632
g789
sVY
I6
sg634
I3
sg635
g790
sg642
I8
sg639
I8
sg640
g641
sVX
I2
sg637
g678
sg644
g688
sg646
I0
sg647
g735
stRp1774
ag1
(g1547
g1509
(dp1775
g632
g722
sVY
I4
sg634
I4
sg635
g723
sg642
I8
sg639
I8
sg640
g688
sVX
I3
sg637
g666
sg644
g668
sg646
g655
sg647
g726
stRp1776
ag1
(g1547
g1509
(dp1777
g632
g781
sVY
I8
sg634
I4
sg635
g782
sg642
I1
sg639
I1
sg640
g666
sVX
I2
sg637
g655
sg644
g668
sg646
g688
sg647
g726
stRp1778
ag1
(g1547
g1509
(dp1779
g632
g773
sVY
I5
sg634
I4
sg635
g774
sg642
I6
sg639
I6
sg640
g645
sVX
I4
sg637
g666
sg644
g688
sg646
g707
sg647
g708
stRp1780
ag1
(g1547
g1509
(dp1781
g632
g702
sVY
I3
sg634
I4
sg635
g703
sg642
I7
sg639
I7
sg640
g705
sVX
I2
sg637
g676
sg644
g707
sg646
g666
sg647
g708
stRp1782
ag1
(g1547
g1509
(dp1783
g632
g684
sVY
I3
sg634
I4
sg635
g685
sg642
I5
sg639
I5
sg640
g666
sVX
I3
sg637
g645
sg644
g655
sg646
g688
sg647
g689
stRp1784
ag1
(g1547
g1509
(dp1785
g632
g694
sVY
I4
sg634
I4
sg635
g695
sg642
I5
sg639
I5
sg640
g655
sVX
I8
sg637
g678
sg644
g641
sg646
g676
sg647
g689
stRp1786
ag1
(g1547
g1509
(dp1787
g632
g740
sVY
I2
sg634
I4
sg635
g741
sg642
I5
sg639
I5
sg640
g666
sVX
I6
sg637
g676
sg644
g655
sg646
g668
sg647
g744
stRp1788
ag1
(g1547
g1509
(dp1789
g632
g757
sVY
I2
sg634
I4
sg635
g758
sg642
I3
sg639
I3
sg640
g666
sVX
I3
sg637
g707
sg644
g676
sg646
g668
sg647
g744
stRp1790
asg1560
Nsg1561
I1
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1791
(dp1792
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1793
sg1501
(lp1794
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1795
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1796
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1797
(I1
(I18
I1
tg1517
I00
S"\xe0\xe0O\x04`[\x8e\x04 \xe9E\x04\xc0\x8d'\x04\xc0\xffN\x04\xe0\xd7\x1f\x04\xa0\x8fD\x04`\xe2D\x04`64\x04@\x07,\x04\x00:D\x04\x80\xd9E\x04\xc0\xdc\x8e\x04\xa0\x85'\x04`cy\x04\xa0\x84D\x04 by\x04\x00\x85O\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1798
(I1
(I18
I1
tg1521
I00
S'%~\xb7@bZ\xc0@2\xe3\xd7?\xef\xabc@\xb2\x8c\x80AC\x11\x83@E\xeb A\xc1#\xed@:\x8b\xa6@\x0e\xb8EA\x18\x8e\xdc@$F\x12A\xc5"\x82AG\\\xca?\x1dv[A\x00\x00\x00\x00\x03\xdcnA$  A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1799
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1800
(I1
(I18
I1
tg1517
I00
S'\xf0\x05|\x01 \xe9.\x01`r\x86\x01\xc0\x02s\x01\xc0\x02s\x01x\x02s\x01\xf0\xe8.\x018\xec.\x018\xec.\x01\xc0\x02s\x01\xe8\xe7.\x018\xec.\x01 \xe9.\x01x\x02s\x01\x08\x03s\x01\xcc\x18\x1f\x1e \xe9.\x01\xf0\x05|\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1801
(I1
(I18
I1
tg1521
I00
S'\x00\x00PA\x00\x00\x10A\x00\x00\x80A\x00\x00@@\x00\x00pA\x00\x00`A\x00\x000A\x00\x00\x80?\x00\x00\xc0@\x00\x00\x88A\x00\x00@A\x00\x00\x00\x00\x00\x00\xe0@\x00\x00 A\x00\x00\x00A\x00\x00\x00@\x00\x00\xa0@\x00\x00\x80@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1802
(I1
(I18
I1
tg1521
I00
S'H\xc7\x8c?\x00\x8b\x03@\x0c&j@\xa7\xb0\x97?Dq\xd7?\xd2\xad%@\x00\xf8[@\xe3I\x86@H\xc8\x16@uf\x92@\xbc\x02\xf2?\xb6Z|@ h\x88@\xaf\x16\xa7@\x0b\x98\xaf@\xd3\rS@\x19\xfa\x8e@\xf6`\x8b@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1803
(dp1804
g1529
(dp1805
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1791
sg1532
(lp1806
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1807
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1808
(I1
(I18
I1
tg1517
I00
(lp1809
I11
aI7
aI15
aI3
aI17
aI16
aI8
aI12
aI14
aI1
aI13
aI6
aI10
aI0
aI5
aI4
aI2
aI9
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1810
g1
(g1547
g1509
(dp1811
g805
g937
sVY
I2
sg807
I2
sg808
g938
sg816
I1
sg813
I1
sg814
g811
sVX
I9
sg810
I0
sg818
g842
sg820
I0
sg822
g908
stRp1812
ag1
(g1547
g1509
(dp1813
g805
g904
sVY
I4
sg807
I2
sg808
g905
sg816
I4
sg813
I4
sg814
g811
sVX
I3
sg810
I0
sg818
g819
sg820
I0
sg822
g908
stRp1814
ag1
(g1547
g1509
(dp1815
g805
g962
sVY
I4
sg807
I2
sg808
g963
sg816
I9
sg813
I9
sg814
g819
sVX
I2
sg810
I0
sg818
g834
sg820
I0
sg822
g855
stRp1816
ag1
(g1547
g1509
(dp1817
g805
g850
sVY
I6
sg807
I2
sg808
g851
sg816
I6
sg813
I6
sg814
g842
sVX
I8
sg810
I0
sg818
g854
sg820
I0
sg822
g855
stRp1818
ag1
(g1547
g1509
(dp1819
g805
g954
sVY
I4
sg807
I3
sg808
g955
sg816
I6
sg813
I6
sg814
g815
sVX
I6
sg810
g830
sg818
g864
sg820
I0
sg822
g949
stRp1820
ag1
(g1547
g1509
(dp1821
g805
g945
sVY
I9
sg807
I3
sg808
g946
sg816
I7
sg813
I7
sg814
g821
sVX
I9
sg810
g815
sg818
g842
sg820
I0
sg822
g949
stRp1822
ag1
(g1547
g1509
(dp1823
g805
g921
sVY
I4
sg807
I3
sg808
g922
sg816
I8
sg813
I8
sg814
g819
sVX
I3
sg810
g811
sg818
g821
sg820
I0
sg822
g835
stRp1824
ag1
(g1547
g1509
(dp1825
g805
g828
sVY
I2
sg807
I3
sg808
g829
sg816
I2
sg813
I2
sg814
g832
sVX
I4
sg810
g830
sg818
g834
sg820
I0
sg822
g835
stRp1826
ag1
(g1547
g1509
(dp1827
g805
g878
sVY
I2
sg807
I3
sg808
g879
sg816
I1
sg813
I1
sg814
g830
sVX
I8
sg810
g832
sg818
g815
sg820
I0
sg822
g882
stRp1828
ag1
(g1547
g1509
(dp1829
g805
g970
sVY
I3
sg807
I3
sg808
g971
sg816
I9
sg813
I9
sg814
g830
sVX
I2
sg810
g819
sg818
g854
sg820
I0
sg822
g882
stRp1830
ag1
(g1547
g1509
(dp1831
g805
g929
sVY
I3
sg807
I4
sg808
g930
sg816
I1
sg813
I1
sg814
g815
sVX
I6
sg810
g811
sg818
g832
sg820
g821
sg822
g823
stRp1832
ag1
(g1547
g1509
(dp1833
g805
g806
sVY
I2
sg807
I4
sg808
g809
sg816
I2
sg813
I2
sg814
g815
sVX
I3
sg810
g811
sg818
g819
sg820
g821
sg822
g823
stRp1834
ag1
(g1547
g1509
(dp1835
g805
g887
sVY
I9
sg807
I4
sg808
g888
sg816
I1
sg813
I1
sg814
g832
sVX
I3
sg810
g854
sg818
g815
sg820
g821
sg822
g891
stRp1836
ag1
(g1547
g1509
(dp1837
g805
g913
sVY
I3
sg807
I4
sg808
g914
sg816
I3
sg813
I3
sg814
g842
sVX
I6
sg810
g834
sg818
g854
sg820
g830
sg822
g891
stRp1838
ag1
(g1547
g1509
(dp1839
g805
g896
sVY
I2
sg807
I4
sg808
g897
sg816
I7
sg813
I7
sg814
g830
sVX
I2
sg810
g819
sg818
g834
sg820
g854
sg822
g845
stRp1840
ag1
(g1547
g1509
(dp1841
g805
g840
sVY
I2
sg807
I4
sg808
g841
sg816
I1
sg813
I1
sg814
g834
sVX
I8
sg810
g842
sg818
g811
sg820
g830
sg822
g845
stRp1842
ag1
(g1547
g1509
(dp1843
g805
g870
sVY
I2
sg807
I4
sg808
g871
sg816
I5
sg813
I5
sg814
g830
sVX
I2
sg810
g854
sg818
g815
sg820
g864
sg822
g865
stRp1844
ag1
(g1547
g1509
(dp1845
g805
g860
sVY
I2
sg807
I4
sg808
g861
sg816
I7
sg813
I7
sg814
g854
sVX
I2
sg810
g830
sg818
g834
sg820
g864
sg822
g865
stRp1846
asg1560
Nsg1561
I9
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1847
(dp1848
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1849
sg1501
(lp1850
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1851
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1852
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1853
(I1
(I18
I1
tg1517
I00
S"\x003D\x04\xc0/)\x04\xc0\xc9y\x04\x00\x8c'\x04\xc0\xeb&\x04 \xdd\x8e\x04\xa0\xd9\x1f\x04\x00\x1fY\x04 \xe1O\x04\x00\x8eD\x04\xa0\xd0\x1f\x04`dy\x04@\x7f&\x04 \xeay\x04 1(\x04\xe0\xdaE\x04@:'\x04\xa0\xdf\x8e\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1854
(I1
(I18
I1
tg1521
I00
S'@r+@l\xe7\x92@\xfa\xf92@\x1c\xee>@\xa9\x9d\xf1@\x97\x1chA\xc9N\x95@\xbb\xc8#A\xc6(\x96@\xc6\xd7\xdd@\x88\xcd\x85A\x97\x93iA\x00\x00\x00\x00g+\xce@g]\x9f@.:5A\xb4\xe7\xc0@d\xe2*A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1855
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1856
(I1
(I18
I1
tg1517
I00
S'\xe8\xe7.\x01\xf0\x05|\x01\xe8\xe7.\x01\xc0\x02s\x01`r\x86\x01 \xe9.\x01\xc0\x02s\x01x\x02s\x01\x08\x03s\x01\xe8\xe7.\x01\xf0\xe8.\x01\xf0\x05|\x01\xcc\x18\x1f\x1e \xe9.\x01\xf0\xe8.\x01\xe8\xe7.\x01\xf0\x05|\x01x\x02s\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1857
(I1
(I18
I1
tg1521
I00
S'\x00\x00`A\x00\x00\x00A\x00\x00\xa0@\x00\x00@A\x00\x00 A\x00\x00\xe0@\x00\x00\x80A\x00\x00\x80?\x00\x00pA\x00\x00PA\x00\x00\x00@\x00\x00\xc0@\x00\x00@@\x00\x00\x88A\x00\x00\x80@\x00\x00\x00\x00\x00\x000A\x00\x00\x10A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1858
(I1
(I18
I1
tg1521
I00
S'\x8a\x94\xa1?\xee\xa1\xa0?\xefv\x18@\xca\x05R?\xf2\xc9\xe3??D/A\r\xe3\x12@\xdbF\xd1?\x1b\xc6*@#N\xd6?i\x14 @\xd8\xa9\x88@2\xe6D@\xed\xc4\xd4?\xce\x97\xf3@3\xee6@D\x7f\x1aA\x84\rx@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1859
(dp1860
g1529
(dp1861
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1847
sg1532
(lp1862
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1863
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1864
(I1
(I18
I1
tg1517
I00
(lp1865
I15
aI7
aI10
aI12
aI14
aI2
aI11
aI5
aI1
aI17
aI4
aI16
aI3
aI9
aI0
aI8
aI6
aI13
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1866
g1
(g1547
g1509
(dp1867
g978
g1119
sVY
I2
sg980
I2
sg981
g1120
sg989
I2
sg986
I2
sg987
g988
sVX
I3
sg983
I0
sg991
g984
sg993
I0
sg995
g1071
stRp1868
ag1
(g1547
g1509
(dp1869
g978
g1067
sVY
I2
sg980
I2
sg981
g1068
sg989
I3
sg986
I3
sg987
g1014
sVX
I6
sg983
I0
sg991
g1005
sg993
I0
sg995
g1071
stRp1870
ag1
(g1547
g1509
(dp1871
g978
g1040
sVY
I4
sg980
I2
sg981
g1041
sg989
I1
sg986
I1
sg987
g984
sVX
I8
sg983
I0
sg991
g1014
sg993
I0
sg995
g1044
stRp1872
ag1
(g1547
g1509
(dp1873
g978
g1102
sVY
I2
sg980
I2
sg981
g1103
sg989
I6
sg986
I6
sg987
g1017
sVX
I3
sg983
I0
sg991
g988
sg993
I0
sg995
g1044
stRp1874
ag1
(g1547
g1509
(dp1875
g978
g1086
sVY
I8
sg980
I3
sg981
g1087
sg989
I9
sg986
I9
sg987
g1003
sVX
I6
sg983
g992
sg991
g1017
sg993
I0
sg995
g1062
stRp1876
ag1
(g1547
g1509
(dp1877
g978
g1058
sVY
I2
sg980
I3
sg981
g1059
sg989
I4
sg986
I4
sg987
g1014
sVX
I3
sg983
g1051
sg991
g984
sg993
I0
sg995
g1062
stRp1878
ag1
(g1547
g1509
(dp1879
g978
g1135
sVY
I3
sg980
I3
sg981
g1136
sg989
I6
sg986
I6
sg987
g1017
sVX
I3
sg983
g1051
sg991
g1003
sg993
I0
sg995
g1007
stRp1880
ag1
(g1547
g1509
(dp1881
g978
g1001
sVY
I2
sg980
I3
sg981
g1002
sg989
I3
sg986
I3
sg987
g1005
sVX
I8
sg983
g1003
sg991
g988
sg993
I0
sg995
g1007
stRp1882
ag1
(g1547
g1509
(dp1883
g978
g1127
sVY
I3
sg980
I3
sg981
g1128
sg989
I7
sg986
I7
sg987
g1051
sVX
I6
sg983
g984
sg991
g988
sg993
I0
sg995
g1114
stRp1884
ag1
(g1547
g1509
(dp1885
g978
g1110
sVY
I3
sg980
I3
sg981
g1111
sg989
I1
sg986
I1
sg987
g1003
sVX
I3
sg983
g1017
sg991
g992
sg993
I0
sg995
g1114
stRp1886
ag1
(g1547
g1509
(dp1887
g978
g1012
sVY
I6
sg980
I4
sg981
g1013
sg989
I8
sg986
I8
sg987
g994
sVX
I6
sg983
g1014
sg991
g1017
sg993
g992
sg995
g1018
stRp1888
ag1
(g1547
g1509
(dp1889
g978
g1049
sVY
I9
sg980
I4
sg981
g1050
sg989
I8
sg986
I8
sg987
g1014
sVX
I3
sg983
g1051
sg991
g1005
sg993
g994
sg995
g1018
stRp1890
ag1
(g1547
g1509
(dp1891
g978
g1023
sVY
I2
sg980
I4
sg981
g1024
sg989
I8
sg986
I8
sg987
g1017
sVX
I3
sg983
g988
sg991
g994
sg993
g992
sg995
g1027
stRp1892
ag1
(g1547
g1509
(dp1893
g978
g1143
sVY
I3
sg980
I4
sg981
g1144
sg989
I2
sg986
I2
sg987
g1080
sVX
I2
sg983
g994
sg991
g992
sg993
g1014
sg995
g1027
stRp1894
ag1
(g1547
g1509
(dp1895
g978
g1032
sVY
I7
sg980
I4
sg981
g1033
sg989
I8
sg986
I8
sg987
g994
sVX
I6
sg983
g1017
sg991
g992
sg993
g1014
sg995
g996
stRp1896
ag1
(g1547
g1509
(dp1897
g978
g979
sVY
I9
sg980
I4
sg981
g982
sg989
I1
sg986
I1
sg987
g988
sVX
I9
sg983
g984
sg991
g992
sg993
g994
sg995
g996
stRp1898
ag1
(g1547
g1509
(dp1899
g978
g1094
sVY
I3
sg980
I4
sg981
g1095
sg989
I6
sg986
I6
sg987
g1051
sVX
I9
sg983
g988
sg991
g1003
sg993
g984
sg995
g1081
stRp1900
ag1
(g1547
g1509
(dp1901
g978
g1076
sVY
I4
sg980
I4
sg981
g1077
sg989
I6
sg986
I6
sg987
g994
sVX
I2
sg983
g988
sg991
g992
sg993
g1080
sg995
g1081
stRp1902
asg1560
Nsg1561
I13
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1903
(dp1904
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1905
sg1501
(lp1906
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1907
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1908
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1909
(I1
(I18
I1
tg1517
I00
S" n\x8f\x04\x80my\x04\x00\xc75\x04 \xe8D\x04@\xedO\x04\x808(\x04\x005(\x04\xe0m5\x04\x80#\xe7\x03 64\x04\xa0\x8aD\x04`q{\x04\x00S&\x04\xe00G\x04 \x8f'\x04 `\x8f\x04\xa0\x9c2\x04@+\xe7\x03"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1910
(I1
(I18
I1
tg1521
I00
S'^\x9et@\x8d}\xc3@\xc2%\xe6?\xc3d\xf2?\xc1(\xbd@\xfcO>Ac\x03\x02A\x0e\xd2\x91@\xd9U\x84@\x16\xd9\x90@\xf9\xd9MA\xad\x00\xdd@y\xf6\xec@\x90J\x00A\xaf\x18\xe8@\x89-\x17AE%\x1dA@}\nA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1911
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1912
(I1
(I18
I1
tg1517
I00
S'\xf0\x05|\x01x\x02s\x01\xf0\xe8.\x01\xf0\xe8.\x01 \xe9.\x01 \xe9.\x01\xc0\x02s\x01x\x02s\x01\xf0\x05|\x01\xe8\xe7.\x01x\x02s\x01x\x02s\x01 \xe9.\x01\x08\x03s\x018\xec.\x01`r\x86\x01\x08\x03s\x01\xc0\x02s\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1913
(I1
(I18
I1
tg1521
I00
S'\x00\x00\xc0@\x00\x00PA\x00\x00\x10A\x00\x00\x88A\x00\x00\x80?\x00\x00\x80A\x00\x00pA\x00\x00 A\x00\x00\x00A\x00\x00\xa0@\x00\x00@@\x00\x00`A\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x80@\x00\x00@A\x00\x00\xe0@\x00\x000A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1914
(I1
(I18
I1
tg1521
I00
S'{[\x9e?\x0c\x13\x95?:\xd2\x96?%\x14j?\x0b4\x81?\xfc%\xd0?n\xb5\xf5@\xfb\xb0\xca?c\xaf\xb2?\xdc\xfb\xa8?\x8eZ\x06@\xde\xd3H@5\xca\x1a@\xe2\xea\xe4?6\xd5\xf9?\xc07\x89@\x98\xdd\xaf?\x99\x08\xd6?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1915
(dp1916
g1529
(dp1917
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1903
sg1532
(lp1918
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1919
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1920
(I1
(I18
I1
tg1517
I00
(lp1921
I12
aI4
aI13
aI10
aI14
aI9
aI0
aI16
aI8
aI2
aI7
aI17
aI15
aI1
aI11
aI6
aI5
aI3
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1922
g1
(g1547
g1509
(dp1923
g1151
g1223
sVY
I6
sg1153
I2
sg1154
g1224
sg1162
I7
sg1159
I7
sg1160
g1188
sVX
I3
sg1156
I0
sg1164
g1205
sg1166
I0
sg1168
g1227
stRp1924
ag1
(g1547
g1509
(dp1925
g1151
g1284
sVY
I4
sg1153
I2
sg1154
g1285
sg1162
I2
sg1159
I2
sg1160
g1165
sVX
I5
sg1156
I0
sg1164
g1215
sg1166
I0
sg1168
g1227
stRp1926
ag1
(g1547
g1509
(dp1927
g1151
g1250
sVY
I2
sg1153
I2
sg1154
g1251
sg1162
I8
sg1159
I8
sg1160
g1205
sVX
I2
sg1156
I0
sg1164
g1196
sg1166
I0
sg1168
g1254
stRp1928
ag1
(g1547
g1509
(dp1929
g1151
g1316
sVY
I2
sg1153
I2
sg1154
g1317
sg1162
I8
sg1159
I8
sg1160
g1186
sVX
I2
sg1156
I0
sg1164
g1196
sg1166
I0
sg1168
g1254
stRp1930
ag1
(g1547
g1509
(dp1931
g1151
g1174
sVY
I3
sg1153
I3
sg1154
g1175
sg1162
I4
sg1159
I4
sg1160
g1157
sVX
I8
sg1156
g1167
sg1164
g1161
sg1166
I0
sg1168
g1178
stRp1932
ag1
(g1547
g1509
(dp1933
g1151
g1308
sVY
I2
sg1153
I3
sg1154
g1309
sg1162
I4
sg1159
I4
sg1160
g1188
sVX
I3
sg1156
g1196
sg1164
g1186
sg1166
I0
sg1168
g1178
stRp1934
ag1
(g1547
g1509
(dp1935
g1151
g1300
sVY
I2
sg1153
I3
sg1154
g1301
sg1162
I9
sg1159
I9
sg1160
g1205
sVX
I2
sg1156
g1157
sg1164
g1165
sg1166
I0
sg1168
g1263
stRp1936
ag1
(g1547
g1509
(dp1937
g1151
g1259
sVY
I2
sg1153
I3
sg1154
g1260
sg1162
I2
sg1159
I2
sg1160
g1215
sVX
I9
sg1156
g1188
sg1164
g1165
sg1166
I0
sg1168
g1263
stRp1938
ag1
(g1547
g1509
(dp1939
g1151
g1242
sVY
I4
sg1153
I3
sg1154
g1243
sg1162
I5
sg1159
I5
sg1160
g1157
sVX
I8
sg1156
g1161
sg1164
g1236
sg1166
I0
sg1168
g1218
stRp1940
ag1
(g1547
g1509
(dp1941
g1151
g1213
sVY
I6
sg1153
I3
sg1154
g1214
sg1162
I1
sg1159
I1
sg1160
g1165
sVX
I8
sg1156
g1215
sg1164
g1188
sg1166
I0
sg1168
g1218
stRp1942
ag1
(g1547
g1509
(dp1943
g1151
g1193
sVY
I3
sg1153
I4
sg1154
g1194
sg1162
I2
sg1159
I2
sg1160
g1196
sVX
I6
sg1156
g1165
sg1164
g1161
sg1166
g1188
sg1168
g1198
stRp1944
ag1
(g1547
g1509
(dp1945
g1151
g1292
sVY
I2
sg1153
I4
sg1154
g1293
sg1162
I8
sg1159
I8
sg1160
g1165
sVX
I2
sg1156
g1167
sg1164
g1186
sg1166
g1157
sg1168
g1198
stRp1946
ag1
(g1547
g1509
(dp1947
g1151
g1152
sVY
I3
sg1153
I4
sg1154
g1155
sg1162
I3
sg1159
I3
sg1160
g1161
sVX
I4
sg1156
g1157
sg1164
g1165
sg1166
g1167
sg1168
g1169
stRp1948
ag1
(g1547
g1509
(dp1949
g1151
g1183
sVY
I3
sg1153
I4
sg1154
g1184
sg1162
I4
sg1159
I4
sg1160
g1186
sVX
I7
sg1156
g1167
sg1164
g1188
sg1166
g1165
sg1168
g1169
stRp1950
ag1
(g1547
g1509
(dp1951
g1151
g1203
sVY
I4
sg1153
I4
sg1154
g1204
sg1162
I7
sg1159
I7
sg1160
g1165
sVX
I8
sg1156
g1205
sg1164
g1188
sg1166
g1196
sg1168
g1208
stRp1952
ag1
(g1547
g1509
(dp1953
g1151
g1276
sVY
I3
sg1153
I4
sg1154
g1277
sg1162
I6
sg1159
I6
sg1160
g1196
sVX
I5
sg1156
g1215
sg1164
g1157
sg1166
g1236
sg1168
g1208
stRp1954
ag1
(g1547
g1509
(dp1955
g1151
g1232
sVY
I2
sg1153
I4
sg1154
g1233
sg1162
I8
sg1159
I8
sg1160
g1157
sVX
I4
sg1156
g1167
sg1164
g1236
sg1166
g1205
sg1168
g1237
stRp1956
ag1
(g1547
g1509
(dp1957
g1151
g1268
sVY
I5
sg1153
I4
sg1154
g1269
sg1162
I3
sg1159
I3
sg1160
g1236
sVX
I9
sg1156
g1167
sg1164
g1157
sg1166
g1215
sg1168
g1237
stRp1958
asg1560
Nsg1561
I3
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbag1
(g1496
g3
NtRp1959
(dp1960
g1499
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.00), 2015_05_26_0333\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.practice\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport random \u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'KRITL'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1920, 1080), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "intro1"\u000aintro1Clock = core.Clock()\u000aimage = visual.ImageStim(win=win, name='image',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide1.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro2"\u000aintro2Clock = core.Clock()\u000aimage_2 = visual.ImageStim(win=win, name='image_2',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide2.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro3"\u000aintro3Clock = core.Clock()\u000aimage_3 = visual.ImageStim(win=win, name='image_3',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=1.0,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro4"\u000aintro4Clock = core.Clock()\u000aimage_4 = visual.ImageStim(win=win, name='image_4',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide4.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro5"\u000aintro5Clock = core.Clock()\u000aimage_5 = visual.ImageStim(win=win, name='image_5',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide5.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro6"\u000aintro6Clock = core.Clock()\u000aimage_6 = visual.ImageStim(win=win, name='image_6',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide6.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro7"\u000aintro7Clock = core.Clock()\u000aimage_7 = visual.ImageStim(win=win, name='image_7',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide7.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro8"\u000aintro8Clock = core.Clock()\u000aimage_8 = visual.ImageStim(win=win, name='image_8',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide8.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2, 1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "intro9"\u000aintro9Clock = core.Clock()\u000aimage_9 = visual.ImageStim(win=win, name='image_9',\u000a    image="C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide12.JPG", mask=None,\u000a    ori=0, pos=[0, 0], size=[2,1.8],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "instruction"\u000ainstructionClock = core.Clock()\u000atext_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a    text='default text',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=45,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "operation"\u000aoperationClock = core.Clock()\u000apractice_text_4 = visual.TextStim(win=win, ori=0, name='practice_text_4',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text1 = visual.TextStim(win=win, ori=0, name='practice_text1',\u000a    text='default text',    font='Arial',\u000a    pos=[0,1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_text2 = visual.TextStim(win=win, ori=0, name='practice_text2',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_text3 = visual.TextStim(win=win, ori=0, name='practice_text3',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-0.5], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_text4 = visual.TextStim(win=win, ori=0, name='practice_text4',\u000a    text='default text',    font='Arial',\u000a    pos=[0,-1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000ano_response = visual.TextStim(win=win, ori=0, name='no_response',\u000a    text='No response was made',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000apractice_center = visual.TextStim(win=win, ori=0, name='practice_center',\u000a    text='+',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000apractice_x_is = visual.TextStim(win=win, ori=0, name='practice_x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_y_is = visual.TextStim(win=win, ori=0, name='practice_y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "check"\u000acheckClock = core.Clock()\u000amessage='anything'\u000acorrect_practice=[]\u000atotal_practice=[]\u000apractice_feedback = visual.TextStim(win=win, ori=0, name='practice_feedback',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a\u000a# Initialize components for Routine "record"\u000arecordClock = core.Clock()\u000a\u000a\u000a# Initialize components for Routine "begining"\u000abeginingClock = core.Clock()\u000abegining_text = visual.TextStim(win=win, ori=0, name='begining_text',\u000a    text='default text',    font=u'Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "operation2"\u000aoperation2Clock = core.Clock()\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_1 = visual.TextStim(win=win, ori=0, name='text_1',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000atext_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -3], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000a    \u000a# Initialize components for Routine "trial2"\u000atrial2Clock = core.Clock()\u000acenter = visual.TextStim(win=win, ori=0, name='center',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.14, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ax_is = visual.TextStim(win=win, ori=0, name='x_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000ay_is = visual.TextStim(win=win, ori=0, name='y_is',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.1], height=0.12, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "record2"\u000arecord2Clock = core.Clock()\u000acorrect_block=[]\u000atotal_block=[]\u000a\u000a# Initialize components for Routine "thank"\u000athankClock = core.Clock()\u000athank_text = visual.TextStim(win=win, ori=0, name='thank_text',\u000a    text='Your session is over. Thank you for your participation.\u005cnPlease alert the experimenter. ',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#---------------Start the experiment-----------------\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "intro1"-------\u000at = 0\u000aintro1Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro1.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro1Components = []\u000aintro1Components.append(image)\u000aintro1Components.append(key_resp_intro1)\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a\u000a#-------Start Routine "intro1"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro1Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image* updates\u000a    if t >= 0.0 and image.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image.tStart = t  # underestimates by a little under one frame\u000a        image.frameNStart = frameN  # exact frame index\u000a        image.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro1* updates\u000a    if t >= 0.0 and key_resp_intro1.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro1.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro1.frameNStart = frameN  # exact frame index\u000a        key_resp_intro1.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro1.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro1Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro1"-------\u000afor thisComponent in intro1Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro2"-------\u000at = 0\u000aintro2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro2.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro2Components = []\u000aintro2Components.append(image_2)\u000aintro2Components.append(key_resp_intro2)\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_2* updates\u000a    if t >= 0.0 and image_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_2.tStart = t  # underestimates by a little under one frame\u000a        image_2.frameNStart = frameN  # exact frame index\u000a        image_2.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro2* updates\u000a    if t >= 0.0 and key_resp_intro2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro2.frameNStart = frameN  # exact frame index\u000a        key_resp_intro2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro2"-------\u000afor thisComponent in intro2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro3"-------\u000at = 0\u000aintro3Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aimage_3.setImage("C:\u005cUsers\u005cexperimenter\u005cDesktop\u005cExperiments\u005cKRITL\u005cSlide3.JPG")\u000aimage_3.setSize([2, 1.8])\u000akey_resp_intro3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro3.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro3Components = []\u000aintro3Components.append(image_3)\u000aintro3Components.append(key_resp_intro3)\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro3"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro3Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_3* updates\u000a    if t >= 0.0 and image_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_3.tStart = t  # underestimates by a little under one frame\u000a        image_3.frameNStart = frameN  # exact frame index\u000a        image_3.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro3* updates\u000a    if t >= 0.0 and key_resp_intro3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro3.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro3.frameNStart = frameN  # exact frame index\u000a        key_resp_intro3.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro3.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro3Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro3"-------\u000afor thisComponent in intro3Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro4"-------\u000at = 0\u000aintro4Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro4 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro4.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro4Components = []\u000aintro4Components.append(image_4)\u000aintro4Components.append(key_resp_intro4)\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro4"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro4Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_4* updates\u000a    if t >= 0.0 and image_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_4.tStart = t  # underestimates by a little under one frame\u000a        image_4.frameNStart = frameN  # exact frame index\u000a        image_4.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro4* updates\u000a    if t >= 0.0 and key_resp_intro4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro4.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro4.frameNStart = frameN  # exact frame index\u000a        key_resp_intro4.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro4.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro4Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro4"-------\u000afor thisComponent in intro4Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro5"-------\u000at = 0\u000aintro5Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro5 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro5.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro5Components = []\u000aintro5Components.append(image_5)\u000aintro5Components.append(key_resp_intro5)\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro5"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro5Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_5* updates\u000a    if t >= 0.0 and image_5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_5.tStart = t  # underestimates by a little under one frame\u000a        image_5.frameNStart = frameN  # exact frame index\u000a        image_5.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro5* updates\u000a    if t >= 0.0 and key_resp_intro5.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro5.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro5.frameNStart = frameN  # exact frame index\u000a        key_resp_intro5.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro5.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro5Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro5"-------\u000afor thisComponent in intro5Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro6"-------\u000at = 0\u000aintro6Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro6.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro6Components = []\u000aintro6Components.append(image_6)\u000aintro6Components.append(key_resp_intro6)\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro6"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro6Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_6* updates\u000a    if t >= 0.0 and image_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_6.tStart = t  # underestimates by a little under one frame\u000a        image_6.frameNStart = frameN  # exact frame index\u000a        image_6.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro6* updates\u000a    if t >= 0.0 and key_resp_intro6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro6.frameNStart = frameN  # exact frame index\u000a        key_resp_intro6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro6Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro6"-------\u000afor thisComponent in intro6Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro7"-------\u000at = 0\u000aintro7Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro7 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro7.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro7Components = []\u000aintro7Components.append(image_7)\u000aintro7Components.append(key_resp_intro7)\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro7"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro7Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_7* updates\u000a    if t >= 0.0 and image_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_7.tStart = t  # underestimates by a little under one frame\u000a        image_7.frameNStart = frameN  # exact frame index\u000a        image_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro7* updates\u000a    if t >= 0.0 and key_resp_intro7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro7.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro7.frameNStart = frameN  # exact frame index\u000a        key_resp_intro7.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro7.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro7Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro7"-------\u000afor thisComponent in intro7Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro8"-------\u000at = 0\u000aintro8Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro8 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro8.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro8Components = []\u000aintro8Components.append(image_8)\u000aintro8Components.append(key_resp_intro8)\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro8"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro8Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_8* updates\u000a    if t >= 0.0 and image_8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_8.tStart = t  # underestimates by a little under one frame\u000a        image_8.frameNStart = frameN  # exact frame index\u000a        image_8.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro8* updates\u000a    if t >= 0.0 and key_resp_intro8.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro8.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro8.frameNStart = frameN  # exact frame index\u000a        key_resp_intro8.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro8.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro8Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro8"-------\u000afor thisComponent in intro8Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "intro9"-------\u000at = 0\u000aintro9Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000akey_resp_intro9 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_intro9.status = NOT_STARTED\u000a# keep track of which components have finished\u000aintro9Components = []\u000aintro9Components.append(image_9)\u000aintro9Components.append(key_resp_intro9)\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "intro9"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = intro9Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *image_9* updates\u000a    if t >= 0.0 and image_9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        image_9.tStart = t  # underestimates by a little under one frame\u000a        image_9.frameNStart = frameN  # exact frame index\u000a        image_9.setAutoDraw(True)\u000a    \u000a    # *key_resp_intro9* updates\u000a    if t >= 0.0 and key_resp_intro9.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_intro9.tStart = t  # underestimates by a little under one frame\u000a        key_resp_intro9.frameNStart = frameN  # exact frame index\u000a        key_resp_intro9.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_intro9.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in intro9Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "intro9"-------\u000afor thisComponent in intro9Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a#------Prepare to start Routine "instruction"-------\u000at = 0\u000ainstructionClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000atext_7.setText('Practice trial is starting.\u005cnPlease make sure to respond as quickly and accurately as possible.\u005cnPress space key when you are ready.')\u000akey_resp_6 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_6.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionComponents = []\u000ainstructionComponents.append(text_7)\u000ainstructionComponents.append(key_resp_6)\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruction"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_7* updates\u000a    if t >= 0.0 and text_7.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_7.tStart = t  # underestimates by a little under one frame\u000a        text_7.frameNStart = frameN  # exact frame index\u000a        text_7.setAutoDraw(True)\u000a    \u000a    # *key_resp_6* updates\u000a    if t >= 0 and key_resp_6.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_6.tStart = t  # underestimates by a little under one frame\u000a        key_resp_6.frameNStart = frameN  # exact frame index\u000a        key_resp_6.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_6.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instruction"-------\u000afor thisComponent in instructionComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a#practice trial is starting\u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a        \u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_trials = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('practicetrial.xlsx'),\u000a    seed=None, name='practice_trials')\u000athisExp.addLoop(practice_trials)  # add the loop to the experiment\u000athisPractice_trial = practice_trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_trial.rgb)\u000aif thisPractice_trial != None:\u000a    for paramName in thisPractice_trial.keys():\u000a        exec(paramName + '= thisPractice_trial.' + paramName)\u000a\u000afor thisPractice_trial in practice_trials:\u000a    currentLoop = practice_trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_trial.rgb)\u000a    if thisPractice_trial != None:\u000a        for paramName in thisPractice_trial.keys():\u000a            exec(paramName + '= thisPractice_trial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "operation"-------\u000a    t = 0\u000a    operationClock.reset()  # clock \u000a    frameN = -1\u000a    \u000a    if operationc==0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.1])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, -0.1])\u000a        practice_text3.setText("")\u000a        practice_text4.setText("")\u000a        \u000a    elif operationc is not 0 and operationd==0:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.2])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.2])\u000a        practice_text4.setText("")\u000a    else:\u000a        practice_text1.setText(operationa)\u000a        practice_text1.setPos([0, 0.3])\u000a        practice_text2.setText(operationb)\u000a        practice_text2.setPos([0, 0.1])\u000a        practice_text3.setText(operationc)\u000a        practice_text3.setPos([0, -0.1])\u000a        practice_text4.setText(operationd)\u000a        practice_text4.setPos([0, -0.3])\u000a     \u000a    \u000a    practice_resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    operationComponents = []\u000a    operationComponents.append(practice_text_4)\u000a    operationComponents.append(practice_text4)\u000a    operationComponents.append(practice_text1)\u000a    operationComponents.append(practice_text2)\u000a    operationComponents.append(practice_text3)\u000a    operationComponents.append(practice_resp1)\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "operation"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = operationClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_text_4* updates\u000a        if t >= 0.0 and practice_text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text_4.tStart = t  # underestimates by a little under one frame\u000a            practice_text_4.frameNStart = frameN  # exact frame index\u000a            practice_text_4.setAutoDraw(True)\u000a        elif practice_text_4.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_text_4.setAutoDraw(False)\u000a        \u000a        # *practice_text1* updates\u000a        if t >= 1 and practice_text1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text1.tStart = t  # underestimates by a little under one frame\u000a            practice_text1.frameNStart = frameN  # exact frame index\u000a            practice_text1.setAutoDraw(True)\u000a        \u000a        # *practice_text2* updates\u000a        if t >= 1 and practice_text2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text2.tStart = t  # underestimates by a little under one frame\u000a            practice_text2.frameNStart = frameN  # exact frame index\u000a            practice_text2.setAutoDraw(True)\u000a        \u000a        # *practice_text3* updates\u000a        if t >= 1 and practice_text3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text3.tStart = t  # underestimates by a little under one frame\u000a            practice_text3.frameNStart = frameN  # exact frame index\u000a            practice_text3.setAutoDraw(True)\u000a        \u000a        # *practice_text4* updates\u000a        if t >= 1 and practice_text4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_text4.tStart = t  # underestimates by a little under one frame\u000a            practice_text4.frameNStart = frameN  # exact frame index\u000a            practice_text4.setAutoDraw(True)\u000a        \u000a        # *practice_resp1* updates\u000a        if t >= 1 and practice_resp1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp1.tStart = t  # underestimates by a little under one frame\u000a            practice_resp1.frameNStart = frameN  # exact frame index\u000a            practice_resp1.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a            \u000a        if practice_resp1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            if t >= 20:\u000a                practice_text1.setAutoDraw(False)\u000a                practice_text2.setAutoDraw(False)\u000a                practice_text3.setAutoDraw(False)\u000a                practice_text4.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp1.keys.extend(theseKeys)  # storing all keys\u000a                practice_resp1.rt.append(practice_resp1.clock.getTime())\u000a               # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in operationComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "operation"-------\u000a    for thisComponent in operationComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp1.keys in ['', [], None]:  # No response was made\u000a       practice_resp1.keys=None\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_encoding.keys',practice_resp1.keys)\u000a    if practice_resp1.keys != None:  # we had a response\u000a        practice_trials.addData('practice_encoding.rt', practice_resp1.rt)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    practice_x_is.setText("X = " + str(valuex))\u000a    practice_x_is.setPos([0, 0.1])\u000a    practice_y_is.setText("Y = " + str(valuey))\u000a    practice_y_is.setPos([0, -0.1])\u000a    practice_resp2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    practice_resp2.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(practice_center)\u000a    trialComponents.append(practice_x_is)\u000a    trialComponents.append(practice_y_is)\u000a    trialComponents.append(practice_resp2)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *practice_center* updates\u000a        if t >= 0.0 and practice_center.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_center.tStart = t  # underestimates by a little under one frame\u000a            practice_center.frameNStart = frameN  # exact frame index\u000a            practice_center.setAutoDraw(True)\u000a        elif practice_center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_center.setAutoDraw(False)\u000a        \u000a        # *practice_x_is* updates\u000a        if t >= 1 and practice_x_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_x_is.tStart = t  # underestimates by a little under one frame\u000a            practice_x_is.frameNStart = frameN  # exact frame index\u000a            practice_x_is.setAutoDraw(True)\u000a        \u000a        # *practice_y_is* updates\u000a        if t >= 1 and practice_y_is.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_y_is.tStart = t  # underestimates by a little under one frame\u000a            practice_y_is.frameNStart = frameN  # exact frame index\u000a            practice_y_is.setAutoDraw(True)\u000a        \u000a        # *practice_resp2* updates\u000a        if t >= 1 and practice_resp2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_resp2.tStart = t  # underestimates by a little under one frame\u000a            practice_resp2.frameNStart = frameN  # exact frame index\u000a            practice_resp2.status = STARTED\u000a            # keyboard checking is just starting\u000a            practice_resp2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a \u000a        if practice_resp2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a            \u000a            if t >= 20:\u000a                practice_x_is.setAutoDraw(False)\u000a                practice_y_is.setAutoDraw(False)\u000a                no_response.setAutoDraw(True)\u000a                \u000a            if t>=21:\u000a                no_response.setAutoDraw(False)\u000a                continueRoutine = False\u000a                \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                practice_resp2.keys = theseKeys[-1]  # just the last key pressed\u000a                practice_resp2.rt = practice_resp2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (practice_resp2.keys == str(correctresponse)) or (practice_resp2.keys == correctresponse):\u000a                    practice_resp2.corr = 1\u000a                else:\u000a                    practice_resp2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if practice_resp2.keys in ['', [], None]:  # No response was made\u000a       practice_resp2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(correctresponse).lower() == 'none': practice_resp2.corr = 1  # correct non-response\u000a       else: practice_resp2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for practice_trials (TrialHandler)\u000a    practice_trials.addData('practice_execution.keys',practice_resp2.keys)\u000a    practice_trials.addData('practice_execution.corr', practice_resp2.corr)\u000a    if practice_resp2.keys != None:  # we had a response\u000a        practice_trials.addData('practice_execution.rt', practice_resp2.rt)\u000a    \u000a    #------Prepare to start Routine "check"-------\u000a    t = 0\u000a    checkClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    if practice_resp2.corr:\u000a        message="Correct"\u000a        correct_practice.append(1)\u000a        total_practice.append(1)\u000a    \u000a    else:\u000a        message="Error"\u000a        total_practice.append(1)\u000a        \u000a    practice_feedback.setText(message)\u000a    practice_feedback.setPos([0, 0])\u000a    # keep track of which components have finished\u000a    checkComponents = []\u000a    checkComponents.append(practice_feedback)\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "check"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = checkClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *practice_feedback* updates\u000a        if t >= 0.0 and practice_feedback.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            practice_feedback.tStart = t  # underestimates by a little under one frame\u000a            practice_feedback.frameNStart = frameN  # exact frame index\u000a            practice_feedback.setAutoDraw(True)\u000a        elif practice_feedback.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            practice_feedback.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in checkComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "check"-------\u000a    for thisComponent in checkComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'practice_trials'\u000a\u000a\u000a#------Prepare to start Routine "record"-------\u000at = 0\u000arecordClock.reset()  # clock \u000aframeN = -1\u000a\u000aif len(total_practice) is not 0:\u000a    record_practice=int(100*len(correct_practice)/len(total_practice))\u000a    \u000apractice_record = visual.TextStim(win=win, ori=0, name='practice_record',\u000a    text='In the practice trial, you answered'+' '+str(record_practice)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a    units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# update component parameters for each repeat\u000apractice_record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000apractice_record_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000arecordComponents = []\u000arecordComponents.append(practice_record)\u000arecordComponents.append(practice_record_resp)\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "record"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = recordClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *practice_record* updates\u000a    if t >= 0.0 and practice_record.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record.tStart = t  # underestimates by a little under one frame\u000a        practice_record.frameNStart = frameN  # exact frame index\u000a        practice_record.setAutoDraw(True)\u000a    \u000a    # *practice_record_resp* updates\u000a    if t >= 0.0 and practice_record_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        practice_record_resp.tStart = t  # underestimates by a little under one frame\u000a        practice_record_resp.frameNStart = frameN  # exact frame index\u000a        practice_record_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if practice_record_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in recordComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "record"-------\u000afor thisComponent in recordComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a########### end of the practice trail############\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#------Prepare to start Routine "begining"-------\u000at = 0\u000abeginingClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000abegining_text.setText(u'The experiment is starting.\u005cnThere are eight blocks each consists of 18 trials.\u005cnYou will receive feedback after each block.\u005cnPlease respond as quickly and accurately as possible.\u005cnCall the experimenter when you are ready to move on.')\u000abegining_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000abegining_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000abeginingComponents = []\u000abeginingComponents.append(begining_text)\u000abeginingComponents.append(begining_resp)\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "begining"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = beginingClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *begining_text* updates\u000a    if t >= 0.0 and begining_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_text.tStart = t  # underestimates by a little under one frame\u000a        begining_text.frameNStart = frameN  # exact frame index\u000a        begining_text.setAutoDraw(True)\u000a    \u000a    # *begining_resp* updates\u000a    if t >= 0.0 and begining_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        begining_resp.tStart = t  # underestimates by a little under one frame\u000a        begining_resp.frameNStart = frameN  # exact frame index\u000a        begining_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if begining_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['k'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in beginingComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "begining"-------\u000afor thisComponent in beginingComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a#### block 1 is starting#######\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000ablocks=['block1.xlsx','block2.xlsx','block3.xlsx','block4.xlsx','block5.xlsx','block6.xlsx','block7.xlsx','block8.xlsx']\u000acomplete_blocks=[]\u000a\u000awhile len(complete_blocks)<=7:\u000a    \u000a    current_block=random.choice(blocks)\u000a    blocks.remove(current_block)\u000a    complete_blocks.append(current_block)\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    block = data.TrialHandler(nReps=1, method='fullRandom', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(current_block),\u000a        seed=None, name='block')\u000a    thisExp.addLoop(block)  # add the loop to the experiment\u000a    thisBlock = block.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisReal_trial.rgb)\u000a    \u000a    if thisBlock != None:\u000a        for paramName in thisBlock.keys():\u000a            exec(paramName + '= thisBlock.' + paramName)\u000a\u000a    for thisBlock in block:\u000a        currentLoop = block\u000a        # abbreviate parameter names if possible (e.g. rgb = thisReal_trial.rgb)\u000a        if thisBlock != None:\u000a            for paramName in thisBlock.keys():\u000a                exec(paramName + '= thisBlock.' + paramName)\u000a        \u000a        #------Prepare to start Routine "operation2"-------\u000a        t = 0\u000a        operation2Clock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        if Operatorc==0 and Operatord==0:\u000a            text_1.setText(Operatora)\u000a            text_1.setPos([0, 0.1])\u000a            text_2.setText(Operatorb)\u000a            text_2.setPos([0, -0.1])\u000a            text_3.setText("")\u000a            text_4.setText("")\u000a            \u000a        elif Operatorc is not 0 and Operatord==0:\u000a            text_1.setText(Operatorc)\u000a            text_1.setPos([0, 0.2])\u000a            text_2.setText(Operatora)\u000a            text_2.setPos([0, 0])\u000a            text_3.setText(Operatorb)\u000a            text_3.setPos([0, -0.2])\u000a            text_4.setText("")\u000a        else:\u000a            text_1.setText(Operatord)\u000a            text_1.setPos([0, 0.3])\u000a            text_2.setText(Operatorc)\u000a            text_2.setPos([0, 0.1])\u000a            text_3.setText(Operatora)\u000a            text_3.setPos([0, -0.1])\u000a            text_4.setText(Operatorb)\u000a            text_4.setPos([0, -0.3])\u000a\u000a        resp1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp1.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        operation2Components = []\u000a        operation2Components.append(text)\u000a        operation2Components.append(text_1)\u000a        operation2Components.append(text_2)\u000a        operation2Components.append(text_3)\u000a        operation2Components.append(text_4)\u000a        operation2Components.append(resp1)\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "operation2"-------\u000a        continueRoutine = True\u000a        skip =False\u000a        \u000a        while continueRoutine:\u000a            # get current time\u000a            t = operation2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text* updates\u000a            if t >= 0.0 and text.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text.tStart = t  # underestimates by a little under one frame\u000a                text.frameNStart = frameN  # exact frame index\u000a                text.setAutoDraw(True)\u000a            elif text.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text.setAutoDraw(False)\u000a            \u000a            # *text_1* updates\u000a            if t >= 1 and text_1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_1.tStart = t  # underestimates by a little under one frame\u000a                text_1.frameNStart = frameN  # exact frame index\u000a                text_1.setAutoDraw(True)\u000a            \u000a            # *text_2* updates\u000a            if t >= 1 and text_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_2.tStart = t  # underestimates by a little under one frame\u000a                text_2.frameNStart = frameN  # exact frame index\u000a                text_2.setAutoDraw(True)\u000a            \u000a            # *text_3* updates\u000a            if t >= 1 and text_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_3.tStart = t  # underestimates by a little under one frame\u000a                text_3.frameNStart = frameN  # exact frame index\u000a                text_3.setAutoDraw(True)\u000a            \u000a            # *text_4* updates\u000a            if t >= 1 and text_4.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_4.tStart = t  # underestimates by a little under one frame\u000a                text_4.frameNStart = frameN  # exact frame index\u000a                text_4.setAutoDraw(True)\u000a            \u000a            \u000a            # *resp1* updates\u000a            if t >= 1 and resp1.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp1.tStart = t  # underestimates by a little under one frame\u000a                resp1.frameNStart = frameN  # exact frame index\u000a                resp1.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp1.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp1.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                if t >= 20:\u000a                    text_1.setAutoDraw(False)\u000a                    text_2.setAutoDraw(False)\u000a                    text_3.setAutoDraw(False)\u000a                    text_4.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    skip = True\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                \u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp1.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp1.rt = resp1.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in operation2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "operation2"-------\u000a        for thisComponent in operation2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp1.keys in ['', [], None]:  # No response was made\u000a            resp1.keys=None\u000a        # store data for block1 (TrialHandler)\u000a        block.addData('encoding.keys',resp1.keys)\u000a        if resp1.keys != None:  # we had a response\u000a            block.addData('encoding.rt', resp1.rt)\u000a        \u000a        #------Prepare to start Routine "trial2"-------\u000a        t = 0\u000a        trial2Clock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        center.setText('+')\u000a        x_is.setText("X = " + str(X))\u000a        y_is.setText("Y = " + str(Y))\u000a        resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trial2Components = []\u000a        trial2Components.append(center)\u000a        trial2Components.append(x_is)\u000a        trial2Components.append(y_is)\u000a        trial2Components.append(resp_2)\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial2"-------\u000a        continueRoutine = True\u000a        if skip:\u000a            continueRoutine = False \u000a        while continueRoutine:\u000a            # get current time\u000a            t = trial2Clock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *center* updates\u000a            if t >= 0.0 and center.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                center.tStart = t  # underestimates by a little under one frame\u000a                center.frameNStart = frameN  # exact frame index\u000a                center.setAutoDraw(True)\u000a            elif center.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                center.setAutoDraw(False)\u000a            \u000a            # *x_is* updates\u000a            if t >= 1 and x_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                x_is.tStart = t  # underestimates by a little under one frame\u000a                x_is.frameNStart = frameN  # exact frame index\u000a                x_is.setAutoDraw(True)\u000a            \u000a            # *y_is* updates\u000a            if t >= 1 and y_is.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                y_is.tStart = t  # underestimates by a little under one frame\u000a                y_is.frameNStart = frameN  # exact frame index\u000a                y_is.setAutoDraw(True)\u000a            \u000a            # *resp_2* updates\u000a            if t >= 1 and resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                resp_2.tStart = t  # underestimates by a little under one frame\u000a                resp_2.frameNStart = frameN  # exact frame index\u000a                resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a                \u000a            if resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['1', '2', '3', '4', '5', '6', '7', '8', '9'])\u000a                \u000a                if t >= 20:\u000a                    x_is.setAutoDraw(False)\u000a                    y_is.setAutoDraw(False)\u000a                    no_response.setAutoDraw(True)\u000a                    \u000a                if t>=21:\u000a                    no_response.setAutoDraw(False)\u000a                    continueRoutine = False\u000a                    \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    no_response.setAutoDraw(False)\u000a                    resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    resp_2.rt = resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (resp_2.keys == str(CorrectResponse)) or (resp_2.keys == CorrectResponse):\u000a                        resp_2.corr = 1\u000a                        correct_block.append(1)\u000a                        total_block.append(1)\u000a                    else:\u000a                        resp_2.corr = 0\u000a                        total_block.append(1)\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial2Components:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial2"-------\u000a        for thisComponent in trial2Components:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if resp_2.keys in ['', [], None]:  # No response was made\u000a           resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str(CorrectResponse).lower() == 'none': resp_2.corr = 1  # correct non-response\u000a           else: resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for (TrialHandler)\u000a        block.addData('execution.keys',resp_2.keys)\u000a        block.addData('execution.corr', resp_2.corr)\u000a        if resp_2.keys != None:  # we had a response\u000a            block.addData('execution.rt', resp_2.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'block'\u000a\u000a    #------Prepare to start Routine "record2"-------\u000a    t = 0\u000a    record2Clock.reset()  # clock \u000a    frameN = -1\u000a\u000a    if len(total_block) is not 0:\u000a        record_block=int(100*len(correct_block)/len(total_block))\u000a\u000a    bloc_record = visual.TextStim(win=win, ori=0, name='bloc_record',\u000a        text='In this block, you answered'+' '+str(record_block)+'% correctly.\u005cnPlease press space key to move on.',    font='Arial',\u000a        units='cm', pos=[0, 0], height=1.4, wrapWidth=40,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    # update component parameters for each repeat\u000a    record_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    record_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    record2Components = []\u000a    record2Components.append(bloc_record)\u000a    record2Components.append(record_resp)\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "record2"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = record2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *bloc_record* updates\u000a        if t >= 0.0 and bloc_record.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bloc_record.tStart = t  # underestimates by a little under one frame\u000a            bloc_record.frameNStart = frameN  # exact frame index\u000a            bloc_record.setAutoDraw(True)\u000a        \u000a        # *record_resp* updates\u000a        if t >= 0.0 and record_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            record_resp.tStart = t  # underestimates by a little under one frame\u000a            record_resp.frameNStart = frameN  # exact frame index\u000a            record_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if record_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in record2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "record2"-------\u000a    for thisComponent in record2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    correct_block=[]\u000a    total_block=[]\u000a\u000a\u000a\u000a\u000a#--------thanks screen--------------\u000a\u000a\u000a#------Prepare to start Routine "thank"-------\u000at = 0\u000athankClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000athank_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000athank_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000athankComponents = []\u000athankComponents.append(thank_text)\u000athankComponents.append(thank_resp)\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thank"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = thankClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *thank_text* updates\u000a    if t >= 0.0 and thank_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_text.tStart = t  # underestimates by a little under one frame\u000a        thank_text.frameNStart = frameN  # exact frame index\u000a        thank_text.setAutoDraw(True)\u000a    \u000a    # *thank_resp* updates\u000a    if t >= 0.0 and thank_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        thank_resp.tStart = t  # underestimates by a little under one frame\u000a        thank_resp.frameNStart = frameN  # exact frame index\u000a        thank_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if thank_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "thank"-------\u000afor thisComponent in thankComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000awin.close()\u000acore.quit()\u000a\u000a\u000a\u000a
p1961
sg1501
(lp1962
sg1503
I73766480
sg10
g1570
sg6
g1505
sg1506
I1
sg24
I01
sg25
g26
sg1507
g1
(g1508
g1509
(dp1963
g22
g1511
(g1512
g1513
g1514
S'b'
tRp1964
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g1511
(g1512
g1513
g1514
S'b'
tRp1965
(I1
(I18
I1
tg1517
I00
S"\x00|{\x04\x00\x8cD\x04\x00<D\x04\xa0\x84C\x04\x00\x19C\x04\x00\xcfy\x04\xe0\xa5\x8d\x04\x00\xbaG\x04\xe0,\xe7\x03\x80\xbcx\x04\xc0\xc1B\x04 \x81O\x04@\x83'\x04\x80Z(\x04@1(\x04\x80\xdc\x8e\x04\xe0J3\x04\x80=(\x04"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg23
g1511
(g1512
g1513
g1514
S'b'
tRp1966
(I1
(I18
I1
tg1521
I00
S'4\xa7Q@\xe8\x8d\x0e@\x0e\xa9\x98?A<K@\\L\xf5@\xa1\x9e\x8c@\x00\x00\x00\x00\x1d\x10\xc6@1\x8e:A\xbfQ\x8b@#\xfb\x00A^\x98\x85A\xd67\x1bAf\xf8\x00A\x8ei%A0\xf5\x93A\x86\xb1\xfb@\x857\x98@'
S'\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1519
g1511
(g1512
g1513
g1514
S'b'
tRp1967
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g1511
(g1512
g1513
g1514
S'b'
tRp1968
(I1
(I18
I1
tg1517
I00
S'\xf0\xe8.\x01x\x02s\x01x\x02s\x01\xf0\xe8.\x01\xe8\xe7.\x01x\x02s\x01\xcc\x18\x1f\x1ex\x02s\x01\xf0\xe8.\x018\xec.\x01x\x02s\x01\xf0\x05|\x01 \xe9.\x01\xf0\xe8.\x01\xf0\xe8.\x01x\x02s\x01\xf0\x05|\x01x\x02s\x01'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1524
g1511
(g1512
g1513
g1514
S'b'
tRp1969
(I1
(I18
I1
tg1521
I00
S'\x00\x00\x88A\x00\x00\x80A\x00\x00\x80@\x00\x000A\x00\x00\x80?\x00\x00PA\x00\x00\x10A\x00\x00\x00\x00\x00\x00@A\x00\x00@@\x00\x00 A\x00\x00`A\x00\x00pA\x00\x00\x00@\x00\x00\xa0@\x00\x00\x00A\x00\x00\xe0@\x00\x00\xc0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g1511
(g1512
g1513
g1514
S'b'
tRp1970
(I1
(I18
I1
tg1521
I00
S'\xd7 \xda?\x1c\x19,?\xa3P\xf2?\\g\xa6?Q.\x94?\xa4\xae\x86@f\xfcf@\x85\xe1\x07@{\xc6\xba?\x88]\xbf?\xe3\x03\xeb?\x86\xfd;@{"M@\x1dq\x19@\xba\x8a\xec?\xae\xa6\xea?\xa3\x8b\xe2@\xbeb\xa3@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1971
(dp1972
g1529
(dp1973
g1519
I01
sg21
I00
sg20
I01
sg22
I01
sg19
I00
sg23
I01
sg1524
I01
ssg1531
g1959
sg1532
(lp1974
g1519
ag1524
ag19
ag20
ag21
ag22
ag23
asg1534
(lp1975
I18
aI1
asbsg1536
g1537
sg1538
g1539
(g1513
(I0
tS'b'
tRp1976
(I1
(I18
I1
tg1517
I00
(lp1977
I7
aI4
aI13
aI9
aI2
aI14
aI17
aI16
aI15
aI6
aI10
aI3
aI8
aI5
aI11
aI12
aI1
aI0
atbsg1542
I01
sg1543
I1
sg1544
I-1
sg1545
(lp1978
g1
(g1547
g1509
(dp1979
g1324
g1490
sVY
I4
sg1326
I2
sg1327
g1491
sg1335
I8
sg1332
I8
sg1333
g1349
sVX
I2
sg1329
I0
sg1337
g1434
sg1339
I0
sg1340
g1485
stRp1980
ag1
(g1547
g1509
(dp1981
g1324
g1481
sVY
I6
sg1326
I2
sg1327
g1482
sg1335
I2
sg1332
I2
sg1333
g1349
sVX
I6
sg1329
I0
sg1337
g1334
sg1339
I0
sg1340
g1485
stRp1982
ag1
(g1547
g1509
(dp1983
g1324
g1378
sVY
I7
sg1326
I2
sg1327
g1379
sg1335
I2
sg1332
I2
sg1333
g1369
sVX
I8
sg1329
I0
sg1337
g1349
sg1339
I0
sg1340
g1382
stRp1984
ag1
(g1547
g1509
(dp1985
g1324
g1440
sVY
I4
sg1326
I2
sg1327
g1441
sg1335
I8
sg1332
I8
sg1333
g1359
sVX
I4
sg1329
I0
sg1337
g1391
sg1339
I0
sg1340
g1382
stRp1986
ag1
(g1547
g1509
(dp1987
g1324
g1346
sVY
I4
sg1326
I3
sg1327
g1347
sg1335
I1
sg1332
I1
sg1333
g1349
sVX
I6
sg1329
g1330
sg1337
g1334
sg1339
I0
sg1340
g1351
stRp1988
ag1
(g1547
g1509
(dp1989
g1324
g1456
sVY
I4
sg1326
I3
sg1327
g1457
sg1335
I2
sg1332
I2
sg1333
g1391
sVX
I4
sg1329
g1371
sg1337
g1369
sg1339
I0
sg1340
g1351
stRp1990
ag1
(g1547
g1509
(dp1991
g1324
g1422
sVY
I7
sg1326
I3
sg1327
g1423
sg1335
I1
sg1332
I1
sg1333
g1369
sVX
I3
sg1329
g1371
sg1337
g1391
sg1339
I0
sg1340
g1341
stRp1992
ag1
(g1547
g1509
(dp1993
g1324
g1325
sVY
I3
sg1326
I3
sg1327
g1328
sg1335
I2
sg1332
I2
sg1333
g1334
sVX
I9
sg1329
g1330
sg1337
g1338
sg1339
I0
sg1340
g1341
stRp1994
ag1
(g1547
g1509
(dp1995
g1324
g1448
sVY
I2
sg1326
I3
sg1327
g1449
sg1335
I8
sg1332
I8
sg1333
g1361
sVX
I7
sg1329
g1369
sg1337
g1349
sg1339
I0
sg1340
g1373
stRp1996
ag1
(g1547
g1509
(dp1997
g1324
g1367
sVY
I3
sg1326
I3
sg1327
g1368
sg1335
I6
sg1332
I6
sg1333
g1371
sVX
I4
sg1329
g1369
sg1337
g1349
sg1339
I0
sg1340
g1373
stRp1998
ag1
(g1547
g1509
(dp1999
g1324
g1430
sVY
I6
sg1326
I4
sg1327
g1431
sg1335
I7
sg1332
I7
sg1333
g1330
sVX
I4
sg1329
g1338
sg1337
g1434
sg1339
g1391
sg1340
g1435
stRp2000
ag1
(g1547
g1509
(dp2001
g1324
g1464
sVY
I5
sg1326
I4
sg1327
g1465
sg1335
I1
sg1332
I1
sg1333
g1338
sVX
I6
sg1329
g1349
sg1337
g1334
sg1339
g1330
sg1340
g1435
stRp2002
ag1
(g1547
g1509
(dp2003
g1324
g1472
sVY
I4
sg1326
I4
sg1327
g1473
sg1335
I9
sg1332
I9
sg1333
g1434
sVX
I9
sg1329
g1349
sg1337
g1476
sg1339
g1330
sg1340
g1362
stRp2004
ag1
(g1547
g1509
(dp2005
g1324
g1356
sVY
I4
sg1326
I4
sg1327
g1357
sg1335
I7
sg1332
I7
sg1333
g1359
sVX
I3
sg1329
g1349
sg1337
g1361
sg1339
g1330
sg1340
g1362
stRp2006
ag1
(g1547
g1509
(dp2007
g1324
g1387
sVY
I6
sg1326
I4
sg1327
g1388
sg1335
I3
sg1332
I3
sg1333
g1330
sVX
I4
sg1329
g1359
sg1337
g1361
sg1339
g1391
sg1340
g1392
stRp2008
ag1
(g1547
g1509
(dp2009
g1324
g1414
sVY
I8
sg1326
I4
sg1327
g1415
sg1335
I6
sg1332
I6
sg1333
g1371
sVX
I9
sg1329
g1334
sg1337
g1349
sg1339
g1361
sg1340
g1392
stRp2010
ag1
(g1547
g1509
(dp2011
g1324
g1406
sVY
I2
sg1326
I4
sg1327
g1407
sg1335
I5
sg1332
I5
sg1333
g1391
sVX
I8
sg1329
g1371
sg1337
g1361
sg1339
g1334
sg1340
g1401
stRp2012
ag1
(g1547
g1509
(dp2013
g1324
g1397
sVY
I4
sg1326
I4
sg1327
g1398
sg1335
I4
sg1332
I4
sg1333
g1361
sVX
I4
sg1329
g1371
sg1337
g1349
sg1339
g1334
sg1340
g1401
stRp2014
asg1560
Nsg1561
I0
sg1562
I18
sg1563
I0
sg1564
I18
sg1565
I01
sbasS'savePickle'
p2015
I00
sb.